<!DOCTYPE html>
<html lang="es">
<head>
    <!-- SweetAlert2 CSS -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11.7.32/dist/sweetalert2.min.css">
    <!-- SweetAlert2 JS -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.7.32/dist/sweetalert2.all.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    <meta charset="UTF-8" />
    <title>Sistema de cubicaje - Comercializadora de Llantas Tres Siglos</title>
    <link rel="icon" type="image/png" href="https://http2.mlstatic.com/storage/mshops-appearance-api/images/13/1184895213/logo-2022082314215812800.png">
    <script src="js/distribucionOptima.js"></script>
    <style>
    body {
        background-image: url('https://www.romacarabs.com/wp-content/uploads/2024/05/Llantas-de-un-coche.jpg');
        background-size: cover;
        background-position: center;
        background-attachment: fixed;
        background-repeat: no-repeat;
        min-height: 100vh;
        margin: 0;
        padding: 20px;
    }

    /* Ajustar opacidad del fondo de las secciones para mejor legibilidad */
    section {
        background: rgba(255,255,255,0.95);
        backdrop-filter: blur(5px);
    }

    /* Mejorar visibilidad del header */
    header {
        background: rgba(255,255,255,0.95);
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        backdrop-filter: blur(5px);
        display: flex;
        align-items: center;
    }

    /* Ajustar nav para que se vea mejor con el fondo */
    nav {
        background: rgba(176, 218, 185, 0.95);
        border-radius: 10px;
        backdrop-filter: blur(5px);
    }

    /* Agregar aqu√≠ los nuevos estilos */
    #tablaPedidosActuales td:last-child {
        min-width: 400px; /* Ancho m√≠nimo para los botones */
        white-space: nowrap; /* Evita que los botones se envuelvan */
   }
       #tablaPedidosActuales .btn {
           margin: 2px; /* Espacio entre botones */
           display: inline-block; /* Asegura que los botones se muestren en l√≠nea */
     }
    section {
        background: rgba(255,255,255,0.65); /* Menos opaco, se ve m√°s la imagen */
        border-radius: 16px;
        margin: 32px auto 16px auto;
        max-width: 1200px;
        box-shadow: 0 8px 32px rgba(72,144,81,0.13);
        padding: 28px 22px;
    }
    header img {
        height: 44px;
        margin-right: 12px;
        opacity: 0.7;
    }
    nav {
        display: flex;
        background: #b0dab9e6;
    }
    nav button {
        flex: 1;
        padding: 12px 0;
        color: #24412b;
        background: transparent;
        border: none;
        cursor: pointer;
        font-weight: bold;
        letter-spacing: 1px;
        transition: background 0.3s;
    }
    nav button:hover, nav button.active {
        background: #d9efe0;
    }
        .tabcontent {
            display: none;
            background: transparent;
        }
        .tabcontent.active {
            display: block;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
        }
        th, td {
            border: 1px solid #e2e2e2;
            padding: 8px 12px;
            text-align: center;
        }
        th {
            background: #f7fcf8;
        }
        .search-bar {
            margin-top: 8px;
            margin-bottom: 12px;
            padding: 7px;
            font-size: 17px;
            border-radius: 5px;
            border: 1px solid #cde5d4;
            flex-grow: 1;
        }
        button.primary {
            background: #489051;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            padding: 8px 18px;
            font-weight: bold;
            margin-top: 0;
            transition: background 0.3s;
            white-space: nowrap;
        }
        button.primary:hover {
            background: #75c286;
        }
        .highlight-yellow {
            background-color: #fffa8b;
            transition: background-color 1s;
        }
        .graph-container {
            width: 30%;
            background: #f5fdf7;
            padding: 16px;
            border-radius: 14px;
            border: 1px solid #e2e2e2;
            margin: 8px 5px 16px 0;
            display: inline-block;
            vertical-align: top;
            box-shadow: 0 3px 12px #d6eedd83;
        }
        @media (max-width: 900px){
            .graph-container{ width: 95%; margin:auto; margin-bottom:16px;}
        }
        /* Estilos para la secci√≥n de b√∫squeda de bloques */
        #modoBusqueda .accordion-button {
            padding: 0.75rem 1rem;
            background-color: #f8f9fa;
            border: none;
        }

        #modoBusqueda .accordion-button:not(.collapsed) {
            background-color: #e9ecef;
            color: #212529;
            box-shadow: none;
        }

        #modoBusqueda .list-group-item {
            border-radius: 0;
            border-left: none;
            border-right: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        #modoBusqueda .list-group-item:hover {
            background-color: #f8f9fa;
        }

        #modoBusqueda .table-sm td {
            padding: 0.5rem;
            vertical-align: middle;
        }

        #modoBusqueda .badge {
            font-weight: normal;
            font-size: 0.85em;
        }

        #resultadosBusqueda {
            max-height: 400px;
            overflow-y: auto;
        }

        .search-and-button {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            max-width: 700px;
            flex-wrap: wrap;
        }

        /* Estilos para las eficiencias */
        .eficiencia-badge {
            min-width: 60px;
            text-align: center;
            padding: 0.25em 0.6em;
            border-radius: 12px;
        }

        .eficiencia-alta { background-color: #28a745; color: white; }
        .eficiencia-media { background-color: #ffc107; color: black; }
        .eficiencia-baja { background-color: #dc3545; color: white; }
        /* Modal and Form Styles */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 1000;
            left: 0; top: 0;
            width: 100%; height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            animation: fadeIn 0.3s;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 2% auto;
            padding: 20px;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            position: relative;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            animation: slideIn 0.3s;
        }
        .close {
            position: absolute;
            right: 20px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #666;
            transition: color 0.3s;
        }
        .close:hover {
            color: #000;
        }
        form.add-form label {
            display: block;
            margin: 12px 0 5px 0;
            font-weight: bold;
            color: #35672b;
        }
        form.add-form input[type=text], 
        form.add-form input[type=number] {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #a3d087;
            border-radius: 6px;
            box-sizing: border-box;
            margin-bottom: 12px;
            font-size: 16px;
            color: #24412b;
        }
        form.add-form button.submit-btn {
            margin-top: 10px;
            padding: 10px 20px;
            background: #489051;
            color: white;
            border: none;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s;
            width: 100%;
            font-size: 17px;
        }
        form.add-form button.submit-btn:hover {
            background: #75c286;
        }
        .msg {
            margin: 8px 0 0 0;
            font-size: 15px;
            min-height: 20px;
        }
        .msg.success { color: green; }
        .msg.error { color: rgb(255, 0, 0); }
        /* Agregar dentro de la secci√≥n <style> existente */
        .alerta-flotante {
            position: fixed;
            bottom: 20px;     
            right: 20px;
            background: white;
            border: 2px solid #75c286;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            max-width: 300px;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        .alerta-flotante button {
            position: absolute;
            top: 5px;
            right: 5px;
            border: none;
            background: none;
            cursor: pointer;
        }
        
        #autocompleteUnidadesPedido {
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        #autocompleteUnidadesPedido > div:hover {
            background: #f0f0f0 !important;
        }
        /* --- Estilos modernos para traspasos --- */
        .btn-gradient {
            background: linear-gradient(90deg, #2193b0 0%, #6dd5ed 100%);
            color: #fff;
            border: none;
            font-weight: bold;
            transition: background 0.3s;
        }
        .btn-gradient:hover {
            background: linear-gradient(90deg, #6dd5ed 0%, #2193b0 100%);
            color: #fff;
        }
        .card {
            border-radius: 1.5rem;
            box-shadow: 0 8px 32px rgba(33,147,176,0.15);
        }
        #facturaResult {
            animation: fadeIn 0.7s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @import url('https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css');

        /* Estilos para la secci√≥n de b√∫squeda de bloques */
        .accordion-button:not(.collapsed) {
            background-color: #e8f5e9;
            color: #2e7d32;
        }

        .accordion-button:focus {
            border-color: #4caf50;
            box-shadow: 0 0 0 0.25rem rgba(76, 175, 80, 0.25);
        }

        #seccionUnidadSugeridaBusqueda .table {
            font-size: 0.9rem;
        }

        #seccionUnidadSugeridaBusqueda .table th {
            background-color: #f8f9fa;
            font-weight: 600;
        }

        #seccionUnidadSugeridaBusqueda .badge {
            font-size: 0.8rem;
            padding: 0.4em 0.6em;
        }

        .eficiencia-badge {
            background: linear-gradient(45deg, #4caf50, #81c784);
            color: white;
            border-radius: 12px;
            padding: 0.3em 0.8em;
        }

        #totalLlantas {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .accordion-body {
            padding: 0.5rem;
        }

        .table-sm td, .table-sm th {
            padding: 0.5rem;
        }
    </style>   
</head>    
<body>
<!-- Modal instrucciones -->
<div id="modalInstrucciones" class="modal">
    <div class="modal-content" style="max-width: 800px; padding: 30px;">
        <span class="close" onclick="cerrarInstrucciones()">&times;</span>
        <div style="text-align: center; margin-bottom: 20px;">
            <img src="https://cdn.prod.website-files.com/62b4e3084bb69b3cbd747e80/62b4e344650db7626d857053_TS_ORGINAL_LOGO.png" 
                 alt="Logo Tres Siglos" 
                 style="height: 60px; margin-bottom: 20px;">
            <h2 style="color: #489051;">Bienvenido al Sistema de Cubicaje Tres Siglos</h2>
        </div>
        <button onclick="cerrarInstrucciones()" class="btn btn-lg btn-success">
               Cerrar instrucciones
        </button>
        <div class="row">
            <div class="col-md-6">
                <div class="card mb-3">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0">üè≠ Gesti√≥n de INVENTARIO</h5>
                    </div>
                    <div class="card-body">
                        <ul class="list-unstyled">
                            <li>‚úì Consulta el INVENTARIO actual</li>
                            <li>‚úì Agrega nuevas llantas</li>
                            <li>‚úì Edita informaci√≥n existente</li>
                            <li>‚úì Calcula vol√∫menes autom√°ticamente</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6">
                <div class="card mb-3">
                    <div class="card-header bg-success text-white">
                        <h5 class="mb-0">üöõ Control de Flota</h5>
                    </div>
                    <div class="card-body">
                        <ul class="list-unstyled">
                            <li>‚úì Administra unidades de transporte</li>
                            <li>‚úì Controla capacidades y l√≠mites</li>
                            <li>‚úì Asigna responsables</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-6">
                <div class="card mb-3">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0">üì¶ Gesti√≥n de Pedidos</h5>
                    </div>
                    <div class="card-body">
                        <ul class="list-unstyled">
                            <li>‚úì Calcula de manera rapida capacidades</li>
                            <li>‚úì Control de volumen y peso</li>
                            <li>‚úì Sugerencias autom√°ticas</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6">
                <div class="card mb-3">
                    <div class="card-header bg-warning">
                        <h5 class="mb-0">üìÑ Escaneo de Documentos</h5>
                    </div>
                    <div class="card-body">
                        <ul class="list-unstyled">
                            <li>‚úì Escanea traspasos y traspasos</li>
                            <li>‚úì Procesamiento autom√°tico</li>
                            <li>‚úì Gesti√≥n de bloques</li>
                            <li>‚úì Historial de documentos</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="alert alert-info mt-3">
            <h5>üí° Tips r√°pidos:</h5>
            <ul>
                <li>Usa la barra de b√∫squeda para filtrar informaci√≥n r√°pidamente</li>
                <li>El bot√≥n de ayuda (‚ùî) estar√° siempre disponible en la esquina inferior izquierda</li>
                <li>Monitorea las alertas de capacidad en tiempo real</li>
                <li>Guarda frecuentemente los cambios importantes</li>
            </ul>
        </div>

        <div class="text-center mt-4">
        </div>
    </div>
</div>

<style>
/* Estilos para el modal de instrucciones */
.modal {
    display: none;
    position: fixed;
    z-index: 9999;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    animation: fadeIn 0.3s;

}

.modal-content {
    background-color: #fefefe;
    margin: 2% auto;
    border-radius: 15px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    animation: slideIn 0.3s;
    max-height: 95vh;
    overflow-y: auto;
}

.close {
    position: absolute;
    right: 20px;
    top: 15px;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    color: #666;
    transition: color 0.3s;
}

.close:hover {
    color: #000;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideIn {
    from { transform: translateY(-100px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

.card {
    transition: transform 0.2s;
}

.card:hover {
    transform: translateY(-5px);
}

.list-unstyled li {
    margin-bottom: 8px;
    padding-left: 20px;
    position: relative;
}

.list-unstyled li:before {
    content: "‚úì";
    position: absolute;
    left: 0;
    color: #489051;
}
</style>

<script>
// Scripts para el modal

// Funci√≥n para cargar las descripciones de llantas
async function cargarDescripcionesLlantas() { 
    try {
        const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=Apartados');
        if (!response.ok) {
            throw new Error('Error al cargar datos de llantas');
        }
        const data = filterMeaningfulRows(await response.json());
        return data;
    } catch (error) {
        console.error('Error al cargar descripciones de llantas:', error);
        throw error;
    }
}  
// Funci√≥n para inicializar la aplicaci√≥n
async function inicializarAplicacion() {
    try {
        await cargarDatosDesdeSheetDB();
        await cargarReservasDePendientes();
        console.log('Datos cargados correctamente');
    } catch (error) {
        console.error('Error al inicializar la aplicaci√≥n:', error);
    }
}

// Utilidades num√©ricas globales (definidas temprano para evitar errores de referencia)
function parseNumber(input) {
    if (input === null || input === undefined) return 0;
    if (typeof input === 'number') return isNaN(input) ? 0 : input;
    let s = String(input).trim();
    if (s === '') return 0;
    s = s.replace(/\$/g, '').replace(/\s+/g, '');
    if (s.indexOf(',') > -1 && s.indexOf('.') > -1) {
        s = s.replace(/,/g, '');
    } else if (s.indexOf(',') > -1 && s.indexOf('.') === -1) {
        s = s.replace(/,/g, '.');
    }
    const n = parseFloat(s);
    return isNaN(n) ? 0 : n;
}

function formatNumber(value, decimals = 2) {
    const opts = { minimumFractionDigits: decimals, maximumFractionDigits: decimals };
    try {
        return new Intl.NumberFormat('es-MX', opts).format(Number(value) || 0);
    } catch (e) {
        return (Number(value) || 0).toFixed(decimals).replace('.', ',');
    }
}

function getNumericTotal(elementId) {
    const el = document.getElementById(elementId);
    if (!el) return 0;
    if (el.dataset && el.dataset.value !== undefined) {
        return parseNumber(el.dataset.value);
    }
    return parseNumber(el.textContent || el.innerText || '0');
}

// App Initialization
document.addEventListener('DOMContentLoaded', function() {
    // Initialize app core
    const appInitializer = {
        init: async function() {
            await inicializarAplicacion();
            this.setupInstructions();
            this.setupHelpButton();
            this.setupEventListeners();
            try { await actualizarUnidadesDisponibles(); } catch(e) { console.warn('No se pudieron actualizar unidades al inicio:', e); }
            try { decidirMostrarDistribucion(); } catch(e) { /* ignore */ }
        },

        setupInstructions: function() {
            window.mostrarInstrucciones = () => {
                document.getElementById('modalInstrucciones').style.display = 'block';
            };

            window.cerrarInstrucciones = () => {
                document.getElementById('modalInstrucciones').style.display = 'none';
                localStorage.setItem('instruccionesVistas', 'true');
            };

            // Show instructions modal with delay
            setTimeout(mostrarInstrucciones, 500);
        },

        setupHelpButton: function() {
            const btnAyuda = document.createElement('button');
            btnAyuda.innerHTML = '‚ùî Ayuda';
            btnAyuda.className = 'help-button';
            btnAyuda.onclick = mostrarInstrucciones;
            
            // Add button styles via CSS class instead of inline styles
            const style = document.createElement('style');
            style.textContent = `
                .help-button {
                    position: fixed;
                    bottom: 20px;
                    left: 20px;
                    background: #489051;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    padding: 10px 15px;
                    cursor: pointer;
                    z-index: 999;
                    transition: all 0.3s ease;
                }
                .help-button:hover {
                    transform: scale(1.1);
                    background: #5aad64;
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(btnAyuda);
        },

        setupEventListeners: function() {
            // Cerrar dropdowns de autocomplete cuando se hace clic afuera
            document.addEventListener('click', (e) => {
                const dropdown = document.getElementById('autocompleteUnidadesPedido');
                const input = document.getElementById('inputPedidoNumEconomico');
                if (dropdown && input && !input.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.style.display = 'none';
                }
            });

            // Listener para el filtro de ubicaciones (si existe)
            const filtroSel = document.getElementById('filtroUbicacionUnidades');
            if (filtroSel) {
                filtroSel.addEventListener('change', () => {
                    actualizarUnidadesDisponibles();
                });
            }
        }
    };

    // Initialize the application
    appInitializer.init();
});
</script>    

<header>
    <img src="https://cdn.prod.website-files.com/62b4e3084bb69b3cbd747e80/62b4e344650db7626d857053_TS_ORGINAL_LOGO.png" alt="Logo Tres Siglos" />
    <h1>Sistema de cubicaje - Comercializadora de Llantas Tres Siglos</h1>
    <div style="margin-left: auto; display:flex; gap:8px; align-items:center;">
    </div>
</header>

<nav>   
    <button class="tablink active" data-tab="inventario">inventario</button>
    <button class="tablink" data-tab="flota">Flota</button>
    <button class="tablink" data-tab="traspasos" onclick="actualizarBloquestraspasos()">Escaneo de traspasos y facturas </button> 
    <button class="tablink" data-tab="pedidos">Pedidos</button>
    <button class="tablink" data-tab="sugerencia-unidad">Sugerencia de Unidad</button>
    <button class="tablink" data-tab="calculo-rapido">C√°lculo R√°pido</button>
    <button class="tablink" data-tab="pedidos-Apartados">Pedidos Apartados</button>
</nav>

<!-- Pedidos Apartados -->
<div id="pedidos-Apartados" class="tabcontent">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h3>Pedidos Apartados</h3>
        <button class="btn btn-primary" onclick="generarPDFPedidosApartados()">
            <i class="bi bi-file-pdf-fill me-2"></i>Imprimir Reporte
        </button>      
    </div>
    <div class="card">
        <div class="card-body">
            <!-- Agregar barra de b√∫squeda -->
            <div class="mb-3">
                <div class="input-group">
                    <span class="input-group-text">
                        <i class="bi bi-search"></i>
                    </span>
                    <input type="text" 
                           class="form-control" 
                           id="busquedaApartados" 
                           placeholder="Buscar por n√∫mero econ√≥mico..." 
                           oninput="buscarPedidoConfirmado()">
                     </div>
                </div>
            <div class="table-responsive">
                <table class="table table-bordered">
                    <thead class="table-light">
                        <tr>
                            <th>Fecha</th>
                            <th>Unidad</th>
                            <th>Econ√≥mico</th>
                            <th>Nombre</th>
                            <th>Llantas</th>
                            <th>Descripci√≥n</th>
                            <th>Volumen</th>
                            <th>Peso</th>
                            <th>Acciones</th>  
                        </tr>
                    </thead>
                    <tbody id="tablaPedidosApartados">
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<!-- Modal para editar pedido apartado -->
<div id="editarPedidoModal" class="custom-modal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:2000;">
    <div style="max-width:700px; margin:40px auto; background:#fff; border-radius:8px; position:relative; display:flex; flex-direction:column; max-height:calc(100vh - 80px);">
        <div style="padding:20px; overflow:auto; flex:1;">
            <h5>Editar Pedido Apartado</h5>
            <div style="margin-top:12px;">
                <div class="mb-2">
                    <label>Fecha</label>
                    <input id="editPedidoFecha" class="form-control" type="text" />
                </div>
                <div class="mb-2">
                    <label>Unidad</label>
                    <input id="editPedidoUnidad" class="form-control" type="text" />
                </div>
                <div class="mb-2">
                    <label>Econ√≥mico</label>
                    <input id="editPedidoEconomico" class="form-control" type="text" />
                </div>
                <div class="mb-2">
                    <label>Nombre</label>
                    <input id="editPedidoNombre" class="form-control" type="text" />
                </div>
                <div class="mb-2">
                    <label>Llantas</label>
                    <input id="editPedidoLlantas" class="form-control" type="number" min="0" />
                </div>
                <div class="mb-2">
                    <label>Descripci√≥n</label>
                    <textarea id="editPedidoDescripcion" class="form-control" rows="3"></textarea>
                </div>
                <div class="row">
                    <div class="col-md-6 mb-2">
                        <label>Volumen (m¬≥)</label>
                        <input id="editPedidoVolumen" class="form-control" type="number" step="0.01" />
                    </div>
                    <div class="col-md-6 mb-2">
                        <label>Peso (kg)</label>
                        <input id="editPedidoPeso" class="form-control" type="number" step="0.01" />
                    </div>
                </div>
            </div>
        </div>
        <div style="padding:12px 20px; border-top:1px solid #eee; display:flex; justify-content:flex-end; gap:8px; background:#fff; position:sticky; bottom:0;">
            <button class="btn btn-secondary" onclick="cerrarEditarPedidoModal()">Cancelar</button>
            <button class="btn btn-primary" onclick="guardarPedidoEditado()">Guardar cambios</button>
        </div>
    </div>
</div>

<section>

    <!-- INVENTARIO -->
    <div id="INVENTARIO" class="tabcontent active">
        <div class="search-and-button">
            <input type="text" id="searchINVENTARIO" class="search-bar" placeholder="Buscar por ID Llanta..." oninput="searchINVENTARIO()" />
            <button class="primary" onclick="openModal('modalINVENTARIO')">Agregar Llanta</button>
            <button class="primary" onclick="calcularPesosINVENTARIO()">Calcular Pesos Aproximados</button>
            <button class="primary" onclick="calcularVolumenINVENTARIO()">Calcular Vol√∫menes</button>
        </div>

        <div id="loadingMessage" style="display:none;">Calculando vol√∫menes...</div>

        <table id="tablaINVENTARIO">
            <thead>
                <tr>
                    <th>clave</th>
                    <th>Descripci√≥n</th>
                    <th>L√≠nea</th>
                    <th>Peso (kg)</th>
                    <th>Volumen (m¬≥)</th>
                    <th>Valor ($)</th>
                    <th>Acciones</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <!-- Modal INVENTARIO -->
    <div id="modalINVENTARIO" class="modal">
    <div id="loadingMessage" style="display:none;">Calculando vol√∫menes...</div>
    <div class="modal-content">
        <span class="close" onclick="closeModal('modalINVENTARIO')">&times;</span>
        <form id="formAgregarLlanta" class="add-form" onsubmit="event.preventDefault(); agregarNuevaLlanta();">
            <h3>Agregar Nueva Llanta</h3>
            
            <!-- Campos requeridos -->
            <label for="agregarId">ID (requerido) *</label>
            <input type="text" 
                   id="agregarId" 
                   placeholder="Ejemplo: 1001" 
                   required />

            <label for="agregarDescripcion">Descripci√≥n (requerido) *</label>
            <input type="text" 
                   id="agregarDescripcion" 
                   placeholder="Descripci√≥n de la llanta" 
                   required />

            <!-- Campos opcionales -->
            <label for="agregarPeso">Peso (kg) (opcional)</label>
            <input type="number" 
                   id="agregarPeso" 
                   step="0.01" 
                   min="0" 
                   placeholder="Ejemplo: 12.5" />

            <label for="agregarVolumen">Volumen unitario (m¬≥) (opcional)</label>
            <input type="number" 
                   id="agregarVolumen" 
                   step="0.0001" 
                   min="0" 
                   placeholder="Ejemplo: 0.0035" />

            <div id="agregarCalcInfo" style="font-size:0.9em;color:#666;margin-top:6px;">
                Valores calculados autom√°ticamente (aprox.) al escribir la descripci√≥n. Puedes editar manualmente.
            </div>

            <label for="agregarValor">Valor unitario ($) (opcional)</label>
            <input type="number" 
                   id="agregarValor" 
                   step="0.01" 
                   min="0" 
                   placeholder="Ejemplo: 1500.00" />

            <label for="agregarLinea">L√≠nea (opcional)</label>
            <input type="text" 
                   id="agregarLinea" 
                   placeholder="Ejemplo: Industrial" />

            <button type="submit" class="submit-btn">Agregar Llanta</button>
            <div id="msgINVENTARIO" class="msg"></div>
        </form>
    </div>
</div>    
 
    <!-- Flota -->
    <div id="calculo-rapido" class="tabcontent" style="max-width:900px;">
        <h3>C√°lculo R√°pido</h3>
        <div class="card mb-3">
            <div class="card-body">
                <div class="row g-2 align-items-end">
                    <div class="col-md-3">
                        <label>Tipo</label>
                        <select id="calcRapidaTipo" class="form-control">
                            <option value="AUTO">Auto</option>
                            <option value="SUV_CAMIONETA">Camioneta / SUV</option>
                            <option value="COMERCIAL_LIGERO">Comercial ligero</option>
                            <option value="PESADO">Cami√≥n</option>
                            <option value="AGRICOLA_MINERO">Agr√≠cola / Minero</option>
                            <option value="CAMARAS">C√°maras</option>
                        </select>
                    </div>
                    <div class="col-md-2">
                        <label>Cantidad</label>
                        <input type="number" id="calcRapidaCantidad" class="form-control" min="1" value="1">
                    </div>
                    <div class="col-md-3">
                        <label>Filtrar por Ubicaci√≥n</label>
                        <select id="calcRapidaFiltroUbicacion" class="form-select">
                            <option value="Todos">Todos</option>
                        </select>
                    </div>
                    <div class="col-md-4 d-flex gap-2">
                        <button class="btn btn-success" onclick="addCombinationCalcRapida()"><i class="bi bi-plus-circle"></i> Agregar combinaci√≥n</button>
                        <button class="btn btn-primary" onclick="calcularSugerenciaCalcRapida()"><i class="bi bi-truck"></i> Calcular sugerencia</button>
                        <button class="btn btn-danger" onclick="limpiarCalcRapida()"><i class="bi bi-trash"></i> Limpiar</button>
                    </div>
                </div>
            </div>
            <div class="card-body">
                <div id="combinacionesCalcRapidaList" style="min-height:40px;"></div>
                <div id="totalesCalcRapida" style="margin-top:8px;font-weight:bold;"></div>
                <div id="resultadoCalcRapida" class="mt-3"></div>
            </div>
        </div>
    </div>

    <div id="flota" class="tabcontent">
        <div class="search-and-button">
            <input type="text" id="searchFlota" class="search-bar" placeholder="Buscar por N√∫mero Econ√≥mico..." oninput="searchFlota()" />
            <button class="primary" onclick="openModal('modalFlota')">Agregar Cami√≥n</button>
            <button class="primary" onclick="fetchFlota()">Actualizar flota</button>
        </div>

        <table id="tablaFlota">
            <thead>
                <tr>
                    <th>Econ√≥mico</th>
                    <th>Unidad</th>
                    <th>Asignado</th>
                    <th>Modelo</th>
                    <th>identificacion</th>
                    <th>Ubicaci√≥n</th>
                    <th>capacidad de carga (kg)</th>
                    <th>Volumen (m¬≥)</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <!-- Modal Flota -->
    <div id="modalFlota" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('modalFlota')">&times;</span>
            <form id="formAgregarCamion" class="add-form" onsubmit="event.preventDefault(); agregarNuevoCamion();">
                <h3>Agregar Nuevo Cami√≥n</h3>

                <label for="agregarEconomico">N√∫mero Econ√≥mico (dejar vac√≠o para autogenerar)</label>
                <input type="text" id="agregarEconomico" placeholder="Ejemplo: 101 o dejar vac√≠o para auto" />

                <label for="agregarUnidad">Unidad</label>
                <input type="text" id="agregarUnidad" placeholder="Unidad/veh√≠culo" required />

                <label for="agregarAsignado">Asignado</label>
                <input type="text" id="agregarAsignado" placeholder="Nombre responsable" required />

                <label for="agregarModelo">Modelo</label>
                <input type="text" id="agregarModelo" placeholder="Modelo del cami√≥n" required />

                <label for="agregarPlacas">Placas</label>
                <input type="text" id="agregarPlacas" placeholder="Placas del cami√≥n" required />

                <label for="agregarUbicacion">Ubicaci√≥n</label>
                <input type="text" id="agregarUbicacion" placeholder="Ubicaci√≥n del cami√≥n" required />

                <label for="agregarCarga">Capacidad de Carga (kg)</label>
                <input type="number" id="agregarCarga" step="0.01" min="0" placeholder="Ejemplo: 15000" required />

                <label for="agregarVolumenCamion">Capacidad de Volumen (m¬≥)</label>
                <input type="number" id="agregarVolumenCamion" step="0.0001" min="0" placeholder="Ejemplo: 40.5" required />

                <button type="submit" class="submit-btn">Agregar Cami√≥n</button>
                <div id="msgFlota" class="msg"></div>
            </form>      
        </div>
    </div>
          
    <!-- Pedidos -->    
    <div id="pedidos" class="tabcontent" style="max-width: 1000px;">
        <div style="position: relative; margin-bottom: 15px;">
            <label for="inputPedidoNumEconomico">N√∫mero Econ√≥mico Cami√≥n:</label>
            <input type="text" id="inputPedidoNumEconomico" oninput="buscarUnidadesPedido()" placeholder="Escriba o seleccione n√∫mero econ√≥mico" autocomplete="off" />
            <div id="autocompleteUnidadesPedido" style="position: absolute; top: 100%; left: 0; right: 0; border: 1px solid #ddd; background: white; max-height: 300px; overflow-y: auto; z-index: 1000; display: none; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
        </div>                
        <div id="datosCamionPedido" style="margin-top:10px; font-weight:bold; min-height: 50px;"></div>
        <!-- Contenedor para mostrar camiones con pedidos pendientes (multi-cliente) -->
        <div id="pendientesCamion" style="margin-top:10px;"></div>
        <!-- Reemplazar la secci√≥n actual de verificaci√≥n r√°pida con esto -->
        <div style="margin-top:10px;">
        <button class="btn btn-info" onclick="toggleVerificacionRapida()">
            <i class="bi bi-calculator"></i> Mostrar Calculadora R√°pida   
        </button>
        
        <div id="verificacionRapidaPanel" style="display:none;">
            <div class="card mb-3 mt-3">
               <div class="card-header">
                   <h5>Verificaci√≥n R√°pida de Capacidad</h5>
              </div>
              <div class="card-body">             
                  <div class="row">
                      <div class="col-md-3">
                          <label>Cantidad</label>
                          <input type="number" id="quickCheckCantidad" class="form-control" value="1" min="1">
                     </div> 
                     <div class="col-md-3">
                         <label>Tipo de Llanta</label>
                         <select class="form-control tipo-llanta">
                             <option value="AUTO">Auto peque√±o/compacto</option>
                             <option value="SUV_CAMIONETA">Camioneta / SUV</option>
                             <option value="COMERCIAL_LIGERO">Comerciales ligeros</option>
                             <option value="PESADO">Camiones pesados</option>
                             <option value="AGRICOLA_MINERO">Agr√≠colas / especiales</option>
                             <option value="CAMARAS">C√°maras y otros</option>
                        </select>
                     </div>
                     <div class="col-md-4 d-flex align-items-end">
                         <button onclick="verificacionRapida()" class="btn btn-primary">
                             Verificar Capacidad
                         </button>
                     </div>
                 </div>
             </div>
         </div>
     </div>
 </div>
          
        <div style="margin-top: 20px;">
            <div class="graph-container">
                <canvas id="graphVolumen" width="150" height="50"></canvas>
                <p style="text-align:center">Espacio usado</p>
           </div>
           <div class="graph-container">
               <canvas id="graphCarga" width="150" height="50"></canvas>
               <p style="text-align:center">Carga Usada</p>
           </div>
       </div>

        <h3>Agregar Llanta al Pedido</h3>

        <!-- Formulario para agregar llanta individual al pedido (necesario para las funciones JS) -->
        <div style="margin-bottom:12px; display:flex; gap:8px; align-items:end; flex-wrap:wrap;">
            <div style="display:flex;flex-direction:column;">
                <label for="pedidoCodigoLlanta">C√≥digo / Clave</label>
                <input type="text" id="pedidoCodigoLlanta" placeholder="C√≥digo o clave" oninput="autoCompletarLlantaPedidoPorCodigo()" />
            </div>
            <div style="display:flex;flex-direction:column;">
                <label for="pedidoDescripcionLlantaInput">Descripci√≥n</label>
                <input type="text" id="pedidoDescripcionLlantaInput" placeholder="Descripci√≥n" oninput="autoCompletarLlantaPedidoPorDescripcion()" />
            </div>
            <div style="display:flex;flex-direction:column;">
                <label>L√≠nea</label>
                <div id="pedidoLineaLlanta"></div>
           </div>
            <div style="display:flex;flex-direction:column; width:90px;">
                <label for="pedidoCantidadLlanta">Cantidad</label>
                <input type="number" id="pedidoCantidadLlanta" value="1" min="1" onchange="calcularTotalesPedido()" />
            </div>
            <div style="display:flex;flex-direction:column;">
                <label>Peso total</label>
                <div id="pedidoPesoLlanta">0</div>
            </div>
            <div style="display:flex;flex-direction:column;">   
                <label>Volumen total</label>
                <div id="pedidoVolumenLlanta">0</div>
            </div>
            <div style="display:flex;flex-direction:column;">
                <label>Valor unitario</label>
                <div id="pedidoValorUnitarioLlanta">0</div>
            </div>
            <div>
                <button class="primary" onclick="agregarPedido()">Agregar al pedido</button>
            </div>
        </div>

        <!-- Campo para agregar bloque por folio -->
        <div style="margin-bottom: 10px;">
             <label for="inputFolioFacturaPedido"><b>Folio de Factura:</b></label>
             <div class="input-group" style="margin: 10px 0;">
                 <input type="text" id="inputFolioFacturaPedido" class="form-control" placeholder="Escribe el folio para buscar" style="margin-left:8px;" oninput="autocompletarBuscaBloques('inputFolioFacturaPedido', 'dropdownAutocompleteBloquesPedido')" />
                 <div class="input-group-append" style="display: flex; gap: 5px; margin-left: 5px;">
                     <button class="primary" onclick="buscarBloquePorFolio()">Buscar bloque</button>
                     <button class="primary" onclick="agregarBloquePorFolioPedido(false)">Agregar bloque</button>
                     <button class="primary" onclick="limpiarPedidosActuales()" style="background:#d9534f;">
                         <i class="bi bi-trash"></i> Limpiar
                     </button>
                 </div>
             </div>
             <div id="bloqueBuscadoPedido"></div>
             <div id="bloquesPendientes" class="mt-2"></div>
              <div style="margin-top: 10px; font-weight: bold;">
            <span id="totalesPedido"></span>
        </div>
        <button class="primary" onclick="aceptarPedido()" style="margin-top: 10px;">Aceptar Pedido</button>
        </div>

        <h3>Pedidos actuales del cami√≥n</h3>
        <table id="tablaPedidosActuales" style="max-width:700px;">
            <thead>
                <tr>
                    <th>C√≥digo</th>
                    <th>Descripci√≥n</th>
                    <th>L√≠nea</th>
                    <th>Cantidad</th>
                    <th>Volumen Total</th>
                    <th>Peso Total</th>
                    <th>Valor Total ($)</th>
                    <th>Quitar</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <!-- Sugerencia de Unidad -->
    <div id="sugerencia-unidad" class="tabcontent" style="max-width: 1000px;">
        <h3>Sugerencia de Unidad</h3>
        
        <!-- Botones de modo -->
        <div class="d-flex justify-content-between align-items-center mb-3">
            <div class="btn-group" role="group" aria-label="Modo de sugerencia">
                <button type="button" class="btn btn-primary active" id="btnModoCalculadora" onclick="cambiarModoSugerencia('calculadora')">
                    Calculadora
                </button>
                <button type="button" class="btn btn-primary" id="btnModoBusqueda" onclick="cambiarModoSugerencia('busqueda')">
                    B√∫squeda de Bloques
                </button>
            </div>
        </div>

        <!-- Modo Calculadora -->
        <div id="modoCalculadora">
            <!-- Secci√≥n de Unidad Sugerida para modo calculadora -->
            <div id="seccionUnidadSugeridaCalculadora" class="card mb-3" style="display: none;">
                <div class="card-header bg-success text-white">
                    <h5 class="mb-0">Unidad Sugerida</h5>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-bordered">
                            <thead class="bg-light">
                                <tr>
                                    <th>Unidad</th>
                                    <th>Econ√≥mico</th>
                                    <th>Cap. Volumen</th>
                                    <th>Cap. Peso</th>
                                    <th style="width: 120px">Uso Volumen</th>
                                    <th style="width: 120px">Uso Peso</th>
                                    <th style="width: 120px">Eficiencia</th>
                                    <th style="width: 150px">Acciones</th>
                                </tr>
                            </thead>
                            <tbody id="tablaUnidadesSugeridasCalculadora">
                                <!-- Las unidades sugeridas se insertar√°n aqu√≠ -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="card mb-3">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Agregar Llantas al C√°lculo</h5>
                <button class="btn btn-outline-danger" onclick="limpiarCalculadora()">
                    <i class="bi bi-trash"></i> Limpiar Todo
                </button>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-3">
                        <label>Cantidad</label>
                        <input type="number" id="sugestionCantidad" class="form-control" value="1" min="1">
                    </div>
                    <div class="col-md-6">
                        <label>Descripci√≥n de Llanta</label>
                        <div class="position-relative">
                            <input type="text" class="form-control" id="busquedaLlanta" placeholder="Escriba para buscar llanta...">
                            <div id="sugerenciasLlantas" class="position-absolute w-100 bg-white shadow-sm border rounded-bottom" style="max-height: 200px; overflow-y: auto; display: none; z-index: 1000;">
                            </div>
                        </div>
                        <input type="hidden" id="descripcionLlanta" value="">
                    </div>
                    <div class="col-md-3 d-flex align-items-end">
                        <button class="btn btn-primary" onclick="agregarTipoLlanta()">
                            <i class="bi bi-plus-circle"></i> Agregar
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="card mb-3">
            <div class="card-header">
                <h5>Llantas Agregadas</h5>
            </div>
            <div class="card-body">
                <table class="table" id="tablaLlantasAgregadas">
                    <thead>
                        <tr>
                            <th>Tipo de Llanta</th>
                            <th>Cantidad</th>
                            <th>Volumen Total</th>
                            <th>Peso Total</th>
                            <th>Acciones</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <div id="totalLlantas" style="font-weight: bold; margin-top: 10px;"></div>
            </div>
        </div>

        <div id="resultadoSugerencia" class="card d-none">
            <div class="card-body">
                <h5 class="card-title">Unidad Sugerida</h5>
                <div id="unidadSugeridaDetalles"></div>
            </div>
        </div>
    </div>

    <!-- Modo B√∫squeda de Bloques -->
    <div id="modoBusqueda" style="display: none;">
        <!-- Barra de b√∫squeda y tabla de llantas -->
        <div class="row g-3 mb-3">
            <!-- Buscador de Bloques -->
            <div style="margin-bottom: 20px;">
                <label for="inputBusquedaBloqueNuevo"><b>Buscar Bloque:</b></label>
                <div class="input-group" style="margin: 10px 0;">
                    <input type="text" 
                           id="inputBusquedaBloqueNuevo" 
                           class="form-control" 
                           placeholder="Escribe el folio para buscar" 
                           style="margin-left:8px;"
                           oninput="autocompletarBuscaBloques('inputBusquedaBloqueNuevo', 'dropdownAutocompleteBloquesNuevo')" />
                    <div class="input-group-append" style="display: flex; gap: 8px; margin-left: 5px; align-items:center;">
                        <button class="primary" onclick="buscarBloqueEnModo()">
                            <i class="bi bi-search"></i> Buscar bloque
                        </button>
                        <button class="primary" onclick="agregarBloqueEnModo(true)">
                            <i class="bi bi-plus-circle"></i> Agregar
                        </button>
                        <button class="primary" onclick="limpiarBusquedaBloqueEnModo()" style="background:#d9534f;">
                            <i class="bi bi-trash"></i> Limpiar
                        </button>
                    </div>
                </div>
                <!-- √Årea para mostrar bloques pendientes -->
                <div id="bloquesPendientesNuevoModo" class="mt-3"></div>
                <div id="resultadoBusquedaBloqueNuevo"></div>
                <div id="bloquesPendientesNuevo" class="mt-2"></div>
            </div>



            <!-- Acorde√≥n de Llantas del Bloque -->
            <div class="accordion mb-4" id="acordeonLlantasBloque">
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button bg-success text-white" 
                                type="button" 
                                data-bs-toggle="collapse" 
                                data-bs-target="#collapseLlantasBloque" 
                                aria-expanded="true" 
                                aria-controls="collapseLlantasBloque">
                            <div class="d-flex align-items-center w-100">
                                <i class="bi bi-stack me-2"></i>
                                <span class="me-auto">Llantas en el Bloque</span>
                                <span class="badge bg-light text-success ms-2" id="contadorLlantasBloque">0</span>
                            </div>
                        </button>
                    </h2>
                    <div id="collapseLlantasBloque" 
                         class="accordion-collapse collapse show" 
                         data-bs-parent="#acordeonLlantasBloque">
                        <div class="accordion-body p-0">
                            <div class="table-responsive">
                                <table class="table table-hover table-bordered mb-0">
                                    <thead class="table-light">
                                        <tr>
                                            <th>C√≥digo</th>
                                            <th>Descripci√≥n</th>
                                            <th>L√≠nea</th>
                                            <th>Cantidad</th>
                                            <th>Volumen Total</th>
                                            <th>Peso Total</th>
                                            <th>Valor Total ($)</th>
                                            <th>Quitar</th>
                                        </tr>
                                    </thead>
                                    <tbody id="tablaLlantasBloque"></tbody>
                                    <tfoot class="table-light fw-bold">
                                        <tr>
                                            <td colspan="3" class="text-end">Totales:</td>
                                            <td id="totalCantidadLlantas" class="text-center">0</td>
                                            <td id="totalVolumenLlantas" class="text-end">0</td>
                                            <td id="totalPesoLlantas" class="text-end">0</td>
                                            <td id="totalValorLlantas" class="text-end">$0</td>
                                            <td></td>
                                        </tr>
                                    </tfoot>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Filtro por ubicaci√≥n -->
            <div class="mb-3 d-flex align-items-center gap-2">
                <label for="filtroUbicacionUnidades" class="mb-0" style="font-weight:600;">Filtrar por ubicaci√≥n:</label>
                <select id="filtroUbicacionUnidades" class="form-select form-select-sm" style="width:220px;">
                    <option value="Todos">Todos</option>
                    <option value="Apan">Apan</option>
                    <option value="Guadalajara">Guadalajara</option>
                    <option value="Pachuca">Pachuca</option>
                    <option value="Queretaro">Quer√©taro</option>
                </select>
            </div>
            <!-- Nueva secci√≥n de Unidades Disponibles -->
            <div class="accordion mb-4" id="acordeonUnidadesDisponibles" style="display:none;">
                <div class="accordion-item">
                    <h2 class="accordion-header">   
                        <button class="accordion-button bg-primary text-white" 
                                type="button" 
                                data-bs-toggle="collapse" 
                                data-bs-target="#collapseUnidadesDisponibles" 
                                aria-expanded="false" 
                                aria-controls="collapseUnidadesDisponibles">
                            <div class="d-flex align-items-center w-100">
                                <i class="bi bi-truck me-2"></i>
                                <span class="me-auto">Unidades Disponibles</span>
                            </div>
                        </button>   
                    </h2>         
                    <div id="collapseUnidadesDisponibles" 
                         class="accordion-collapse collapse" 
                         data-bs-parent="#acordeonUnidadesDisponibles">
                        <div class="accordion-body p-0">
                            <div class="table-responsive">
                                <table class="table table-hover table-bordered mb-0">
                                    <thead class="table-light">
                                        <tr>
                                            <th>Unidad</th>
                                            <th>Econ√≥mico</th>
                                            <th>Ubicaci√≥n</th>
                                            <th>Cap. Volumen</th>
                                            <th>Cap. Peso</th>
                                            <th>Uso Volumen</th>
                                            <th>Uso Peso</th>
                                            <th>Eficiencia</th>
                                            <th>Acciones</th>
                                        </tr>
                                    </thead>
                                    <tbody id="tablaUnidadesDisponibles">
                                        <!-- Las unidades disponibles se insertar√°n aqu√≠ din√°micamente -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Secci√≥n de Distribuci√≥n M√∫ltiple -->
            <script>
                // === SISTEMA DE BLOQUEO DE UNIDADES ASIGNADAS ===
                // Mantiene un registro de qu√© llantas fueron asignadas a qu√© unidades
                // para que cuando cambies de unidad, las llantas asignadas NO se muevan
                let distribucionBloqueada = []; 
                // Formato: [ { economico: "01", llantas: [...], volumen: X, peso: Y }, ... ]
                
                // === VALIDACI√ìN: ASEGURAR QUE LAS LLANTAS NO DESAPARECEN ===
                function validarConteoLlantas(llantasOriginales, unidadesActuales, distribucionBloqueadaParam) {
                    let totalOriginal = 0;
                    let totalEnUnidades = 0;
                    let totalEnBloqueadas = 0;
                    
                    // Contar llantas originales
                    for (const ll of llantasOriginales) {
                        totalOriginal += parseInt(ll.Cantidad || ll.cantidad || ll.CantidadLL || 1);
                    }
                    
                    // Contar llantas en unidades actuales
                    for (const unidad of unidadesActuales) {
                        if (unidad.llantas?.length > 0) {
                            for (const ll of unidad.llantas) {
                                totalEnUnidades += parseInt(ll.cantidad || 1);
                            }
                        }
                    }
                    
                    // Contar llantas en distribucionBloqueada
                    for (const bloqueada of (distribucionBloqueadaParam || [])) {
                        if (bloqueada.llantas?.length > 0) {
                            for (const ll of bloqueada.llantas) {
                                totalEnBloqueadas += parseInt(ll.cantidad || 1);
                            }
                        }
                    }
                    
                    const totalActual = totalEnUnidades + totalEnBloqueadas;
                    const diferencia = totalOriginal - totalActual;
                    
                    const resultado = {
                        totalOriginal: totalOriginal,
                        totalEnUnidades: totalEnUnidades,
                        totalEnBloqueadas: totalEnBloqueadas,
                        totalActual: totalActual,
                        diferencia: diferencia,
                        valido: Math.abs(diferencia) <= 1, // permitir peque√±o margen de error
                        mensaje: diferencia === 0 ? '‚úÖ Conteo correcto' : `‚ö†Ô∏è FALTA ${Math.abs(diferencia)} LLANTAS`
                    };
                    
                    console.log('üìä [VALIDACI√ìN] Conteo de llantas:', resultado);
                    return resultado;
                }
                
                // Funciones espec√≠ficas para la distribuci√≥n m√∫ltiple
                async function calcularDistribucionMultiple(llantas) {
                    console.log('Calculando distribuci√≥n para:', llantas);
                    const distribucion = [];

                    // Normalizar llantas: asegurar cantidad, volumen y peso reales
                    const llantasNorm = [];  
                    for (const ll of llantas) {
                        const cantidad = parseInt(ll.cantidad || ll.Cantidad || ll.CantidadLL || ll.CANTIDAD || 1) || 1;

                        // Intentar leer volumen desde distintos campos
                        let volumen = parseNumber(ll.volumen || ll.Volumen || ll.VOLUMEN || ll['Volumen (m3)'] || ll['volumen_m3']);
                        if (!volumen || isNaN(volumen) || volumen <= 0) {
                            try {
                                const desc = ll.descripcion || ll.Descripcion || ll.Descripci√≥n || ll.descripcionLlanta || '';
                                const vcalc = await calcularVolumenLlanta(desc);
                                volumen = (vcalc && !isNaN(vcalc) && vcalc > 0) ? Number(vcalc) : volumen;
                            } catch (e) {
                                console.warn('No se pudo calcular volumen para', ll, e);
                            }
                        }   
                        // Si a√∫n no hay volumen, usar valor conservador realista (por ejemplo 0.021 m¬≥)
                        if (!volumen || isNaN(volumen) || volumen <= 0) volumen = 0.021;

                        // Intentar leer peso desde distintos campos
                        let peso = parseNumber(ll.peso || ll.Peso || ll.PESO || ll['Peso (kg)'] || ll['peso_kg']);
                        if (!peso || isNaN(peso) || peso <= 0) {
                            try {
                                const desc = ll.descripcion || ll.Descripcion || ll.Descripci√≥n || ll.descripcionLlanta || '';
                                const pcalc = await calcularPesoLlanta(desc);
                                peso = (pcalc && !isNaN(pcalc) && pcalc > 0) ? Number(pcalc) : peso;
                            } catch (e) {
                                console.warn('No se pudo calcular peso para', ll, e);
                            }
                        }
                        // Si a√∫n no hay peso v√°lido, usar fallback razonable (por ejemplo 12 kg)
                        if (!peso || isNaN(peso) || peso <= 0) peso = 12;

                        llantasNorm.push({
                            ...ll,
                            cantidad: cantidad,
                            volumen: Number(volumen),
                            peso: Number(peso)
                        });
                    }
 
                    // Calcular totales usando llantas normalizadas
                    let volumenTotal = llantasNorm.reduce((sum, llanta) => sum + ((parseNumber(llanta.volumen) || 0) * (parseInt(llanta.cantidad) || 1)), 0);
                    let pesoTotal = llantasNorm.reduce((sum, llanta) => sum + ((parseNumber(llanta.peso) || 0) * (parseInt(llanta.cantidad) || 1)), 0);
                    let llantasTotal = llantasNorm.reduce((sum, llanta) => sum + (parseInt(llanta.cantidad) || 1), 0);

                    console.log('Totales calculados (normalizados):', { volumenTotal, pesoTotal, llantasTotal });

                    // Obtener unidades disponibles
                    const unidadesDisponibles = await obtenerUnidadesDisponibles();
                    console.log('Unidades disponibles:', unidadesDisponibles);
                    
                    // Distribuir la carga
                    let volumenRestante = volumenTotal;
                    let pesoRestante = pesoTotal;
                    let llantasRestantes = llantasTotal;

                    // Crear un arreglo mutable con las cantidades pendientes por tipo de llanta (usar normalizadas)
                    let llantasPendientes = llantasNorm.map(l => ({
                        ...l,
                        cantidadPendiente: parseInt(l.cantidad || l.Cantidad || 1)
                    }));
                    
                    // === RESTAR LAS LLANTAS YA BLOQUEADAS ===
                    if (distribucionBloqueada && distribucionBloqueada.length > 0) {
                        console.log('[BLOQUEO] Restando llantas bloqueadas antes de redistribuir:', distribucionBloqueada);
                        
                        for (const bloqueada of distribucionBloqueada) {
                            if (bloqueada.llantas && Array.isArray(bloqueada.llantas)) {
                                for (const llantaBloqueada of bloqueada.llantas) {
                                    const desc = llantaBloqueada.descripcion || '';
                                    const cant = llantaBloqueada.cantidad || 0;
                                    
                                    // Buscar y reducir en llantasPendientes
                                    for (let i = 0; i < llantasPendientes.length; i++) {
                                        const disponible = llantasPendientes[i];
                                        const descDisponible = disponible.Descripci√≥n || disponible.descripcion || '';
                                        
                                        if (descDisponible === desc || descDisponible.includes(desc) || desc.includes(descDisponible)) {
                                            disponible.cantidadPendiente = Math.max(0, disponible.cantidadPendiente - cant);
                                            console.log(`  - Restado ${cant}x ${desc} de pendientes. Quedan: ${disponible.cantidadPendiente}`);
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            // Restar tambi√©n del volumen y peso restantes
                            volumenRestante -= (bloqueada.volumen || 0);
                            pesoRestante -= (bloqueada.peso || 0);
                        }
                        
                        console.log('[BLOQUEO] Despu√©s de restar bloqueadas:', {
                            volumenRestante: volumenRestante.toFixed(2),
                            pesoRestante: pesoRestante.toFixed(2),
                            llantasPendientes: llantasPendientes.map(l => ({ desc: l.Descripci√≥n || l.descripcion, cant: l.cantidadPendiente }))
                        });
                    }  

                    while(volumenRestante > 0 && pesoRestante > 0) {
                        // Encontrar la mejor unidad que pueda llevar al menos el 30% de la carga restante
                        const unidadesValidas = unidadesDisponibles.filter(unidad => 
                            !distribucion.find(d => d.economico === unidad.economico) &&
                            unidad.capacidadVolumen > 0 &&
                            unidad.capacidadPeso > 0     
                        );  

                        if (unidadesValidas.length === 0) break;

                        // Ordenar por eficiencia (menor diferencia entre capacidad y necesidad)  
                        const mejorUnidad = unidadesValidas.sort((a, b) => {
                            const eficienciaA = Math.min(volumenRestante / a.capacidadVolumen, pesoRestante / a.capacidadPeso);
                            const eficienciaB = Math.min(volumenRestante / b.capacidadVolumen, pesoRestante / b.capacidadPeso);
                            return Math.abs(1 - eficienciaA) - Math.abs(1 - eficienciaB);
                        })[0];

                        // Calcular cu√°nto puede llevar esta unidad
                        const volumenAsignable = Math.min(volumenRestante, mejorUnidad.capacidadVolumen);
                        const pesoAsignable = Math.min(pesoRestante, mejorUnidad.capacidadPeso);
                        const proporcionCarga = Math.min(
                            volumenAsignable / volumenRestante,
                            pesoAsignable / pesoRestante
                        ); 
                              
                        const llantasAsignadas = Math.ceil(llantasRestantes * proporcionCarga);
                        const volumenAsignado = volumenRestante * proporcionCarga;
                        const pesoAsignado = pesoRestante * proporcionCarga;

                        const eficienciaVolumen = (volumenAsignado / mejorUnidad.capacidadVolumen) * 100;
                        const eficienciaPeso = (pesoAsignado / mejorUnidad.capacidadPeso) * 100;
                        const eficiencia = (eficienciaVolumen + eficienciaPeso) / 2;

                        // Distribuir las llantas secuencialmente usando llantasPendientes
                        let llantasDistribuidas = 0;
                        let descripcionesAsignadas = [];
                        let llantasAsignadasArray = [];

                        // Recorrer la lista mutable de llantas pendientes en orden
                        for (const llanta of llantasPendientes) {
                            // Si ya no quedan unidades de este tipo, continuar
                            const cantidadLlanta = parseInt(llanta.cantidadPendiente || 0);
                            if (cantidadLlanta <= 0) continue;

                            const cantidadPendiente = Math.min(
                                cantidadLlanta,
                                llantasAsignadas - llantasDistribuidas
                            );

                            if (cantidadPendiente <= 0) break;

                            descripcionesAsignadas.push(
                                `${cantidadPendiente}x ${llanta.descripcion || llanta.Descripci√≥n || llanta.descripcionLlanta || ''}`
                            );

                            llantasAsignadasArray.push({
                                cantidad: cantidadPendiente,
                                descripcion: llanta.descripcion || llanta.Descripci√≥n || llanta.descripcionLlanta || '',
                                linea: llanta.linea || llanta.Linea || ''
                            });

                            // Restar lo asignado de las pendientes para que no se reasigne a otra unidad
                            llanta.cantidadPendiente = Math.max(0, cantidadLlanta - cantidadPendiente);

                            llantasDistribuidas += cantidadPendiente;
                            if (llantasDistribuidas >= llantasAsignadas) break;
                        }

                        const descripcionesLlantas = descripcionesAsignadas.join('\n');

                        distribucion.push({
                            unidad: mejorUnidad.unidad,
                            economico: mejorUnidad.economico,
                            llantasEstimadas: llantasAsignadas,
                            volumen: volumenAsignado,
                            peso: pesoAsignado,
                            eficiencia: eficiencia,
                            descripciones: descripcionesLlantas,
                            llantas: llantasAsignadasArray
                        });

                        volumenRestante -= volumenAsignado;
                        pesoRestante -= pesoAsignado;
                        llantasRestantes -= llantasAsignadas;

                        console.log('Distribuci√≥n parcial:', {
                            unidad: mejorUnidad.unidad,
                            volumenRestante,
                            pesoRestante,
                            llantasRestantes
                        });
                    }

                    // === PASO CR√çTICO: ASIGNAR CUALQUIER LLANTA RESTANTE A LA √öLTIMA UNIDAD ===
                    // Si hay llantas que no fueron distribuidas por restricciones de volumen/peso,
                    // asignarlas a la unidad m√°s grande disponible para que no se pierdan
                    const llantasNoAsignadas = llantasPendientes.filter(l => (l.cantidadPendiente || 0) > 0);
                    if (llantasNoAsignadas.length > 0) {
                        console.log(`‚ö†Ô∏è [CR√çTICO] ${llantasNoAsignadas.map(l => l.cantidadPendiente + 'x ' + (l.descripcion || l.Descripci√≥n)).join(', ')} sin asignar`);
                        
                        // Obtener la unidad m√°s grande disponible
                        const unidadesDisponibles = await obtenerUnidadesDisponibles();
                        const mayorUnidad = unidadesDisponibles.reduce((max, u) => {
                            const capMax = (parseNumber(max.capacidadVolumen) || 0) + (parseNumber(max.capacidadPeso) || 0);
                            const capU = (parseNumber(u.capacidadVolumen) || 0) + (parseNumber(u.capacidadPeso) || 0);
                            return capU > capMax ? u : max;
                        });
                        
                        // Buscar si ya existe una distribuci√≥n para esta unidad
                        let existente = distribucion.find(d => d.economico === mayorUnidad.economico);
                        if (!existente) {
                            existente = {
                                unidad: mayorUnidad.unidad,
                                economico: mayorUnidad.economico,
                                llantasEstimadas: 0,
                                volumen: 0,
                                peso: 0,
                                eficiencia: 0,
                                descripciones: '',
                                llantas: []
                            };
                            distribucion.push(existente);
                        }
                        
                        // Agregar todas las llantas restantes
                        let llantasAgregadas = 0;
                        let volumenAgregado = 0;
                        let pesoAgregado = 0;
                        const descripcionesExtra = [];
                        
                        for (const llanta of llantasNoAsignadas) {
                            if ((llanta.cantidadPendiente || 0) <= 0) continue;
                            
                            const cant = llanta.cantidadPendiente;
                            const vol = parseNumber(llanta.volumen || llanta.Volumen || 0) || 0;
                            const peso = parseNumber(llanta.peso || llanta.Peso || 0) || 0;
                            
                            // Buscar si ya existe en el array de llantas de la unidad
                            let encontrada = false;
                            if (existente.llantas && Array.isArray(existente.llantas)) {
                                for (const ll of existente.llantas) {
                                    if ((ll.descripcion || ll.Descripci√≥n) === (llanta.descripcion || llanta.Descripci√≥n)) {
                                        ll.cantidad = (ll.cantidad || 0) + cant;
                                        encontrada = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (!encontrada) {
                                if (!existente.llantas) existente.llantas = [];
                                existente.llantas.push({
                                    cantidad: cant,
                                    descripcion: llanta.descripcion || llanta.Descripci√≥n || '',
                                    linea: llanta.linea || llanta.Linea || ''
                                });
                            }
                            
                            llantasAgregadas += cant;
                            volumenAgregado += vol * cant;
                            pesoAgregado += peso * cant;
                            descripcionesExtra.push(`${cant}x ${llanta.descripcion || llanta.Descripci√≥n || ''}`);
                        }
                        
                        // Actualizar totales
                        existente.llantasEstimadas = (existente.llantasEstimadas || 0) + llantasAgregadas;
                        existente.volumen = (existente.volumen || 0) + volumenAgregado;
                        existente.peso = (existente.peso || 0) + pesoAgregado;
                        if (descripcionesExtra.length > 0) {
                            existente.descripciones = (existente.descripciones ? existente.descripciones + '\n' : '') + descripcionesExtra.join('\n');
                        }
                        
                        console.log(`‚úÖ [RESCATADAS] ${llantasAgregadas} llantas agregadas a ${mayorUnidad.economico}:`, {
                            volumen: volumenAgregado.toFixed(2),
                            peso: pesoAgregado.toFixed(2)
                        });
                    }

                    return distribucion;
                }

                // Nueva funci√≥n: Recalcular distribuci√≥n completa cuando cambia una unidad
                async function recalcularDistribucionCompleta(distribucion, unidadesFlota, options = {}) {
                    console.log('üîÑ Recalculando distribuci√≥n completa...', options);
                    
                    // === NUEVA L√ìGICA: RESPETAR UNIDADES BLOQUEADAS ===
                    const respetarBloqueados = options.respetarBloqueados || false;
                    const unidadesBloquedadas = window.unidadesBloquedadas || {};
                    console.log('[BLOQUEO] Unidades bloqueadas actualmente:', Object.keys(unidadesBloquedadas));
                    
                    // Si hay bloqueados y se solicita respetarlos, construir distribucionBloqueada
                    // directamente desde `window.unidadesBloquedadas` para usar el detalle exacto
                    // de llantas y evitar inconsistencias.
                    let distribucionBloqueada = [];
                    let distribucionParaRedistribuir = [];

                    if (respetarBloqueados && Object.keys(unidadesBloquedadas).length > 0) {
                        // Construir bloqueados a partir del objeto global (fuente de la verdad)
                        for (const key of Object.keys(unidadesBloquedadas)) {
                            const u = unidadesBloquedadas[key];
                            const bloqueadoItem = {
                                unidad: u.unidad || '',
                                economico: u.economico || key,
                                llantasEstimadas: u.llantasAsignadas || 0,
                                volumen: u.volumen || 0,
                                peso: u.peso || 0,
                                descripciones: (u.llantas && u.llantas.map(l => `${l.cantidad}x ${l.descripcion || l.Descripci√≥n || ''}`).join('\n')) || '',
                                llantas: u.llantas ? JSON.parse(JSON.stringify(u.llantas)) : []
                            };
                            distribucionBloqueada.push(bloqueadoItem);
                        }

                        // Los items a redistribuir son los que NO est√©n bloqueados
                        distribucionParaRedistribuir = distribucion.filter(d => !unidadesBloquedadas[String(d.economico)]);
                    } else {
                        distribucionParaRedistribuir = [...distribucion];
                    }
                    
                    console.log(`[BLOQUEO] ${distribucionBloqueada.length} unidades bloqueadas, ${distribucionParaRedistribuir.length} a redistribuir`);
                    
                    // Calcular totales de llantas disponibles
                    const llantasOriginales = llantasAcumuladasEnBloque || [];
                    if (llantasOriginales.length === 0) {
                        console.warn('No hay llantas para redistribuir');
                        return distribucion;
                    }

                    // Calcular volumen y peso total disponible
                    let volumenTotal = 0;
                    let pesoTotal = 0;
                    let llantasTotal = 0;

                    llantasOriginales.forEach(llanta => {
                        const cant = parseInt(llanta.Cantidad || llanta.cantidad || 1, 10);
                        const vol = parseNumber(llanta.volumenUnitario || llanta.Volumen || 0) || 0;
                        const peso = parseNumber(llanta.pesoUnitario || llanta.Peso || 0) || 0;
                        
                        volumenTotal += vol * cant;
                        pesoTotal += peso * cant;
                        llantasTotal += cant;
                    });

                    console.log('üìä Totales disponibles (ANTES de restar bloqueadas):', {
                        volumen: volumenTotal.toFixed(3),
                        peso: pesoTotal.toFixed(2),
                        llantas: llantasTotal
                    });

                    // RESPETO A BLOQUEADOS: no restar de los totales directamente
                    // (restar cantidades en el arreglo de llantasDisponibles m√°s abajo)
                    if (distribucionBloqueada.length > 0) {
                        for (const bloqueada of distribucionBloqueada) {
                            const llantasEnBloqueada = bloqueada.llantasEstimadas || 0;
                            const volumenEnBloqueada = bloqueada.volumen || 0;
                            const pesoEnBloqueada = bloqueada.peso || 0;
                            
                            // No restamos de los totales globales aqu√≠ porque eso puede
                            // provocar que llantas restantes "desaparezcan" si las
                            // estimaciones de volumen/peso no coinciden exactamente.
                            // En su lugar, descontaremos las cantidades de
                            // `llantasDisponibles` m√°s adelante (ya existe esa l√≥gica).
                            console.log(`[BLOQUEO] Manteniendo ${llantasEnBloqueada} llantas bloqueadas en ${bloqueada.economico} (no se restan de totales)`);
                        }
                    }

                    console.log('üìä Totales DISPONIBLES para redistribuir:', {
                        volumen: volumenTotal.toFixed(3),
                        peso: pesoTotal.toFixed(2),
                        llantas: llantasTotal
                    });

                    // Crear copia de llantas disponibles para ir restando
                    let llantasDisponibles = llantasOriginales.map(l => ({
                        ...l,
                        cantidadPendiente: parseInt(l.Cantidad || l.cantidad || 1, 10),
                        volumenUnitario: (l.volumenUnitario || l.Volumen || l.Volumen_m3 || l['Volumen (m3)']) || 0,
                        pesoUnitario: (l.pesoUnitario || l.Peso || l['Peso (kg)'] || l.peso) || 0
                    }));

                    // RESTAR de llantasDisponibles las que ya fueron asignadas a unidades bloqueadas
                    if (distribucionBloqueada.length > 0) {
                        for (const bloqueada of distribucionBloqueada) {
                            if (bloqueada.llantas && Array.isArray(bloqueada.llantas)) {
                                for (const llantaBloqueada of bloqueada.llantas) {
                                    const desc = llantaBloqueada.descripcion || '';
                                    const cant = llantaBloqueada.cantidad || 0;
                                    
                                    // Buscar y reducir en llantasDisponibles
                                    for (let i = 0; i < llantasDisponibles.length; i++) {
                                        const disponible = llantasDisponibles[i];
                                        const descDisponible = disponible.Descripci√≥n || disponible.descripcion || '';
                                        
                                        if (descDisponible === desc || descDisponible.includes(desc) || desc.includes(descDisponible)) {
                                            llantasDisponibles[i].cantidadPendiente = Math.max(0, disponible.cantidadPendiente - cant);
                                            console.log(`[BLOQUEO] Restando ${cant} de "${desc}" de llantas disponibles (quedan: ${llantasDisponibles[i].cantidadPendiente})`);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Calcular vol/peso unitario faltante usando funciones auxiliares si existen
                    for (let ll of llantasDisponibles) {
                        try {
                            if ((!ll.volumenUnitario || ll.volumenUnitario === 0) && typeof calcularVolumenLlanta === 'function') {
                                const v = await calcularVolumenLlanta(ll.descripcion || ll.Descripcion || ll.Descripci√≥n || '');
                                ll.volumenUnitario = (v && !isNaN(v)) ? Number(v) : (ll.volumenUnitario || 0);
                            }
                        } catch (e) {
                            console.warn('Error calculando volumen unitario para', ll, e);
                        }
                        try {
                            if ((!ll.pesoUnitario || ll.pesoUnitario === 0) && typeof calcularPesoLlanta === 'function') {
                                const p = await calcularPesoLlanta(ll.descripcion || ll.Descripcion || ll.Descripci√≥n || '');
                                ll.pesoUnitario = (p && !isNaN(p)) ? Number(p) : (ll.pesoUnitario || 0);
                            }
                        } catch (e) {
                            console.warn('Error calculando peso unitario para', ll, e);
                        }
                    }

                    // Recalcular distribuci√≥n con las nuevas capacidades de las unidades en distribucion[]
                    let distribucionNueva = [];
                    let volumenRestante = volumenTotal;
                    let pesoRestante = pesoTotal;
                    let llantasRestantes = llantasTotal;

                    // Si se pas√≥ una unidad prioritaria, intentar llenarla primero (greedy)
                    const prioridad = options.prioritizeEconomico || null;
                    const unidadesAsignadasSet = new Set();
                    if (prioridad) {
                        const unidadPrior = unidadesFlota.find(u => String(u.codigo) === String(prioridad));
                        if (unidadPrior) {
                            console.log('üéØ Prioridad detectada, intentando llenar unidad:', prioridad, unidadPrior);
                            const capVol = parseNumber(unidadPrior.capacidadVolumen) || 0;
                            const capPeso = parseNumber(unidadPrior.capacidadPeso) || 0;

                            let usedVol = 0;
                            let usedPeso = 0;
                            let piezasAsignadasTotal = 0;
                            let descripcionesAsignadas = [];
                            let llantasAsignadasArray = [];

                            // Recorrer las llantas disponibles y asignar tantas como quepan
                            for (const llanta of llantasDisponibles) {
                                if (llanta.cantidadPendiente <= 0) continue;

                                const volUnit = parseNumber(llanta.volumenUnitario || llanta.Volumen || 0) || 0;
                                const pesoUnit = parseNumber(llanta.pesoUnitario || llanta.Peso || 0) || 0;
                                const cantidadDisponible = llanta.cantidadPendiente || 0;

                                // Calcular cu√°ntas de esta descripci√≥n caben seg√∫n volumen/peso restante
                                let maxByVol = volUnit > 0 ? Math.floor((capVol - usedVol) / volUnit) : cantidadDisponible;
                                let maxByPeso = pesoUnit > 0 ? Math.floor((capPeso - usedPeso) / pesoUnit) : cantidadDisponible;
                                if (maxByVol < 0) maxByVol = 0;
                                if (maxByPeso < 0) maxByPeso = 0;

                                let tomar = Math.min(cantidadDisponible, Math.max(0, Math.min(maxByVol || cantidadDisponible, maxByPeso || cantidadDisponible)));

                                // Si tanto volUnit como pesoUnit son cero, asignar lo posible
                                if ((volUnit === 0 && pesoUnit === 0) && tomar === 0) {
                                    tomar = Math.min(cantidadDisponible, llantasRestantes);
                                }

                                if (tomar <= 0) continue;

                                descripcionesAsignadas.push(`${tomar}x ${llanta.Descripci√≥n || llanta.descripcion || ''}`);
                                llantasAsignadasArray.push({ cantidad: tomar, descripcion: llanta.Descripci√≥n || llanta.descripcion || '', volUnitario: volUnit, pesoUnitario: pesoUnit });

                                usedVol += volUnit * tomar;
                                usedPeso += pesoUnit * tomar;
                                piezasAsignadasTotal += tomar;

                                // Reducir pendiente
                                llanta.cantidadPendiente = Math.max(0, llanta.cantidadPendiente - tomar);
                                llantasRestantes = Math.max(0, llantasRestantes - tomar);
                                volumenRestante = Math.max(0, volumenRestante - (volUnit * tomar));
                                pesoRestante = Math.max(0, pesoRestante - (pesoUnit * tomar));

                                if (llantasRestantes <= 0) break;
                                if (usedVol >= capVol && usedPeso >= capPeso) break;
                            }

                            if (piezasAsignadasTotal > 0) {
                                const eficienciaVol = capVol > 0 ? (usedVol / capVol) * 100 : 0;
                                const eficienciaPeso = capPeso > 0 ? (usedPeso / capPeso) * 100 : 0;
                                const eficiencia = (eficienciaVol + eficienciaPeso) / 2;

                                distribucionNueva.push({
                                    unidad: unidadPrior.nombre || unidadPrior.unidad || '',
                                    economico: unidadPrior.codigo || unidadPrior.economico || '',
                                    llantasEstimadas: piezasAsignadasTotal,
                                    volumen: usedVol,
                                    peso: usedPeso,
                                    eficiencia: eficiencia,
                                    descripciones: descripcionesAsignadas.join('\n'),
                                    llantas: llantasAsignadasArray
                                });

                                unidadesAsignadasSet.add(String(unidadPrior.codigo || unidadPrior.economico || ''));
                                console.log('‚úÖ Prioridad asignada:', unidadPrior.codigo, 'piezas:', piezasAsignadasTotal, 'vol:', usedVol.toFixed(3), 'peso:', usedPeso.toFixed(2));
                            } else {
                                console.log('‚ö†Ô∏è No se pudieron asignar piezas a la unidad prioritaria (capacidad 0 o vol/peso cero)');
                            }
                        } else {
                            console.warn('Unidad prioritaria no encontrada en flota:', prioridad);
                        }
                    }

                    // Calcular capacidades totales de las unidades listadas en 'distribucion'
                    let unidadesProcesar = distribucion.map(item => unidadesFlota.find(u => String(u.codigo) === String(item.economico))).filter(Boolean);
                    let totalCapVol = unidadesProcesar.reduce((s, u) => s + (parseNumber(u.capacidadVolumen) || 0), 0);
                    let totalCapPeso = unidadesProcesar.reduce((s, u) => s + (parseNumber(u.capacidadPeso) || 0), 0);

                    // Crear lista de unidades a procesar: si hay prioridad, ponerla al inicio,
                    // luego ordenar el resto por capacidad de volumen descendente (para aprovechar unidades grandes)
                    const unidadesMap = (distribucion || []).map(item => ({ item }));
                    let ordenProcesamiento = [];

                    if (prioridad) {
                        // Buscar el item correspondiente en distribucion (si no fue ya asignada por la fase greedy)
                        const idxPrior = distribucion.findIndex(d => String(d.economico) === String(prioridad));
                        if (idxPrior >= 0) {
                            const codigoPrior = String(distribucion[idxPrior].economico || '');
                            if (!unidadesAsignadasSet.has(codigoPrior)) {
                                ordenProcesamiento.push(distribucion[idxPrior]);
                            }
                        }
                    }

                    // A√±adir el resto (sin duplicar la prioritaria), ordenados por capacidadVol desc
                    const restantes = distribucion.filter(d => !ordenProcesamiento.find(op => String(op.economico) === String(d.economico)) && !unidadesAsignadasSet.has(String(d.economico)));
                    const restantesConCap = restantes.map(d => ({
                        d,
                        unidadObj: unidadesFlota.find(u => String(u.codigo) === String(d.economico))
                    }));

                    restantesConCap.sort((a, b) => {
                        const capA = parseNumber((a.unidadObj && a.unidadObj.capacidadVolumen) || 0);
                        const capB = parseNumber((b.unidadObj && b.unidadObj.capacidadVolumen) || 0);
                        return capB - capA;
                    });

                    for (const r of restantesConCap) ordenProcesamiento.push(r.d);

                    // Procesar en el orden decidido
                    for (const item of ordenProcesamiento) {
                        if (llantasRestantes <= 0) break;

                        const unidadActual = unidadesFlota.find(u => String(u.codigo) === String(item.economico));
                        if (!unidadActual) continue;

                        const capVol = parseNumber(unidadActual.capacidadVolumen) || 0;
                        const capPeso = parseNumber(unidadActual.capacidadPeso) || 0;

                        // Evitar divisi√≥n por cero
                        const divisorVol = totalCapVol > 0 ? totalCapVol : capVol || 1;
                        const divisorPeso = totalCapPeso > 0 ? totalCapPeso : capPeso || 1;

                        // Estimar cu√°ntas llantas asignar en proporci√≥n a la capacidad de la unidad frente al total
                        let llantasCapacidadVol = Math.max(0, Math.round((capVol / divisorVol) * llantasRestantes));
                        let llantasCapacidadPeso = Math.max(0, Math.round((capPeso / divisorPeso) * llantasRestantes));
                        let llantasAsignadas = Math.min(llantasRestantes, Math.max(llantasCapacidadVol, llantasCapacidadPeso));

                        // Garantizar al menos 1 si la unidad tiene capacidad y a√∫n quedan llantas
                        if (llantasAsignadas <= 0 && (capVol > 0 || capPeso > 0) && llantasRestantes > 0) {
                            llantasAsignadas = Math.min(1, llantasRestantes);
                        }

                        if (llantasAsignadas <= 0) {
                            // Restar la capacidad de esta unidad del total para pr√≥ximas iteraciones
                            totalCapVol -= capVol; totalCapPeso -= capPeso;
                            continue;
                        }

                        // Calcular eficiencia estimada usando capacidad frente a asignaci√≥n
                        const volumenAsignadoEstimado = (volumenTotal > 0) ? (volumenTotal * (llantasAsignadas / llantasTotal)) : 0;
                        const pesoAsignadoEstimado = (pesoTotal > 0) ? (pesoTotal * (llantasAsignadas / llantasTotal)) : 0;
                        const eficienciaVol = capVol > 0 ? (volumenAsignadoEstimado / capVol) * 100 : 0;
                        const eficienciaPeso = capPeso > 0 ? (pesoAsignadoEstimado / capPeso) * 100 : 0;
                        const eficiencia = (eficienciaVol + eficienciaPeso) / 2;

                        // Distribuir llantas a esta unidad conforme a llantasAsignadas
                        let descripcionesAsignadas = [];
                        let llantasAsignadasArray = [];
                        let llantasDistribuidas = 0;
                        let volumenReal = 0;
                        let pesoReal = 0;

                        for (const llanta of llantasDisponibles) {
                            const cantidadPendiente = llanta.cantidadPendiente || 0;
                            if (cantidadPendiente <= 0 || llantasDistribuidas >= llantasAsignadas) continue;

                            const cantidadTomar = Math.min(cantidadPendiente, llantasAsignadas - llantasDistribuidas);
                            if (cantidadTomar <= 0) continue;

                            const volUnitario = parseNumber(llanta.volumenUnitario || llanta.Volumen || 0) || 0;
                            const pesoUnitario = parseNumber(llanta.pesoUnitario || llanta.Peso || 0) || 0;

                            descripcionesAsignadas.push(`${cantidadTomar}x ${llanta.Descripci√≥n || llanta.descripcion || ''}`);
                            llantasAsignadasArray.push({ cantidad: cantidadTomar, descripcion: llanta.Descripci√≥n || llanta.descripcion || '', volUnitario, pesoUnitario });

                            volumenReal += volUnitario * cantidadTomar;
                            pesoReal += pesoUnitario * cantidadTomar;

                            llanta.cantidadPendiente = Math.max(0, cantidadPendiente - cantidadTomar);
                            llantasDistribuidas += cantidadTomar;
                        }

                        if (llantasDistribuidas > 0) {
                            distribucionNueva.push({
                                unidad: item.unidad,
                                economico: item.economico,
                                llantasEstimadas: llantasDistribuidas,
                                volumen: volumenReal,
                                peso: pesoReal,
                                eficiencia: eficiencia,
                                descripciones: descripcionesAsignadas.join('\n'),
                                llantas: llantasAsignadasArray
                            });

                            volumenRestante -= volumenReal;
                            pesoRestante -= pesoReal;
                            llantasRestantes -= llantasDistribuidas;

                            // Restar capacidades usadas del total para pr√≥ximas iteraciones
                            totalCapVol -= capVol; totalCapPeso -= capPeso;
                            console.log('‚úÖ Distribuida a', item.economico, ':', llantasDistribuidas, 'llantas');
                        } else {
                            totalCapVol -= capVol; totalCapPeso -= capPeso;
                        }
                    }

                    console.log('üîÑ Distribuci√≥n recalculada:', distribucionNueva);
                    
                    // === RETORNAR: PRIMERO BLOQUEADOS (FIJOS), LUEGO REDISTRIBUIDOS (SIN DUPLICADOS) ===
                    // Evitar duplicados: si una unidad ya est√° en bloqueados, no agregarla de nuevo desde distribucionNueva
                    const economicosBloqueados = new Set(distribucionBloqueada.map(d => String(d.economico)));
                    const distribucionNuevaSinDuplicados = distribucionNueva.filter(d => !economicosBloqueados.has(String(d.economico)));
                    
                    const distribucionFinal = [...distribucionBloqueada, ...distribucionNuevaSinDuplicados];
                    console.log(`[BLOQUEO] Distribuci√≥n final: ${distribucionBloqueada.length} bloqueadas + ${distribucionNuevaSinDuplicados.length} redistribuidas (sin duplicados) = ${distribucionFinal.length} total`);
                    return distribucionFinal;
                }

                // Actualiza los totales (volumen/peso) mostrados en la UI
                function actualizarTotalesDistribucion(distribucion) {
                    try {
                        // Si la tabla de llantas del bloque est√° visible y tiene filas,
                        // preferimos calcular los totales directamente desde las filas
                        // para asegurar que el pie refleje exactamente lo mostrado.
                        const tablaLlantas = document.getElementById('tablaLlantasBloque');
                        if (tablaLlantas && tablaLlantas.rows && tablaLlantas.rows.length > 0) {
                            let totalVol = 0;
                            let totalPeso = 0;
                            Array.from(tablaLlantas.rows).forEach(row => {
                                try {
                                    const volCell = row.cells[4] && row.cells[4].textContent ? row.cells[4].textContent : '0';
                                    const pesCell = row.cells[5] && row.cells[5].textContent ? row.cells[5].textContent : '0';
                                    totalVol += parseNumber(volCell);
                                    totalPeso += parseNumber(pesCell);
                                } catch (e) { /* ignorar filas malformadas */ }
                            });
                            const elVol = document.getElementById('totalVolumenLlantas');
                            const elPeso = document.getElementById('totalPesoLlantas');
                            if (elVol) { elVol.dataset.value = totalVol; elVol.textContent = formatNumber(totalVol, 3); }
                            if (elPeso) { elPeso.dataset.value = totalPeso; elPeso.textContent = formatNumber(totalPeso, 3); }
                            console.log('Totales actualizados desde tabla:', { totalVol, totalPeso });
                            return;
                        }

                        // Si no hay filas en la tabla, caer en la suma por distribuci√≥n
                        const totalVol = (distribucion || []).reduce((s, d) => s + (parseNumber(d.volumen) || 0), 0);
                        const totalPeso = (distribucion || []).reduce((s, d) => s + (parseNumber(d.peso) || 0), 0);
                        const elVol = document.getElementById('totalVolumenLlantas');
                        const elPeso = document.getElementById('totalPesoLlantas');
                        if (elVol) { elVol.dataset.value = totalVol; elVol.textContent = formatNumber(totalVol, 3); }
                        if (elPeso) { elPeso.dataset.value = totalPeso; elPeso.textContent = formatNumber(totalPeso, 3); }
                        console.log('Totales actualizados desde distribuci√≥n:', { totalVol, totalPeso });
                    } catch (e) {
                        console.warn('Error actualizando totales de distribuci√≥n', e);
                    }
                }
                
                function actualizarTablaDistribucion(distribucion) {
                    const tbody = document.getElementById('tablaDistribucionSugerida');
                    const unidadesFlota = typeof obtenerUnidadesFlota === 'function' ? obtenerUnidadesFlota() : [];

                    // Filtrar solo las filas que tienen llantas asignadas (no vac√≠as)
                    const distribucionValida = distribucion.filter(item => (item.llantasEstimadas || 0) > 0);

                    tbody.innerHTML = distribucionValida.map((item, idx) => {
                        // Obtener las descripciones de las llantas
                        const detallesLlantas = item.descripciones ? 
                            item.descripciones.split('\n').join('<br>') : 
                            'Sin descripciones';
                        
                        // Agregar estilos para mejor presentaci√≥n
                        const estiloDescripciones = `
                            font-size: 0.9em;
                            color: #666;
                            line-height: 1.4;
                        `;
                        
                        // Construir lista de unidades candidatas que soporten este volumen/peso
                        const candidatos = unidadesFlota.filter(u => {
                            const capVol = parseNumber(u.capacidadVolumen) || 0;
                            const capPeso = parseNumber(u.capacidadPeso) || 0;
                            return capVol >= (parseNumber(item.volumen) || 0) && capPeso >= (parseNumber(item.peso) || 0);
                        });

                        // Asegurar que la unidad actualmente asignada est√© en la lista
                        let presente = candidatos.find(u => String(u.codigo) === String(item.economico));
                        if (!presente) {
                            const encontrada = unidadesFlota.find(u => String(u.codigo) === String(item.economico));
                            if (encontrada) candidatos.unshift(encontrada);
                            else if (item.economico || item.unidad) {
                                candidatos.unshift({ 
                                    codigo: item.economico || '', 
                                    nombre: item.unidad || 'Sin unidad', 
                                    capacidadVolumen: 0, 
                                    capacidadPeso: 0 
                                });
                            }
                        }

                        const opcionesHtml = candidatos.map(u => {
                            const selected = String(u.codigo) === String(item.economico) ? 'selected' : '';
                            const label = `${u.nombre || u.unidad || ''} (${u.codigo || u.economico || ''})`;
                            return `<option value="${u.codigo || ''}" ${selected}>${label}</option>`;
                        }).join('');

                        return `
                            <tr>
                                <td>
                                    <select class="form-select form-select-sm select-unidad" data-idx="${idx}">
                                        ${opcionesHtml}
                                    </select>
                                </td>
                                <td>${item.economico || 'N/A'}</td>
                                <td class="text-center"><strong>${item.llantasEstimadas || 0}</strong></td>
                                <td style="${estiloDescripciones}">${detallesLlantas}</td>
                                <td class="text-end">${(item.volumen || 0).toFixed(2)} m¬≥</td>
                                <td class="text-end">${(item.peso || 0).toFixed(2)} kg</td>
                                <td class="text-center">${(item.eficiencia || 0).toFixed(1)}%</td>
                            </tr>
                        `;
                    }).join('');
                    
                    // Actualizar los datos en el bot√≥n de apartar (usar solo distribucionValida)
                    const botonApartar = document.querySelector('#botonesDistribucionMultiple button');
                    if (botonApartar) {
                        botonApartar.dataset.unidades = JSON.stringify(distribucionValida);
                    }

                    // Actualizar totales generales tras renderizar la tabla
                    try { actualizarTotalesDistribucion(distribucion); } catch(e) { console.warn(e); }

                    // Inicializar unidadesBloquedadas como objeto global si no existe
                    if (typeof window.unidadesBloquedadas === 'undefined') {
                        window.unidadesBloquedadas = {};
                        console.log('[BLOQUEO] Inicializado objeto de unidades bloqueadas');
                    }

                    // Agregar manejadores para los selects con sistema de bloqueo
                    setTimeout(() => {
                        const selects = tbody.querySelectorAll('.select-unidad');
                        selects.forEach(select => {
                            select.removeEventListener('change', select._changeHandler || (() => {}));
                            const handler = async function (e) {
                                const nuevoEconomico = this.value;
                                const unidadesFlota = typeof obtenerUnidadesFlota === 'function' ? obtenerUnidadesFlota() : [];
                                
                                // Encontrar qu√© item corresponde a este select (comparar econ√≥mico actual)
                                const filaTR = this.closest('tr');
                                const cellEconomico = filaTR.cells[1].textContent;
                                const itemActual = distribucionValida.find(item => String(item.economico) === String(cellEconomico));
                                
                                if (itemActual) {
                                    const unidadNueva = unidadesFlota.find(u => String(u.codigo) === String(nuevoEconomico));
                                    const economicoPrevio = String(itemActual.economico);
                                    
                                    itemActual.economico = nuevoEconomico;
                                    itemActual.unidad = unidadNueva ? unidadNueva.nombre : itemActual.unidad;
                                    
                                    // === NO BLOQUEAR LA NUEVA UNIDAD INMEDIATAMENTE ===
                                    // En su lugar, simplemente actualizar el econ√≥mico en el item.
                                    // La nueva unidad se recalcular√° libremente sin ser "fija".
                                    // Esto evita que ambas (vieja y nueva) aparezcan como bloqueadas.
                                    
                                    // Si hab√≠a una unidad anterior diferente, desbloquearla
                                    if (typeof window.unidadesBloquedadas === 'undefined') window.unidadesBloquedadas = {};
                                    
                                    if (economicoPrevio && economicoPrevio !== String(nuevoEconomico)) {
                                        try {
                                            console.log(`[üîì DESBLOQUEANDO] ${economicoPrevio} (cambio a ${nuevoEconomico})`);
                                            delete window.unidadesBloquedadas[economicoPrevio];
                                        } catch (e) { console.warn('Error desbloqueando:', e); }
                                    }
                                    
                                    console.log(`[üîÑ CAMBIO REGISTRADO] ${economicoPrevio} ‚Üí ${nuevoEconomico}`);
                                }

                                // Recalcular distribuci√≥n completa (respeta bloqueados SI LOS HAY)
                                console.log('üì¶ Cambio de unidad detectado. Recalculando (respetando bloqueados)...');
                                const distribucionRecalculada = await recalcularDistribucionCompleta(distribucion, unidadesFlota, { 
                                    prioritizeEconomico: nuevoEconomico,
                                    respetarBloqueados: true
                                });
                                
                                // Actualizar array global
                                distribucion.length = 0;
                                distribucion.push(...distribucionRecalculada);

                                // Redibujar tabla
                                actualizarTablaDistribucion(distribucion);

                                // Mantener la secci√≥n de Distribuci√≥n Sugerida abierta despu√©s del cambio
                                try {
                                    const acordeon = document.getElementById('collapseDistribucionMultiple');
                                    if (acordeon && !acordeon.classList.contains('show')) acordeon.classList.add('show');
                                } catch (e) { /* ignorar */ }

                                // Actualizar totales visibles
                                try { actualizarTotalesDistribucion(distribucion); } catch(e){ console.warn(e); }

                                console.log('‚úÖ Tabla actualizada (bloqueados respetados)');
                            };
                            select._changeHandler = handler;
                            select.addEventListener('change', handler);
                        });
                    }, 50);

                        // Decidir si se muestra la secci√≥n de Distribuci√≥n Sugerida.
                        // Regla: mostrar s√≥lo si se requieren m√∫ltiples unidades o
                        // si ning√∫n veh√≠culo disponible puede manejar el volumen/peso total.
                        try {
                            const totalVolumen = distribucion.reduce((s, it) => s + (parseNumber(it.volumen) || 0), 0);
                            const totalPeso = distribucion.reduce((s, it) => s + (parseNumber(it.peso) || 0), 0);

                            // Obtener la flota desde la tabla (funci√≥n existente)
                            const unidadesFlota = typeof obtenerUnidadesFlota === 'function' ? obtenerUnidadesFlota() : [];

                            // Comprobar si existe alguna unidad capaz de llevar la carga en una sola pieza
                            const unidadApta = unidadesFlota.find(u => {
                                const capVol = parseNumber(u.capacidadVolumen) || parseNumber(u.capacidad || u.capacidadVolumen) || 0;
                                const capPeso = parseNumber(u.capacidadPeso) || parseNumber(u.capacidad_peso || u.capacidadPeso) || 0;
                                return capVol >= totalVolumen && capPeso >= totalPeso;
                            });

                            // Mostrar s√≥lo si NO existe una unidad capaz de llevar toda la carga.
                            // Evita abrir el acorde√≥n cuando la distribuci√≥n se divide por otra raz√≥n.
                            const mostrar = (!unidadApta) && ((totalVolumen || 0) > 0 || (totalPeso || 0) > 0);
                            const acordeon = document.getElementById('collapseDistribucionMultiple');
                            if (acordeon) {
                                if (mostrar) acordeon.classList.add('show');
                                else acordeon.classList.remove('show');
                            }
                        } catch (e) {
                            console.warn('No se pudo decidir mostrar la distribuci√≥n sugerida:', e);
                        }
                }

                async function apartarDistribucionCompleta() {
                    try {
                        // Obtener la distribuci√≥n actual
                        const distribucionActual = await obtenerDistribucionActual();
                        if (!distribucionActual || distribucionActual.length === 0) {
                            Swal.fire('Error', 'No hay distribuci√≥n para apartar', 'error');
                            return;
                        }

                        // Solicitar nombre del cliente
                        const { value: nombreCliente } = await Swal.fire({
                            title: 'Nombre del cliente',
                            input: 'text',
                            inputLabel: 'Ingrese el nombre del cliente',
                            inputValidator: (value) => {
                                if (!value) return 'Debe ingresar un nombre';
                            }
                        });

                        if (!nombreCliente) return;

                        // Confirmar la operaci√≥n
                        const { isConfirmed } = await Swal.fire({
                            title: '¬øConfirmar distribuci√≥n?',
                            html: `Se apartar√°n ${distribucionActual.length} unidades para este pedido`,
                            icon: 'question',
                            showCancelButton: true
                        });

                        if (!isConfirmed) return;

                        // Registrar cada unidad
                        for (const unidad of distribucionActual) {
                            await registrarApartado({
                                fecha: new Date().toISOString(),
                                responsable: nombreResponsable,
                                unidad: unidad.unidad,
                                economico: unidad.economico,
                                llantasEstimadas: unidad.llantasEstimadas,
                                volumen: unidad.volumen,
                                peso: unidad.peso
                            });
                        }

                        Swal.fire('√âxito', 'Distribuci√≥n apartada correctamente', 'success');
                        document.getElementById('tablaDistribucionSugerida').innerHTML = '';
                        
                    } catch (error) {
                        console.error('Error al apartar distribuci√≥n:', error);
                        Swal.fire('Error', 'No se pudo completar la operaci√≥n', 'error');
                    }
                }

                async function obtenerUnidadesDisponibles() {
                    console.log('Obteniendo unidades disponibles desde la tabla de flota...');
                    try {
                        // Obtener los datos de la tabla de flota (DOM) en lugar de SheetDB
                        // para asegurar que se usan los datos reales de capacidades
                        const unidadesFlota = typeof obtenerUnidadesFlota === 'function' ? obtenerUnidadesFlota() : [];
                        
                        console.log('Unidades de flota obtenidas:', unidadesFlota);

                        // Mapear y filtrar las unidades disponibles
                        const unidades = unidadesFlota
                            .map(unidad => {
                                return {
                                    unidad: unidad.nombre || 'Sin unidad',
                                    economico: unidad.codigo || 'Sin econ√≥mico',
                                    codigo: unidad.codigo,  // Agregar ambos para compatibilidad
                                    nombre: unidad.nombre,
                                    ubicacion: unidad.ubicacion || '',
                                     capacidadVolumen: parseNumber(unidad.capacidadVolumen) || 0,
                                    capacidadPeso: parseNumber(unidad.capacidadPeso) || 0
                                };
                            })
                            .filter(unidad => 
                                // Filtrar unidades con capacidades v√°lidas y que no est√©n apartadas
                                unidad.capacidadVolumen > 0 && 
                                unidad.capacidadPeso > 0 && 
                                !estaUnidadApartada(unidad.economico)
                            );

                        console.log('Unidades disponibles procesadas:', unidades);
                        return unidades;
                    } catch (error) {
                        console.error('Error al obtener unidades disponibles:', error);
                        return [];
                    }
                }

                async function obtenerDistribucionActual() {
                    const tbody = document.getElementById('tablaDistribucionSugerida');
                    const filas = tbody.getElementsByTagName('tr');
                    const distribucion = [];

                    for (let fila of filas) {
                        const celdas = fila.getElementsByTagName('td');
                        const descripcionesCell = celdas[3]; // Celda de descripciones
                        const descripciones = descripcionesCell.innerHTML
                            .replace(/<br>/g, '\n')  // Reemplazar <br> por saltos de l√≠nea
                            .replace(/<[^>]*>/g, '')  // Eliminar cualquier otra etiqueta HTML
                            .trim();

                        distribucion.push({
                            unidad: celdas[0].textContent,
                            economico: celdas[1].textContent,
                            llantasEstimadas: parseInt(celdas[2].textContent),
                            descripciones: descripciones !== 'Sin descripciones' ? descripciones : '',
                            volumen: parseNumber(celdas[4].textContent),
                            peso: parseNumber(celdas[5].textContent),
                            eficiencia: parseNumber(celdas[6].textContent)
                        });
                    }

                    return distribucion;
                }
            </script>
            <div class="accordion mb-3" id="acordeonDistribucionMultiple" style="display:none;">
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button" type="button" 
                                data-bs-toggle="collapse" 
                                data-bs-target="#collapseDistribucionMultiple" 
                                aria-expanded="false" 
                                aria-controls="collapseDistribucionMultiple">
                            <div class="d-flex align-items-center w-100">
                                <i class="bi bi-truck-flatbed me-2"></i>
                                <span class="me-auto">Distribuci√≥n Sugerida Multi-Unidad</span>
                            </div>
                        </button>
                    </h2>
                    <div id="collapseDistribucionMultiple" 
                         class="accordion-collapse collapse" 
                         data-bs-parent="#acordeonDistribucionMultiple">
                        <div class="accordion-body">
                            <div class="alert alert-info">
                                <h5><i class="bi bi-info-circle"></i> Distribuci√≥n Sugerida del Pedido</h5>
                                <p>Este pedido requiere distribuci√≥n en m√∫ltiples unidades para √≥ptimo manejo:</p>
                            </div>
                            <div class="table-responsive">
                                <table class="table table-bordered">
                                    <thead>
                                        <tr>
                                            <th>Unidad</th>
                                            <th>Econ√≥mico</th>
                                            <th>Llantas Est.</th>
                                            <th>Descripciones</th>
                                            <th>Volumen</th>
                                            <th>Peso</th>
                                            <th>Eficiencia</th>
                                        </tr>
                                    </thead>
                                    <tbody id="tablaDistribucionSugerida">
                                        <!-- La distribuci√≥n se insertar√° aqu√≠ din√°micamente -->
                                    </tbody>
                                </table>
                            </div>
                            <div class="d-flex justify-content-center mt-3" id="botonesDistribucionMultiple">
                                <button class="btn btn-warning btn-lg" onclick="apartarDistribucionCompleta(this)">
                                    <i class="bi bi-box-arrow-right"></i> Apartar Distribuci√≥n Completa
                                </button>
                            </div>
                            <div class="alert alert-warning mt-3">
                                <i class="bi bi-info-circle"></i> Al apartar la distribuci√≥n, se reservar√°n todas las unidades mostradas para este pedido.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Secci√≥n de Unidad Sugerida -->
                <div id="seccionUnidadSugeridaPrincipal" class="card mb-3" style="display: none;">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0">Unidad Sugerida</h5>
                    </div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table table-bordered mb-0">
                                <thead class="bg-light">
                                    <tr>
                                        <th>Unidad</th>
                                        <th>Econ√≥mico</th>
                                        <th>Cap. Volumen</th>
                                        <th>Cap. Peso</th>
                                        <th style="width: 120px">Uso Volumen</th>
                                        <th style="width: 120px">Uso Peso</th>
                                        <th style="width: 120px">Eficiencia</th>
                                        <th style="width: 150px">Acciones</th>
                                    </tr>
                                </thead>
                                <tbody id="tablaUnidadesPrincipal">
                                    <!-- Las unidades sugeridas se insertar√°n aqu√≠ -->
                                 </tbody>
                            </table>
                        </div>
                        <div id="unidadSugeridaDetalles" class="mt-3"></div>
                    </div>
                </div>
            </div>
        </div>
     </div>        
    <!-- Pedidos Apartados -->
    <div id="pedidos-Apartados" class="tabcontent" style="max-width: 1200px;">
        <h3>Pedidos Apartados</h3>
        <table id="tabla">
            <thead>
                <tr>
                    <th>Cami√≥n</th>
                    <th>Llantas</th>
                    <th>Descripci√≥n</th>
                    <th>Cantidad</th>
                    <th>Total,Cantidad</th>
                    <th>L√≠nea</th>
                    <th>Volumen</th>
                    <th>Peso</th>
                    <th>Valor ($)</th>
                    <th>Fecha</th> 
                    <th>Acci√≥n</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>       
    </div>  
  <!-- OCR PDF para traspasos -->
<!-- Modernizado: OCR PDF para traspasos -->         
<!-- Dentro del div id="traspasos" existente -->
<div class="tabcontent" id="traspasos">
    <div class="container py-5">
        <div class="row justify-content-center">
            <div class="col-lg-12">
                <!-- Pesta√±as para los diferentes tipos de traspasos -->
               <!-- Pesta√±as para los diferentes tipos de traspasos -->
               <ul class="nav nav-tabs mb-4" id="traspasosTab" role="tablist">
                   <li class="nav-item" role="presentation">
                       <button class="nav-link active" id="traspasos-normales-tab" data-bs-toggle="tab" data-bs-target="#traspasosNormales" type="button" role="tab">
                           Traspasos
                       </button>  
                   </li>
                   <li class="nav-item" role="presentation">
                       <button class="nav-link" id="traspasos-especiales-tab" data-bs-toggle="tab" data-bs-target="#traspasosEspeciales" type="button" role="tab">
                           Facturas
                       </button> 
                   </li>   
               </ul>                        

               
                <div class="tab-content">
                    <!-- Pesta√±a 1: Escaneo de Traspasos (externo) -->
                    <div class="tab-pane fade show active" id="traspasosNormales">
                           <div style="padding:8px;">
                            <iframe src="https://cubicaje-tres-siglos.github.io/ESCANEOTRASPASOS/"
                                    style="width:100%; height:400px; border:none; border-radius:8px;" 
                                    title="Escaneo de Traspasos"></iframe>
                            <!-- Contenedor est√°tico para los bloques de traspasos (evita creaci√≥n din√°mica y warnings) -->
                            <div id="traspasosGroupsContainer" class="mt-3"></div>
                        </div>
                    </div> 
                
                    
                    <!-- Pesta√±a 2: traspasos Especiales -->  
                    <div class="tab-pane fade" id="traspasosEspeciales">
                        <div class="card shadow-lg border-0 rounded-4">
                            <div class="card-body p-4">   
                                <h3>Escanea tus facturas para ser m√°s √°gil  el proceso</h3>  
                                <div class="mb-3">
                                    <input type="file" id="fileInput" accept="application/pdf,image/*" 
                                           class="form-control" multiple>  
                                </div>
                                <button onclick="processFiles()" class="btn btn-primary w-100 mb-3">
                                    Procesar archivos
                                </button>
                                <button id="traspasosEspecialesCacheClearBtn" class="btn btn-warning w-100 mb-3">
                                   <i class="bi bi-trash"></i> Limpiar Cach√©
                               </button>
                               <div class="input-group mb-3">
                                   <span class="input-group-text">
                                       <i class="bi bi-search"></i>
                                   </span>
                                   <input type="text" 
                                          class="form-control" 
                                          placeholder="Buscar escaneos guardados..." 
                                          oninput="cargarEscaneosGuardados(this.value)">
                               </div>
                                <button onclick="limpiarModales()" class="btn btn-warning" style="position: fixed; bottom: 20px; right: 20px; z-index: 9999; display: none;" id="btnLimpiarModales">
                                   Limpiar interfaz
                               </button>
                               <div id="log" class="alert alert-info mt-3" style="display:none;"></div>
                               <div id="extractedData"></div>
                               <!-- Contenedor est√°tico para las FACTURAS especiales (formato acorde√≥n) -->
                               <h4 class="mt-4">Facturas guardadas</h4>
                               <div id="facturaGroupsContainer_FACTURAS" class="mt-3"></div>
                               <div id="escaneosGuardados" class="mt-4"></div>
                          </div>
                     </div>
                </div> 
             </div> 
        </div> 
     </div> 
 </div> 
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    // Variables de datos
    let INVENTARIO = [];
    let flota = [];
    let pedidosApartados = [];
    // Unidades marcadas como PENDIENTES por el usuario (no est√°n apartadas formalmente)
    let unidadesPendientes = [];
    let pedidosEnCurso = [];
    let pedidoCamion = null;
    let autoUpdateInterval;


    class CacheSystem {
    constructor(ttl = 300000) { // 5 minutos por defecto
        this.cache = new Map();
        this.ttl = ttl;
    }
    
    // ... resto del c√≥digo
}

// Funci√≥n para iniciar actualizaciones autom√°ticas
// Modificar el intervalo de actualizaci√≥n a 2 minutos en lugar de 30 segundos
function iniciarActualizacionesAutomaticas() {
    autoUpdateInterval = setInterval(async () => {
        const tabActiva = document.querySelector('.tablink.active')?.dataset.tab;
        if (!tabActiva) return;
        const tabKey = String(tabActiva).toLowerCase();
        try {
            switch(tabKey) {
                case 'inventario':
                    await fetchINVENTARIO();
                    break;
                case 'flota':
                    await fetchFlota();
                    break;
                case 'pedidos-apartados':
                    await fetchPedidosApartados();
                    break;
                case 'traspasos':
                    await actualizarBloquestraspasos();
                    break;
            }
        } catch (error) {
            console.error('Error en actualizaci√≥n autom√°tica:', error);
        }
    }, 120000); // 2 minutos
}


document.addEventListener('DOMContentLoaded', () => {
    iniciarActualizacionesAutomaticas();
    
    // Helper para abrir una pesta√±a por nombre (y forzar actualizaci√≥n si es Apartados)
    function openTabByName(tabName) {
        const btn = document.querySelector(`.tablink[data-tab="${tabName}"]`);
        if (btn) {
            btn.click();
            // Si es la pesta√±a de Apartados, forzar la carga de datos
            if (tabName === 'pedidos-Apartados' && typeof fetchPedidosApartados === 'function') {
                try { fetchPedidosApartados(); } catch (e) { console.warn(e); }
            }
        }
    }

    // Si la URL tiene hash al cargar, abrir esa pesta√±a
    if (location.hash) {
        const hashTab = location.hash.replace('#', '');
        setTimeout(() => openTabByName(hashTab), 50);
    }

    // Manejar cambios de hash para poder enlazar directamente
    window.addEventListener('hashchange', () => {
        const hashTab = location.hash.replace('#', ''); v
        openTabByName(hashTab);
    });

    // Enlace r√°pido en header: asegurar que haga lo mismo sin recargar
    const linkApartados = document.getElementById('linkApartadosHeader');
    if (linkApartados) {
        linkApartados.addEventListener('click', (e) => {
            e.preventDefault();
            history.replaceState(null, '', '#pedidos-Apartados');
            openTabByName('pedidos-Apartados');
        });
    }
});

function mostrarEstado(mensaje, tipo = 'info') {
    console.log(mensaje);
    const statusDiv = document.createElement('div');
    statusDiv.textContent = mensaje;
    statusDiv.style.position = 'fixed';
    statusDiv.style.bottom = '20px';
    statusDiv.style.right = '20px';
    statusDiv.style.padding = '10px';
    statusDiv.style.backgroundColor = tipo === 'error' ? '#ffebee' : '#f0f4ff';
    statusDiv.style.border = '1px solid #ccc';
    statusDiv.style.borderRadius = '4px';    
    statusDiv.style.zIndex = '1000';
    document.body.appendChild(statusDiv);
    setTimeout(() => statusDiv.remove(), 3000);
}
// Funciones utilitarias
function mostrarMensaje(mensaje, tipo = 'info') {
    const div = document.createElement('div');
    div.className = `alert alert-${tipo}`;
    div.textContent = mensaje;
    document.body.appendChild(div);
    setTimeout(() => div.remove(), 3000);
}

function validarDatos(obj, campos) {
    return campos.every(campo => {
        const valor = obj[campo];
        return valor !== undefined && valor !== null && valor !== '';
    });
}

// Helper: parsea valores que vienen de la hoja y devuelve n√∫mero seguro (0 si no es num√©rico)
function safeNum(v) {
    if (v === null || v === undefined) return 0;
    let s = String(v).trim();
    if (s === '') return 0;
        // Quita s√≠mbolo de moneda y espacios
        s = s.replace(/\$/g, '').replace(/\s+/g, '');
        // Si contiene ambos separadores, asumimos que las comas son separador de miles
        if (s.includes(',') && s.includes('.')) {
            s = s.replace(/,/g, '');
        } else if (s.includes(',') && !s.includes('.')) {
            // Probablemente usan coma como decimal
            s = s.replace(/,/g, '.');
        }
        // Elimina cualquier resto de comas
        s = s.replace(/,/g, '');
        const n = Number(s);
        return isNaN(n) ? 0 : n;
    }
    // Busca una propiedad entre varias alternativas comunes (tolerancia a nombres de columnas)
    function getField(obj, name) {
        if (!obj) return undefined;
        const keys = [name, name.toLowerCase(), name.toUpperCase(), name.charAt(0).toLowerCase() + name.slice(1)];
        // variantes comunes
        const variants = {
            volumen: ['volumen', 'Volumen', 'volumen (m3)', 'Volumen (m3)', 'volume'],
            peso: ['peso', 'Peso', 'weight', 'Weight'],
            valor: ['valor', 'Valor', 'precio', 'Precio', 'value']
        };

        // (el Set `codigosGuardados` se declara en el √°mbito de agregarBloqueEnModo)
        const list = variants[name] || keys;
        for (const k of list) {
            if (k in obj) return obj[k];
        }
        // intenta buscar cualquier key que contenga el nombre
        for (const k of Object.keys(obj)) {
            if (k.toLowerCase().includes(name.toLowerCase())) return obj[k];
        }
        return undefined;
    }

    // Normaliza cadenas para comparaciones (quita tildes, caracteres extra y espacios)
    function normalizeKey(s) {
        if (!s && s !== 0) return '';
        try {
            return String(s)
                .normalize('NFKD') // separar acentos
                .replace(/\p{Diacritic}/gu, '')
                .replace(/[\u200B-\u200D\uFEFF]/g, '') // eliminar chars invisibles
                .replace(/[^\w\s\-]/g, ' ') // reemplazar s√≠mbolos por espacio
                .replace(/\s+/g, ' ') // normalizar espacios
                .trim()
                .toLowerCase();
        } catch (e) {
            return String(s).toLowerCase().trim();
        }
    }

    // Filtra filas vac√≠as/no informativas devueltas por SheetDB
    function filterMeaningfulRows(rows) {
        if (!Array.isArray(rows)) return [];
        return rows.filter(row => {
            if (!row || typeof row !== 'object') return false;
            const vals = Object.values(row).map(v => String(v === null || v === undefined ? '' : v).trim());
            // Considerar no informativas aquellas filas cuyos valores son todos vac√≠os o tokens habituales
            return vals.some(v => v !== '' && v !== '-' && v.toLowerCase() !== 'n/a' && v.toLowerCase() !== 'null' && v.toLowerCase() !== 'undefined');
        });
    }

    // Sanitiza descripciones para la pesta√±a de FACTURAS: elimina un token final corto
    // t√≠picamente del tipo 'H87' o 'AB123' que aparece pegado al final del texto.
    // S√≥lo afecta la visualizaci√≥n en la pesta√±a de FACTURAS.
    function sanitizeFacturaDesc(s) {
        if (!s && s !== 0) return '';
        try {
            let str = String(s).trim();
            if (!str) return ''; 
            // Quitar puntuaci√≥n final
            str = str.replace(/[\)\]\.,;:\s]+$/g, '');
            const parts = str.split(/\s+/);
            if (parts.length === 0) return str;
            let last = parts[parts.length - 1];
            // limpiar par√©ntesis o s√≠mbolos remanentes
            last = last.replace(/^[\(\-\_]+|[\)\-\_]+$/g, '');
            // Si el √∫ltimo token es un c√≥digo corto alfanum√©rico como H87, AB123, etc., lo removemos
            if (/^[A-Z]{1,5}\d{1,5}$/i.test(last)) {
                parts.pop();
                return parts.join(' ').trim();
            }
            return str;
        } catch (e) {
            return String(s).trim();
        }
    }

// ========== AUTOCOMPLETADO GEN√âRICO PARA BLOQUES ==========
async function autocompletarBuscaBloques(inputId, dropdownId) {
    const inputElement = document.getElementById(inputId);
    const raw = (inputElement.value || '').trim();
    const search = normalizeKey(raw);

    if (!search) {
        const dropdown = document.getElementById(dropdownId);
        if (dropdown) dropdown.style.display = 'none';
        return;
    }

    try {
        // Usar la ra√≠z de SheetDB y a√±adir ?sheet= en cada fetch
        const coincidencias = [];
        const seen = new Set();
        const base = 'https://sheetdb.io/api/v1/gdn5wqo960cey';

        // 1. Buscar en escaneos locales (archivosEscaneados)
        if (Array.isArray(archivosEscaneados)) {
            archivosEscaneados.forEach(archivo => {
                if (archivo.productos && Array.isArray(archivo.productos)) {
                    archivo.productos.forEach(prod => {
                        const nombre = normalizeKey(prod.Nombre || prod.nombre || '');
                        const folio = (prod.Folio || prod.folio || '').toString();
                        if (nombre.includes(search) || normalizeKey(folio).includes(search)) {
                            const display = prod.Nombre || prod.Folio || prod.nombre || prod.folio || 'Sin nombre';
                            if (!seen.has(display)) {
                                seen.add(display);
                                coincidencias.push({ display, folio });
                            }
                        }
                    });
                }
            });
        }

        // 2. Buscar en "traspasos"
        try {
            const resTrasp = await fetch(base + '?sheet=traspasos');
            if (resTrasp.ok) {
                const traspasos = filterMeaningfulRows(await resTrasp.json());
                if (Array.isArray(traspasos)) {
                    traspasos.forEach(t => {
                        const nombre = normalizeKey(t.Nombre || t.nombre || '');
                        const folio = (t.Folio || t.folio || '').toString();
                        if (nombre.includes(search) || normalizeKey(folio).includes(search)) {
                            const display = t.Nombre || t.Folio || t.nombre || t.folio || 'Sin nombre';
                            if (!seen.has(display)) {
                                seen.add(display);
                                coincidencias.push({ display, folio });
                            }
                        }
                    });
                }
            }
        } catch (e) {
            console.warn('Error buscando en traspasos:', e);
        }

        // 3. Buscar en "FACTURAS" (traspasos)
        try {
            const resEscan = await fetch(base + '?sheet=FACTURAS');
            if (resEscan.ok) {
                const escaneados = filterMeaningfulRows(await resEscan.json());
                if (Array.isArray(escaneados)) {
                    escaneados.forEach(e => {
                        const nombre = normalizeKey(e.Nombre || e.nombre || '');
                        const folio = (e.Folio || e.folio || '').toString();
                        if (nombre.includes(search) || normalizeKey(folio).includes(search)) {
                            const display = e.Nombre || e.Folio || e.nombre || e.folio || 'Sin nombre';
                            if (!seen.has(display)) {
                                seen.add(display);
                                coincidencias.push({ display, folio });
                            }
                        }
                    });
                }
            }
        } catch (e) {
            console.warn('Error buscando en FACTURAS:', e);
        }

        // Mostrar dropdown con resultados (pasamos objetos {display, folio})
        mostrarDropdownBloques(dropdownId, inputId, coincidencias.slice(0, 10));

    } catch (error) {
        console.error('Error en autocompletarBuscaBloques:', error);
    }
}  

function mostrarDropdownBloques(dropdownId, inputId, coincidencias) {
    let dropdownDiv = document.getElementById(dropdownId);
    if (!dropdownDiv) {
        dropdownDiv = document.createElement('div');
        dropdownDiv.id = dropdownId;
        dropdownDiv.style.cssText = `
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 1000;
            min-width: 350px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            margin-top: 2px;
        `;
        const inputElement = document.getElementById(inputId);
        const parentDiv = inputElement.parentElement.parentElement;
        parentDiv.style.position = 'relative';
        parentDiv.appendChild(dropdownDiv);
    }

    if (coincidencias.length === 0) {
        dropdownDiv.innerHTML = '<div style="padding: 8px 12px; color: #999;">Sin resultados</div>';
    } else {
        dropdownDiv.innerHTML = coincidencias.map(item => {
            const isString = typeof item === 'string';
            const display = isString ? item : (item.display || 'Sin resultados');
            let val = isString ? item : (item.folio || item.display || '');
            if (typeof val !== 'string') val = String(val);
            const safeVal = val.replace(/'/g, "\\'");
            const safeDisplay = String(display).replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return `\n            <div onclick="seleccionarBloqueAutocompletado('${inputId}', '${safeVal}')" style="\n                padding: 10px 12px;\n                cursor: pointer;\n                border-bottom: 1px solid #eee;\n                font-size: 13px;\n                font-weight: 500;\n                color: #333;\n            " onmouseover="this.style.backgroundColor='#f5f5f5'" onmouseout="this.style.backgroundColor='white'">\n                üì¶ ${safeDisplay}\n            </div>\n            `;
        }).join('');
    }

    dropdownDiv.style.display = 'block';  
}

function ocultarDropdownBloques(dropdownId) {
    const dropdown = document.getElementById(dropdownId);
    if (dropdown) dropdown.style.display = 'none';
}

function seleccionarBloqueAutocompletado(inputId, valor) {
    document.getElementById(inputId).value = valor;
    const dropdownId = inputId === 'inputFolioFacturaPedido' ? 'dropdownAutocompleteBloquesPedido' : 'dropdownAutocompleteBloquesNuevo';
    ocultarDropdownBloques(dropdownId);
}

async function buscarBloquePorFolio() {
    const folioRaw = document.getElementById('inputFolioFacturaPedido').value.trim();
    const div = document.getElementById('bloqueBuscadoPedido');
    const folioNorm = normalizeKey(folioRaw);

    // Si no hay folio, limpiar el div y retornar
    if (!folioRaw) {
        div.innerHTML = '';
        return;
    }

    try {
        // Buscar primero en bloquestraspasos (normalizando)
        const bloque = bloquestraspasos.find(b => 
            normalizeKey(b.nombre) === folioNorm || normalizeKey(b.datos[0]?.Folio) === folioNorm
        );

        // Buscar en "FACTURAS" (traspasos)
        const resEscaneados = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=FACTURAS');
        const escaneados = filterMeaningfulRows(await resEscaneados.json());
        const escaneadosDelFolio = escaneados.filter(r => {
            const nombre = normalizeKey(r.Nombre || r.nombre || '');
            const fol = normalizeKey(r.Folio || r.folio || '');
            return nombre === folioNorm || fol === folioNorm || nombre.includes(folioNorm) || fol.includes(folioNorm);
        });

        // Buscar en "traspasos"
        const restraspasos = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=traspasos');
        let traspasosDelFolio = [];
        if (restraspasos.ok) {
            const traspasos = filterMeaningfulRows(await restraspasos.json());
            traspasosDelFolio = traspasos.filter(r => {
                const nombre = normalizeKey(r.Nombre || r.nombre || '');
                const fol = normalizeKey(r.Folio || r.folio || '');
                return nombre === folioNorm || fol === folioNorm || nombre.includes(folioNorm) || fol.includes(folioNorm);
            });
        } else {  
            // Intentar con nombre alternativo
            const restraspasosAlt = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=factura');
            if (restraspasosAlt.ok) {
                const traspasosAlt = filterMeaningfulRows(await restraspasosAlt.json());
                traspasosDelFolio = traspasosAlt.filter(r => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    return nombre === folioNorm || fol === folioNorm || nombre.includes(folioNorm) || fol.includes(folioNorm);
                });
            }
        }

        // Buscar en la hoja "reservados"
        const resReservados = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=reservados');
        const reservados = filterMeaningfulRows(await resReservados.json());
        
        // Agrupar reservados por nombre normalizado
        const reservadosAgrupados = reservados.reduce((grupos, item) => {
            const key = normalizeKey(item.nombre || item.Nombre || item.folio || item.Folio || '');
            if (!grupos[key]) {
                grupos[key] = [];
            }
            grupos[key].push(item);
            return grupos;
        }, {});

        if (bloque) {
            div.innerHTML = `
                   <div class="alert alert-success mt-2">
                    Bloque encontrado en traspasos: ${bloque.nombre}<br>
                    Productos: ${bloque.datos.length}
                </div>
            `;
        } else if (escaneadosDelFolio.length > 0) {
            div.innerHTML = `
                <div class="alert alert-info mt-2">
                    Bloque encontrado en FACTURAS: ${folioRaw}<br>
                    Productos: ${escaneadosDelFolio.length}<br>
                    <table class="table table-bordered mt-2">
                        <thead>
                            <tr>
                                <th>C√≥digo</th>
                                <th>Descripci√≥n</th>
                                <th>L√≠nea</th>
                                <th>Cantidad</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${escaneadosDelFolio.map(item => `
                                <tr>
                                    <td>${item.C√≥digo || item.codigo || ''}</td>
                                    <td>${item.Descripci√≥n || item.descripcion || ''}</td>
                                    <td>${item.L√≠nea || item.linea || ''}</td>
                                    <td>${item.Cantidad || item.cantidad || ''}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        } else if (traspasosDelFolio.length > 0) {
            div.innerHTML = `
                <div class="alert alert-info mt-2">
                    Bloque encontrado en traspasos: ${folioRaw}<br>
                    Productos: ${traspasosDelFolio.length}<br>
                    <table class="table table-bordered mt-2">
                        <thead>
                            <tr>
                                <th>C√≥digo</th>
                                <th>Descripci√≥n</th>
                                <th>L√≠nea</th>
                                <th>Cantidad</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${traspasosDelFolio.map(item => `
                                <tr>
                                    <td>${item.C√≥digo || item.codigo || ''}</td>
                                    <td>${item.Descripci√≥n || item.descripcion || ''}</td>
                                    <td>${item.L√≠nea || item.linea || ''}</td>
                                    <td>${item.Cantidad || item.cantidad || ''}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        } else if (reservadosAgrupados[folioNorm]) {
            const reservadosEncontrados = reservadosAgrupados[folioNorm];
            div.innerHTML = `
                <div class="alert alert-info mt-2">
                    Bloque encontrado en reservados: ${folioRaw}<br>
                    Productos: ${reservadosEncontrados.length}<br>
                    <table class="table table-bordered mt-2">
                        <thead>
                            <tr>
                                <th>C√≥digo</th>
                                <th>Descripci√≥n</th>
                                <th>L√≠nea</th>
                                <th>Cantidad</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${reservadosEncontrados.map(item => `
                                <tr>
                                    <td>${item.C√≥digo}</td>
                                    <td>${item.Descripci√≥n}</td>
                                    <td>${item.L√≠nea}</td>
                                    <td>${item.Cantidad}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        } else if (folioRaw) { // Solo mostrar mensaje de no encontrado si se ingres√≥ un folio
            div.innerHTML = '<div class="alert alert-danger mt-2">No se encontr√≥ ning√∫n bloque con ese folio en traspasos, traspasos o reservados.</div>';
        }
    } catch (error) {
        console.error('Error al buscar:', error);
        if (folioRaw) { // Solo mostrar error si se ingres√≥ un folio
            div.innerHTML = '<div class="alert alert-danger mt-2">Error al buscar el bloque.</div>';
        }
    }
}
// Agregar este evento para limpiar el mensaje cuando se borre el input
document.getElementById('inputFolioFacturaPedido').addEventListener('input', function() {
    if (!this.value.trim()) {
        document.getElementById('bloqueBuscadoPedido').innerHTML = '';
    }
});
// Pega aqu√≠:
async function agregarBloquePorFolioPedido(agregarMas = false) {
    const folioRaw = document.getElementById('inputFolioFacturaPedido').value.trim();
    const folio = normalizeKey(folioRaw);
    if (!folioRaw) {
        alert('Escribe un folio v√°lido.');
        return;
    }
    
    const bloquesPendientesDiv = document.getElementById('bloquesPendientes');

    try {
        console.log("=== DIAGN√ìSTICO DE B√öSQUEDA ===");
        console.log("Folio ingresado (raw):", folioRaw);
        console.log("Folio normalizado:", folio);
        const divResultado = document.getElementById('bloqueBuscadoPedido');
        let productosAgregados = false;

        // 1. Buscar primero en traspasosParaGuardar (traspasos reci√©n escaneadas)
        console.log("Buscando en traspasos reci√©n escaneadas...", traspasosParaGuardar);
        const traspasosRecientes = traspasosParaGuardar.filter(f => {
            const nombre = normalizeKey(f.Nombre || f.nombre || '');
            const fol = normalizeKey(f.Folio || f.folio || '');
            return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);

        });

        if (traspasosRecientes.length > 0) {
            console.log("Encontrado en traspasos reci√©n escaneadas:", traspasosRecientes);
            await procesarBloquetraspasos(traspasosRecientes, folio);
            productosAgregados = true;
        }                   

        // 2. Buscar en FACTURAS
        console.log("Buscando en FACTURAS...");
        try {
            const resEscaneados = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=FACTURAS');
            if (!resEscaneados.ok) {
                const txt = await resEscaneados.text().catch(()=>'<no body>');
                console.warn('Respuesta no OK de FACTURAS:', resEscaneados.status, txt);
            } else {
                const escaneados = filterMeaningfulRows(await resEscaneados.json());
                console.log("Total de registros en FACTURAS:", escaneados.length);
                console.log("Buscando coincidencia de:", folio, "en registros...");
                escaneados.slice(0, 5).forEach((r, idx) => {
                    console.log(`  Registro ${idx}: Nombre="${r.Nombre}" | Folio="${r.Folio}" | Nombre norm="${normalizeKey(r.Nombre || r.nombre || '')}" | Folio norm="${normalizeKey(r.Folio || r.folio || '')}"`);
                });
                
                const escaneadosDelFolio = escaneados.filter(r => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    const match = nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                    if (match) console.log("  ‚úì COINCIDENCIA:", r.Nombre, r.Folio);
                    return match;
                });

                if (escaneadosDelFolio.length > 0) {
                    console.log("Encontrado en FACTURAS:", escaneadosDelFolio);
                    try {
                        await procesarBloquetraspasos(escaneadosDelFolio, folio);
                        productosAgregados = true;
                    } catch (e) {
                        console.error('Error al procesar productos de FACTURAS:', e);
                        document.getElementById('bloqueBuscadoPedido').innerHTML = `<div class="alert alert-danger mt-2">Error al procesar productos de FACTURAS: ${e.message || e}</div>`;
                        return;
                    }
                }
            }
        } catch (e) {
            console.error('Fetch error FACTURAS:', e);
        }

        // 2.5. Buscar en traspasos (sheet)
        console.log("Buscando en traspasos (sheet)...");
        try {
            const restraspasos = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=traspasos');
            if (!restraspasos.ok) {
                const txt = await restraspasos.text().catch(()=>'<no body>');
                console.warn('Sheet "traspasos" no OK. Status:', restraspasos.status);
            } else {
                const traspasosSheet = filterMeaningfulRows(await restraspasos.json());
                console.log("Total de registros en traspasos (sheet):", traspasosSheet.length);
                console.log("=== PRIMEROS 10 REGISTROS EN TRASPASOS ===");
                traspasosSheet.slice(0, 10).forEach((r, idx) => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    console.log(`${idx + 1}. Nombre="${r.Nombre}" (norm:"${nombre}") | Folio="${r.Folio}" (norm:"${fol}")`);
                });
                console.log("=== BUSCANDO COINCIDENCIA PARA: " + folio + " ===");
                
                const traspasosDelFolio = traspasosSheet.filter(r => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    const exactoNombre = nombre === folio;
                    const exactoFolio = fol === folio;
                    const parcialNombre = nombre.includes(folio);
                    const parcialFolio = fol.includes(folio);
                    const match = exactoNombre || exactoFolio || parcialNombre || parcialFolio;
                    if (match) {
                        console.log(`  ‚úì COINCIDENCIA: "${r.Nombre}" (${exactoNombre ? 'exacto' : 'parcial'}) o "${r.Folio}" (${exactoFolio ? 'exacto' : 'parcial'})`);
                    }
                    return match;
                });
                if (traspasosDelFolio.length > 0) {
                    console.log("Encontrado en traspasos (sheet):", traspasosDelFolio.length, "registros");
                    await procesarBloquetraspasos(traspasosDelFolio, folio);
                    productosAgregados = true;
                } else {
                    console.log("‚ùå NO SE ENCONTRARON COINCIDENCIAS EN TRASPASOS (sheet)");
                }
            }
        } catch (e) {
            console.error('Fetch error traspasos (sheet):', e);
        }

        // 3. Buscar en bloquestraspasos
        console.log("Buscando en bloques de traspasos...");
        const bloquesFactura = bloquestraspasos.filter(b => {     
            const nombreBloque = normalizeKey(b.nombre || '');
            return nombreBloque === folio || nombreBloque.includes(folio);
        });

        if (bloquesFactura.length > 0) {
            console.log("Encontrado en bloques de traspasos:", bloquesFactura);
            for (const bloque of bloquesFactura) {
                await procesarBloquetraspasos(bloque.datos, folio);
            }
            productosAgregados = true;
        }

        // 4. Buscar en reservados como √∫ltima opci√≥n
        console.log("Buscando en reservados...");
        try {
            const resReservados = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=reservados');
            if (!resReservados.ok) {
                const txt = await resReservados.text().catch(()=>'<no body>');
                console.warn('Respuesta no OK de reservados:', resReservados.status, txt);
            } else {
                const reservados = filterMeaningfulRows(await resReservados.json());
                const reservadosDelFolio = reservados.filter(r => {
                    const nombre = normalizeKey(r.nombre || r.Nombre || '');
                    const fol = normalizeKey(r.folio || r.Folio || '');
                    return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                });
                
                if (reservadosDelFolio.length > 0) {
                    console.log("Encontrado en reservados:", reservadosDelFolio);
                    try {
                        await procesarBloquetraspasos(reservadosDelFolio, folio);
                        productosAgregados = true;
                    } catch (e) {
                        console.error('Error al procesar reservados:', e);
                        document.getElementById('bloqueBuscadoPedido').innerHTML = `<div class="alert alert-danger mt-2">Error al procesar reservados: ${e.message || e}</div>`;
                        return;
                    }
                }
            }
        } catch (e) {
            console.error('Fetch error reservados:', e);
        }

        // Mostrar resultado y actualizar interfaz
        if (productosAgregados) {
            if (agregarMas) {
                // Agregar a la lista de bloques pendientes
                const bloquePendiente = document.createElement('div');
                bloquePendiente.className = 'alert alert-info mt-2 d-flex justify-content-between align-items-center';
                bloquePendiente.innerHTML = `
                    <span>
                        <i class="bi bi-box"></i> 
                        Bloque "${folio}" agregado y combinado con el pedido
                    </span>
                `;
                bloquesPendientesDiv.appendChild(bloquePendiente);
                
                // Limpiar solo el input, mantener los productos agregados
                document.getElementById('inputFolioFacturaPedido').value = '';
                divResultado.innerHTML = `
                    <div class="alert alert-success mt-2">
                        <i class="bi bi-plus-circle"></i>
                        Bloque agregado. Puede seguir a√±adiendo m√°s bloques.
                    </div>`;
            } else {
                divResultado.innerHTML = `
                    <div class="alert alert-success mt-2">
                        <i class="bi bi-check-circle"></i>
                        Se agregaron los productos al pedido correctamente.
                    </div>`;
                document.getElementById('inputFolioFacturaPedido').value = '';
                bloquesPendientesDiv.innerHTML = ''; // Limpiar lista de pendientes
            }
            
            // Actualizar interfaz siempre
            renderPedidosActuales();
            actualizarGraficas();
        } else {
            console.log("No se encontr√≥ en ninguna fuente");
            divResultado.innerHTML = `
                <div class="alert alert-danger mt-2">
                    <i class="bi bi-exclamation-triangle"></i>
                    No se encontr√≥ ning√∫n bloque o factura con ese folio o nombre.
                </div>`;
        }

    } catch (error) {
        console.error('Error detallado:', error);
        document.getElementById('bloqueBuscadoPedido').innerHTML = `
            <div class="alert alert-danger mt-2">
                Error al procesar el bloque: ${error.message}
            </div>`;
    }
}

// Nueva funci√≥n para buscar y agregar bloques
async function buscarYAgregarBloque() {
    const folioRaw = document.getElementById('inputBusquedaBloque').value.trim();
    const folio = normalizeKey(folioRaw);
    const resultadoDiv = document.getElementById('resultadoBusquedaBloque');
    
    if (!folioRaw) {
        resultadoDiv.innerHTML = `
            <div class="alert alert-warning">
                <i class="bi bi-exclamation-circle"></i> Por favor, ingrese un folio v√°lido.
            </div>`;
        return;
    }

    try {
        resultadoDiv.innerHTML = `
            <div class="alert alert-info">
                <i class="bi bi-hourglass-split"></i> Buscando bloque...
            </div>`;

        let encontrado = false;
        let llantasEncontradas = [];

        // Buscar en todas las fuentes y extraer las llantas
        // 1. Buscar en traspasos reci√©n escaneadas
        const traspasosRecientes = traspasosParaGuardar.filter(f => {
            const nombre = normalizeKey(f.Nombre || f.nombre || '');
            const fol = normalizeKey(f.Folio || f.folio || '');
            return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
        });
        if (traspasosRecientes.length > 0) {
            llantasEncontradas = llantasEncontradas.concat(traspasosRecientes);
            encontrado = true;
        }

        // 2. Buscar en FACTURAS
        try {
            const resEscaneados = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=FACTURAS');
            if (resEscaneados.ok) {
                const escaneados = filterMeaningfulRows(await resEscaneados.json());
                const escaneadosDelFolio = escaneados.filter(r => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                });
                if (escaneadosDelFolio.length > 0) {
                    llantasEncontradas = llantasEncontradas.concat(escaneadosDelFolio);
                    encontrado = true;
                }
            }
        } catch (e) {
            console.warn('Error buscando en FACTURAS:', e);
        }

        // 2.5. Buscar en FACTURAS
        try {
            const resFACTURAS = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=traspasos');
            let FACTURAS = [];
            if (resFACTURAS.ok) {
                FACTURAS = filterMeaningfulRows(await resFACTURAS.json());
            } else {
                // Intentar con nombre alternativo
                const resFACTURASAlt = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=traspasos');
                if (resFACTURASAlt.ok) {
                    FACTURAS = filterMeaningfulRows(await resFACTURASAlt.json());
                }
            }
            
            if (FACTURAS.length > 0) {
                const FACTURASDelFolio = FACTURAS.filter(r => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                });
                if (FACTURASDelFolio.length > 0) {
                    llantasEncontradas = llantasEncontradas.concat(FACTURASDelFolio);
                    encontrado = true;
                }
            }
        } catch (e) {
            console.warn('Error buscando en FACTURAS:', e);
        }

        // 3. Buscar en bloques de traspasos
        const bloquesFactura = bloquestraspasos.filter(b => {
            const nombreBloque = normalizeKey(b.nombre || '');
            return nombreBloque === folio || nombreBloque.includes(folio);
        });
        if (bloquesFactura.length > 0) {
            llantasEncontradas = llantasEncontradas.concat(bloquesFactura[0].datos || []);
            encontrado = true;
        }

        // 4. Buscar en reservados
        try {
            const resReservados = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=reservados');
            if (resReservados.ok) {
                const reservados = filterMeaningfulRows(await resReservados.json());
                const reservadosDelFolio = reservados.filter(r => {
                    const nombre = normalizeKey(r.nombre || r.Nombre || '');
                    const fol = normalizeKey(r.folio || r.Folio || '');
                    return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                });
                if (reservadosDelFolio.length > 0) {
                    llantasEncontradas = llantasEncontradas.concat(reservadosDelFolio);
                    encontrado = true;
                }
            }
        } catch (e) {
            console.warn('Error buscando en reservados:', e);
        }

        if (encontrado) {
            // Actualizar la tabla de Llantas en el Bloque
            actualizarTablaLlantasBloque(llantasEncontradas);
            resultadoDiv.innerHTML = `
                <div class="alert alert-success">
                    <i class="bi bi-check-circle"></i> Se encontraron ${llantasEncontradas.length} llantas en el bloque.
                </div>`;
        } else {
            resultadoDiv.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-x-circle"></i> No se encontr√≥ ning√∫n bloque con el folio "${folioRaw}".
                </div>`;
        }

    } catch (error) {
        console.error('Error en la b√∫squeda:', error);
        resultadoDiv.innerHTML = `
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> Error al buscar el bloque: ${error.message}
            </div>`;
    }
}

function mostrarResultadoBloque(resultadoDiv, folio, tipo, datos) {
    const cantidadItems = Array.isArray(datos) ? datos.length : (datos.datos ? datos.datos.length : 0);
    
    resultadoDiv.innerHTML += `
        <div class="alert alert-success mt-2">
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <i class="bi bi-box"></i> 
                    Bloque encontrado en ${tipo} (${cantidadItems} items)
                </div>
                <button class="btn btn-sm btn-outline-success" onclick="agregarBloqueEncontrado('${folio}', '${tipo}')">
                    <i class="bi bi-plus-circle"></i> Agregar al pedido
                </button>
            </div>
        </div>`;
}


// Funciones para el nuevo buscador de bloques
async function buscarBloqueEnModo() {
    const folioRaw = document.getElementById('inputBusquedaBloqueNuevo').value.trim();
    const folio = normalizeKey(folioRaw);
    const divResultado = document.getElementById('resultadoBusquedaBloqueNuevo');
    
    if (!folioRaw) {
        divResultado.innerHTML = `
            <div class="alert alert-warning">
                <i class="bi bi-exclamation-circle"></i> Por favor, ingrese un folio v√°lido.
            </div>`;
        return;
    }  
       
    try {
        divResultado.innerHTML = `   
            <div class="alert alert-info">
                <i class="bi bi-hourglass-split"></i> Buscando bloque...
            </div>`;

        let encontrado = false;

        // 1. Buscar en traspasos reci√©n escaneadas
        const traspasosRecientes = traspasosParaGuardar.filter(f => {
            const nombre = normalizeKey(f.Nombre || f.nombre || '');
            const fol = normalizeKey(f.Folio || f.folio || '');
            return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
        });
        if (traspasosRecientes.length > 0) {
            mostrarResultadoBloqueModo(divResultado, folio, 'traspasos recientes', traspasosRecientes);
            encontrado = true;
        }

        // 2. Buscar en FACTURAS
        try {
            const resEscaneados = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=FACTURAS');
            if (resEscaneados.ok) {
                const escaneados = filterMeaningfulRows(await resEscaneados.json());
                const escaneadosDelFolio = escaneados.filter(r => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                });
                if (escaneadosDelFolio.length > 0) {
                    mostrarResultadoBloqueModo(divResultado, folio, 'FACTURAS', escaneadosDelFolio);
                    encontrado = true;
                }
            }
        } catch (e) {
            console.warn('Error buscando en FACTURAS:', e);
        }

        // 3. Buscar en traspasos (sheet) - M√ÅS EQUIPADO
        try {
            const restraspasos = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=traspasos');
            let traspasosDelFolio = [];
            if (restraspasos.ok) {
                const traspasos = filterMeaningfulRows(await restraspasos.json());
                traspasosDelFolio = traspasos.filter(r => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                });
            } else {
                // Intentar con nombre alternativo
                try {
                    const restraspasosAlt = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=factura');
                    if (restraspasosAlt.ok) {
                        const traspasosAlt = filterMeaningfulRows(await restraspasosAlt.json());
                        traspasosDelFolio = traspasosAlt.filter(r => {
                            const nombre = normalizeKey(r.Nombre || r.nombre || '');
                            const fol = normalizeKey(r.Folio || r.folio || '');
                            return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                        });
                    }
                } catch (eAlt) {
                    console.warn('Error intentando hoja alternativa "factura":', eAlt);
                }
            }
            
            if (traspasosDelFolio.length > 0) {
                mostrarResultadoBloqueModo(divResultado, folio, 'traspasos', traspasosDelFolio);
                encontrado = true;
            }
        } catch (e) {
            console.warn('Error buscando en traspasos (sheet):', e);
        }

        // 4. Buscar en bloques de traspasos
        const bloquesFactura = bloquestraspasos.filter(b => {
            const nombreBloque = normalizeKey(b.nombre || '');
            return nombreBloque === folio || nombreBloque.includes(folio);
        });
        if (bloquesFactura.length > 0) {
            mostrarResultadoBloqueModo(divResultado, folio, 'bloques de traspasos', bloquesFactura);
            encontrado = true;
        }

        if (!encontrado) {
            divResultado.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-x-circle"></i> No se encontr√≥ ning√∫n bloque con el folio "${folio}".
                </div>`;
        }

    } catch (error) {
        console.error('Error en la b√∫squeda:', error);
        divResultado.innerHTML = `
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> Error al buscar el bloque: ${error.message}
            </div>`;
    }
}

// Utilidades num√©ricas: parseo robusto y formateo en espa√±ol (coma decimal)
function parseNumber(input) {
    if (input === null || input === undefined) return 0;
    if (typeof input === 'number') return isNaN(input) ? 0 : input;
    let s = String(input).trim();
    if (s === '') return 0;
    // Eliminar s√≠mbolo de moneda y espacios
    s = s.replace(/\$/g, '').replace(/\s+/g, '');
    // Si contiene ambos separadores, asumimos que '.' es decimal y ',' miles -> eliminar ','
    if (s.indexOf(',') > -1 && s.indexOf('.') > -1) {
        s = s.replace(/,/g, '');
    } else if (s.indexOf(',') > -1 && s.indexOf('.') === -1) {
        // Solo coma: asumir que es separador decimal
        s = s.replace(/,/g, '.');
    } else {
        // Solo puntos (o ninguno) -> dejar como est√°
    }
    const n = parseFloat(s);
    return isNaN(n) ? 0 : n;
}

function formatNumber(value, decimals = 2, isCurrency = false) {
    const opts = { minimumFractionDigits: decimals, maximumFractionDigits: decimals };
    if (isCurrency) {
        // Mostrar sin s√≠mbolo aqu√≠; quien llama a√±adir√° '$' si lo desea
    }
    try {
        return new Intl.NumberFormat('es-MX', opts).format(Number(value) || 0);
    } catch (e) {
        return (Number(value) || 0).toFixed(decimals).replace('.', ',');
    }
}

function getNumericTotal(elementId) {
    const el = document.getElementById(elementId);
    if (!el) return 0;
    // Preferir dataset.value si est√° presente
    if (el.dataset && el.dataset.value !== undefined) {
        return parseNumber(el.dataset.value);
    }
    return parseNumber(el.textContent || el.innerText || '0');
}

function mostrarResultadoBloqueModo(divResultado, folio, tipo, datos) {
    const cantidadItems = Array.isArray(datos) ? datos.length : (datos.datos ? datos.datos.length : 0);
    
    divResultado.innerHTML = `
        <div class="alert alert-success">
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <i class="bi bi-box"></i> 
                    Bloque encontrado en ${tipo} (${cantidadItems} items)
                </div>
                <button class="btn btn-sm btn-outline-success" onclick="document.getElementById('inputBusquedaBloqueNuevo').value='${folio}'; agregarBloqueEnModo()">
                    <i class="bi bi-plus-circle"></i> Agregar al bloque
                </button>
            </div>
        </div>`;
}

// Funci√≥n para obtener los datos de la flota
function obtenerDatosFlota() {
    const tablaFlota = document.querySelector('#flota table tbody');
    if (!tablaFlota) return [];
    
    // Obtener el volumen y peso total del bloque actual (num√©rico, usando helper)
    const volumenTotal = getNumericTotal('totalVolumenLlantas');
    const pesoTotal = getNumericTotal('totalPesoLlantas');
    
    return Array.from(tablaFlota.rows)
        .map(row => {
            // Extraer los valores y limpiarlos
            const volumenStr = row.cells[7].textContent.trim();
            const pesoStr = row.cells[6].textContent.trim();
            const ubic = (row.cells[5].textContent || '').toString().trim();
            
            // Convertir y validar los valores (parseo robusto)
            const capacidadVolumen = parseNumber(volumenStr) || 0;
            const capacidadPeso = parseNumber(pesoStr) || 0;
            
            // Calcular uso de volumen y peso (evitar divisi√≥n por cero)
            const usoVolumen = capacidadVolumen > 0 ? (volumenTotal / capacidadVolumen) * 100 : 9999;
            const usoPeso = capacidadPeso > 0 ? (pesoTotal / capacidadPeso) * 100 : 9999;
            
            return {
                nombre: row.cells[1].textContent.trim(), // columna 'unidad'
                economico: row.cells[0].textContent.trim(), // columna 'economico'
                ubicacion: ubic,
                capacidadVolumen: capacidadVolumen,
                capacidadPeso: capacidadPeso,
                usoVolumen: usoVolumen,
                usoPeso: usoPeso,
                puedeTransportar: capacidadVolumen > 0 && capacidadPeso > 0 && usoVolumen <= 100 && usoPeso <= 100
            };
        })
        .filter(unidad => unidad.puedeTransportar); // Solo retornar unidades que pueden transportar la carga
}

// Funci√≥n para apartar una unidad
async function apartarUnidad(economico) {
    // Verificar si hay llantas en el bloque
    const tablaLlantas = document.getElementById('tablaLlantasBloque');
    if (!tablaLlantas) {
        console.error('No se encontr√≥ la tabla de llantas');
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'Error al acceder a las llantas del pedido'
        });
        return;
    }

    // Verificar si hay filas en la tabla (excluyendo encabezados y pie de tabla)
    const filas = Array.from(tablaLlantas.rows);
    if (filas.length === 0) {
        console.error('La tabla de llantas est√° vac√≠a');
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'No se han agregado llantas al pedido'
        });
        return;
    }

    // Verificar que haya datos v√°lidos en las filas
    const llantasValidas = filas.some(row => 
        row.cells.length >= 4 && 
        row.cells[3].textContent && 
        parseInt(row.cells[3].textContent) > 0
    );

    if (!llantasValidas) {
        console.error('No se encontraron llantas v√°lidas en la tabla');
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'No hay llantas v√°lidas en el pedido'
        });
        return;
    }

    // Obtener los datos de la unidad seleccionada
    const unidad = obtenerDatosFlota().find(u => u.economico === economico);
    
    if (!unidad) {
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'No se encontr√≥ la unidad seleccionada'
        });
        return;
    }
  
    // Verificar totales antes de continuar
    const totalVolumen = getNumericTotal('totalVolumenLlantas');
    const totalPeso = getNumericTotal('totalPesoLlantas');
    
    if (totalVolumen === 0 || totalPeso === 0) {
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'Los totales de volumen y peso no son v√°lidos'
        });
        return;
    }

    // Solicitar el nombre del cliente
    const nombreResult = await Swal.fire({
        title: 'Nombre del cliente',
        input: 'text',
        inputLabel: 'Por favor, ingrese el nombre del cliente que hace el pedido',
        inputPlaceholder: 'Nombre completo',
        showCancelButton: true,
        confirmButtonText: 'Continuar',
        cancelButtonText: 'Cancelar',
        inputValidator: (value) => {
            if (!value) {
                return 'Debe ingresar un nombre';
            }
        }
    });

    if (!nombreResult.isConfirmed || !nombreResult.value) {
        return;
    }

    const nombrePedido = nombreResult.value;
    // Recopilar llantas del bloque (para uso en 'Agregar otro cliente' o confirmaci√≥n)
    const llantasObj = recolectarLlantasBloque();

    // Confirmar la operaci√≥n
    const result = await Swal.fire({
        icon: 'question',
        title: '¬øApartar unidad?',
        text: `¬øDesea apartar la unidad ${unidad.nombre} (${unidad.economico}) para este pedido?`,
        html: `
            <p>Cliente: <strong>${nombrePedido}</strong></p>
            <p>Unidad: <strong>${unidad.nombre} (${unidad.economico})</strong></p>
        `,
        showCancelButton: true,
        confirmButtonText: 'S√≠, apartar',
        cancelButtonText: 'Cancelar'
    });
   
    
    if (result.isConfirmed) {
        try {
            // Recopilar las llantas del bloque
            const llantas = Array.from(tablaLlantas.rows)
                .filter(row => row.cells.length >= 7) // Asegurarse de que la fila tiene todas las columnas necesarias
                .map(row => {
                    try {
                        return {
                            codigo: row.cells[0].textContent.trim(),
                            descripcion: row.cells[1].textContent.trim(),
                            linea: row.cells[2].textContent.trim(),
                            cantidad: parseInt(row.cells[3].textContent) || 0,
                            volumen: parseNumber(row.cells[4].textContent) || 0,
                            peso: parseNumber(row.cells[5].textContent) || 0,
                            valor: parseNumber(row.cells[6].textContent.replace(/[^0-9,.-]+/g, '')) || 0
                        };
                    } catch (error) {
                        console.error('Error al procesar fila:', error);
                        return null;  
                    }
                })
                .filter(llanta => llanta && llanta.cantidad > 0); // Filtrar llantas nulas o con cantidad 0
                
            if (llantas.length === 0) {
                throw new Error('No se encontraron llantas v√°lidas para procesar');
            }

            // Recopilar informaci√≥n del pedido
            const fecha = new Date().toLocaleString('es-MX', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });

            // Procesar las llantas para obtener totales y descripciones
            const totalLlantas = llantas.reduce((total, l) => total + l.cantidad, 0);
            const descripcionesLlantas = llantas.map(l => `${l.cantidad}x ${l.descripcion}`).join(', ');
            const volumenTotal = llantas.reduce((total, l) => total + l.volumen, 0);
            const pesoTotal = llantas.reduce((total, l) => total + l.peso, 0);

            // Preparar los datos para enviar a SheetDB
            const datosParaEnviar = {
                data: [{
                    "Fecha": fecha,
                    "Unidad": unidad.nombre || "",
                    "Econ√≥mico": unidad.economico || "",
                    "Nombre": nombrePedido,
                    "Llantas": totalLlantas.toString(),
                    "Descripcion": descripcionesLlantas,
                    "Volumen": volumenTotal.toFixed(2),
                    "Peso": pesoTotal.toFixed(2)
                }]
            };

            // Enviar a SheetDB (hoja Apartados) usando helper y registrar payload/response para depuraci√≥n
            try {
                const url = buildSheetdbUrl('Apartados');
                console.log('apartarUnidad -> POST', url, datosParaEnviar);
                try { const logsBox = document.getElementById('pendingSyncLogs'); if (logsBox) { logsBox.insertAdjacentHTML('afterbegin', `<div style="font-size:12px;color:#0077aa;margin-bottom:6px">[${new Date().toLocaleTimeString()}] APARTADOS POST: ${escapeHtml(JSON.stringify(datosParaEnviar).slice(0,1000))}</div>`); } } catch(e){}
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(datosParaEnviar)
                });
                const respText = await response.text().catch(() => '');
                try { const logsBox = document.getElementById('pendingSyncLogs'); if (logsBox) { const color = response.ok ? '#2b7a13' : '#b35100'; logsBox.insertAdjacentHTML('afterbegin', `<div style="font-size:12px;color:${color};margin-bottom:6px">[${new Date().toLocaleTimeString()}] APARTADOS RESP (${response.status}): ${escapeHtml(String(respText).slice(0,500))}</div>`); } } catch(e){}
                if (!response.ok) throw new Error('Error al guardar en Apartados: ' + (response.status || 'no-status'));
            } catch (err) {
                console.error('Error al POST a Apartados', err);
                throw err;
            }

            // Actualizar la vista de pedidos Apartados
            await fetchPedidosApartados();

            // Limpiar completamente la pesta√±a de b√∫squeda de bloques
            // Limpiar tabla de llantas
            tablaLlantas.innerHTML = '';
            const elVol = document.getElementById('totalVolumenLlantas');
            const elPes = document.getElementById('totalPesoLlantas');
            const elVal = document.getElementById('totalValorLlantas');
            const elCan = document.getElementById('totalCantidadLlantas');
            if (elVol) { elVol.dataset.value = 0; elVol.textContent = formatNumber(0,3); }
            if (elPes) { elPes.dataset.value = 0; elPes.textContent = formatNumber(0,3); }
            if (elVal) { elVal.dataset.value = 0; elVal.textContent = `$${formatNumber(0,2)}`; }
            if (elCan) { elCan.dataset.value = 0; elCan.textContent = 0; }

            // Limpiar campo de b√∫squeda
            const inputBusqueda = document.getElementById('inputBusquedaBloqueNuevo');
            if (inputBusqueda) {
                inputBusqueda.value = '';
            }

            // Limpiar resultados de b√∫squeda
            const resultadoBusqueda = document.getElementById('resultadoBusquedaBloqueNuevo');
            if (resultadoBusqueda) {
                resultadoBusqueda.innerHTML = '';
            }

            // Limpiar contador de llantas
            const contadorLlantas = document.getElementById('contadorLlantasBloque');
            if (contadorLlantas) {
                contadorLlantas.textContent = '0';
            }

            // Restablecer variables globales si existen
            if (window.bloqueSeleccionado) {
                window.bloqueSeleccionado = null;
            }
            if (window.llantasBloque) {
                window.llantasBloque = [];
            }

            // Actualizar las unidades disponibles
            actualizarUnidadesDisponibles();

            // Mostrar mensaje de √©xito y redireccionar
            await Swal.fire({
                icon: 'success',
                title: 'Pedido apartado exitosamente',
                text: `Las llantas han sido apartadas para la unidad ${unidad.nombre} (${unidad.economico})`,
                confirmButtonText: 'Aceptar'
            });

            // Cambiar a la pesta√±a de apartados
            const tabApartados = document.querySelector('[data-tab="pedidos-Apartados"]');
            if (tabApartados) {
                tabApartados.click();
            }

        } catch (error) {
            console.error('Error al apartar:', error);
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: 'Ocurri√≥ un error al apartar las llantas'
            });
        }
    }
}

// Funci√≥n para apartar una unidad desde C√°lculo R√°pido (distribuci√≥n o lista de potenciales)
async function apartarUnidadCalcRapida(economico, volumenAsignado = 0, pesoAsignado = 0) {
    try {
        if (!economico) return Swal.fire('Error','No se especific√≥ el n√∫mero econ√≥mico de la unidad','error');
        if (estaUnidadApartada(economico)) return Swal.fire('Advertencia','La unidad ya est√° apartada','warning');

        // Buscar datos de la unidad (intentar obtener de las unidades disponibles actuales)
        const uds = await obtenerUnidadesDisponibles();
        let unidad = (uds || []).find(u => ((u.economico || u.codigo || '').toString() === (economico || '').toString()));
        // Fallback: intentar obtener desde la flota completa
        if (!unidad) {
            const fl = obtenerUnidadesFlota();
            unidad = (fl || []).find(u => ((u.economico || u.codigo || u.codigo || '').toString() === (economico || '').toString()));
        }

        const totalLlantas = (Array.isArray(combinacionesCalcRapida) ? combinacionesCalcRapida.reduce((t,c) => t + (parseInt(c.cantidad)||0), 0) : 0);
        // Crear descripci√≥n con cantidades: "100 x AUTO", si no hay cantidades usar solo los tipos
        const descripcionItems = Array.isArray(combinacionesCalcRapida) ? combinacionesCalcRapida.map(c => `${c.cantidad} x ${c.tipo}`) : [];
        const tipos = Array.from(new Set((Array.isArray(combinacionesCalcRapida) ? combinacionesCalcRapida.map(c => c.tipo) : []).filter(Boolean)));
        const descripcion = descripcionItems.length ? descripcionItems.join(', ') : (tipos.join(', ') || '');

        // Calcular llantas a asignar proporcionalmente por volumen (fallback a redondeo)
        let llantasAsignadas = 0;
        const volumenTotalLocal = (Array.isArray(combinacionesCalcRapida) ? combinacionesCalcRapida.reduce((t,c) => t + ((c.volumenUnit||0) * (c.cantidad||0)), 0) : 0);
        if (totalLlantas > 0 && volumenTotalLocal > 0) {
            llantasAsignadas = Math.max(1, Math.round(totalLlantas * (volumenAsignado / volumenTotalLocal)));
        } else {
            // fallback: asignar total si no se puede calcular la proporci√≥n
            llantasAsignadas = totalLlantas || 1;
        }

        // Solicitar nombre del cliente
        const nombreResult = await Swal.fire({
            title: 'Nombre del cliente',
            input: 'text',
            inputLabel: 'Por favor, ingrese el nombre del cliente',
            inputPlaceholder: 'Nombre completo',
            showCancelButton: true,
            confirmButtonText: 'Continuar',
            cancelButtonText: 'Cancelar',
            inputValidator: (value) => { if (!value) return 'Debe ingresar un nombre'; }
        });
        if (!nombreResult.isConfirmed || !nombreResult.value) return;
        const nombrePedido = nombreResult.value;

        // Confirmaci√≥n final
        const confirm = await Swal.fire({
            icon: 'question',
            title: '¬øApartar unidad? ',
            html: `<p>Cliente: <strong>${escapeHtml(nombrePedido)}</strong></p>
                   <p>Unidad: <strong>${escapeHtml((unidad && (unidad.nombre||unidad.unidad)) || 'Sin nombre')} (${escapeHtml(economico)})</strong></p>
                   <p>Llantas: <strong>${llantasAsignadas}</strong> ‚Äî Tipos: <strong>${escapeHtml(descripcion)}</strong></p>
                   <p>Volumen: <strong>${Number(volumenAsignado).toFixed(3)} m¬≥</strong> ‚Äî Peso: <strong>${Number(pesoAsignado).toFixed(1)} kg</strong></p>`,
            showDenyButton: true,
            denyButtonText: 'Agregar cliente',
            showCancelButton: true,
            confirmButtonText: 'S√≠, apartar',
            cancelButtonText: 'Cancelar'
        });

        // Si el usuario eligi√≥ "Agregar cliente", abrir formulario flotante para dejar la unidad como pendiente
        if (confirm.isDenied) {
            try {
                await abrirPanelPendienteParaUnidad(unidad, economico, llantasAsignadas, descripcion, volumenAsignado, pesoAsignado, nombrePedido);
            } catch (e) { console.warn('No se pudo guardar como pendiente:', e); }
            return;
        }

        if (!confirm.isConfirmed) return;

        const fecha = new Date().toLocaleString('es-MX', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });

        const datosParaEnviar = { data: [{
            "Fecha": fecha,
            "Unidad": (unidad && (unidad.nombre||unidad.unidad)) || '',
            "Econ√≥mico": economico || '',
            "Nombre": nombrePedido,
            "Llantas": (llantasAsignadas || 0).toString(),
            "Descripcion": descripcion,
            "Volumen": Number(volumenAsignado || 0).toFixed(3),
            "Peso": Number(pesoAsignado || 0).toFixed(1)
        }] };

        // POST a la hoja 'Apartados'
        try {
            const url = buildSheetdbUrl('Apartados');
            const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(datosParaEnviar) });
            const respText = await response.text().catch(() => '');
            if (!response.ok) throw new Error('Error al guardar en Apartados: ' + (response.status || 'no-status'));
            // Registrar localmente y refrescar vista
            pedidosApartados.unshift({
                'Fecha': fecha,
                'Unidad': (unidad && (unidad.nombre||unidad.unidad)) || '',
                'Econ√≥mico': economico || '',
                'Nombre': nombrePedido,
                'Llantas': (llantasAsignadas || 0).toString(),
                'Descripcion': descripcion,
                'Volumen': Number(volumenAsignado || 0).toFixed(3),
                'Peso': Number(pesoAsignado || 0).toFixed(1)
            });

            try { actualizarTablaPedidosApartados(); } catch(e) { console.warn(e); }
            try { await fetchPedidosApartados(); } catch(e) { console.warn(e); }

            Swal.fire({ icon: 'success', title: 'Apartado', text: 'La unidad fue apartada y el registro fue guardado.' });

            // Actualizar disponibilidad y rec√°lculo en C√°lculo R√°pido
            try { actualizarUnidadesDisponibles(); } catch(e) { console.warn(e); }
            try { calcularSugerenciaCalcRapida(); } catch(e) { console.warn(e); }

            // Cambiar a la pesta√±a de apartados para ver el resultado
            const tabApartados = document.querySelector('[data-tab="pedidos-Apartados"]');
            if (tabApartados) tabApartados.click();

        } catch (error) {
            console.error('Error al apartar desde C√°lculo R√°pido:', error);
            Swal.fire({ icon: 'error', title: 'Error', text: 'No se pudo apartar la unidad. Revisa la consola.' });
        }

    } catch (err) {
        console.error('apartarUnidadCalcRapida error', err);
        Swal.fire({ icon: 'error', title: 'Error', text: 'Ocurri√≥ un error inesperado' });
    }
}

// Funci√≥n para actualizar la tabla de unidades disponibles
async function actualizarUnidadesDisponibles() {
    console.log('Actualizando unidades disponibles...');
    const tablaUnidades = document.getElementById('tablaUnidadesDisponibles');
    if (!tablaUnidades) {
        console.log('No se encontr√≥ la tabla de unidades disponibles');
        return;
    }

    // Obtener los totales actuales del bloque (num√©ricos)
    const totalVolumen = getNumericTotal('totalVolumenLlantas');
    const totalPeso = getNumericTotal('totalPesoLlantas');

    // Obtener unidades disponibles
    let unidadesDisponibles = obtenerUnidadesFlota();
    
    // Verificar si alguna unidad puede manejar el pedido sola
    const unidadApta = unidadesDisponibles.find(u => 
        parseNumber(u.capacidadVolumen) >= totalVolumen && 
        parseNumber(u.capacidadPeso) >= totalPeso
    );

    // Si no hay llantas agregadas, no mostrar unidades
    if (totalVolumen === 0 && totalPeso === 0) {
        tablaUnidades.innerHTML = `
            <tr>
                <td colspan="9" class="text-center">
                    <div class="alert alert-info mb-0">
                        Agregue llantas al bloque para ver las unidades disponibles
                    </div>
                </td>
            </tr>`;
        // Ocultar acorde√≥n de Unidades Disponibles (cuerpo y contenedor)
        try {
            const acordeonU = document.getElementById('collapseUnidadesDisponibles');
            if (acordeonU && acordeonU.classList.contains('show')) acordeonU.classList.remove('show');
            const btnU = document.querySelector('[data-bs-target="#collapseUnidadesDisponibles"]');
            if (btnU) btnU.setAttribute('aria-expanded','false');
            const contU = document.getElementById('acordeonUnidadesDisponibles');
            if (contU) contU.style.display = 'none';
        } catch(e) { /* ignore */ }
        // Actualizar visibilidad de Distribuci√≥n Sugerida
        decidirMostrarDistribucion();
        return;
    }

    let datosFlota = obtenerDatosFlota();
    
    // Aplicar filtro por ubicaci√≥n si est√° seleccionado (diferente de 'Todos')
    try {
        const sel = document.getElementById('filtroUbicacionUnidades');
        const ubicFilter = sel ? (sel.value || 'Todos') : 'Todos';
        if (ubicFilter && ubicFilter !== 'Todos') {
            datosFlota = datosFlota.filter(u => (u.ubicacion || '').toString().trim().toLowerCase() === ubicFilter.toString().trim().toLowerCase());
        }
    } catch(e) { console.warn('Error aplicando filtro de ubicaci√≥n:', e); }

    // Filtrar las unidades que ya est√°n en apartados
    if (Array.isArray(pedidosApartados) && pedidosApartados.length > 0) {
        const economicosApartados = pedidosApartados.map(pedido => 
            (pedido.Econ√≥mico || pedido.economico || '').toString().toLowerCase()
        );
        datosFlota = datosFlota.filter(unidad => 
            !economicosApartados.includes((unidad.economico || '').toString().toLowerCase())
        );
    }

    // Filtrar unidades que pueden llevar la carga
    datosFlota = datosFlota.filter(unidad => {
        const capacidadVolumen = parseFloat(unidad.capacidadVolumen) || 0;
        const capacidadPeso = parseFloat(unidad.capacidadPeso) || 0;
        
        // La unidad debe tener capacidad suficiente tanto en volumen como en peso
        return capacidadVolumen >= totalVolumen && capacidadPeso >= totalPeso;
    });
    
    tablaUnidades.innerHTML = '';
    
    if (datosFlota.length === 0) {
        // Si no hay unidades disponibles, mostrar mensaje
        const fila = document.createElement('tr');
        fila.innerHTML = `
            <td colspan="9" class="text-center">
                <div class="alert alert-warning mb-0">
                    <i class="bi bi-exclamation-triangle"></i>
                    No hay unidades disponibles que puedan transportar esta carga
                </div>
            </td>
        `;
        tablaUnidades.appendChild(fila);
        // Asegurar que el acorde√≥n de Unidades Disponibles est√© abierto y visible (incluso si s√≥lo muestra el aviso)
        try {
            const acordeonU = document.getElementById('collapseUnidadesDisponibles');
            if (acordeonU && !acordeonU.classList.contains('show')) acordeonU.classList.add('show');
            const btnU = document.querySelector('[data-bs-target="#collapseUnidadesDisponibles"]');
            if (btnU) btnU.setAttribute('aria-expanded','true');
            const contU = document.getElementById('acordeonUnidadesDisponibles');
            if (contU) contU.style.display = '';
        } catch(e) {}
        // Decidir mostrar distribuci√≥n sugerida (puede abrir el acorde√≥n de distribuci√≥n)
        decidirMostrarDistribucion();
        return;
    }
    
    datosFlota.forEach(unidad => {
        const eficiencia = (unidad.usoVolumen + unidad.usoPeso) / 2;
        
        const fila = document.createElement('tr');
        fila.innerHTML = `
            <td>${unidad.nombre}</td>
            <td>${unidad.economico}</td>
            <td>${unidad.ubicacion || '-'}</td>
            <td>${unidad.capacidadVolumen.toFixed(2)} m¬≥</td>
            <td>${unidad.capacidadPeso.toFixed(2)} kg</td>
            <td>
                <div class="progress">
                    <div class="progress-bar bg-success" 
                         role="progressbar" 
                         style="width: ${unidad.usoVolumen}%">
                        ${unidad.usoVolumen.toFixed(1)}%
                    </div>
                </div>
            </td>
            <td>
                <div class="progress">
                    <div class="progress-bar bg-success" 
                         role="progressbar" 
                         style="width: ${unidad.usoPeso}%">
                        ${unidad.usoPeso.toFixed(1)}%
                    </div>
                </div>
            </td>
            <td>${eficiencia.toFixed(1)}%</td>
            <td>
                <button class="btn btn-success btn-sm" onclick="apartarUnidad('${unidad.economico}')">
                    <i class="bi bi-truck"></i> Apartar
                </button>
            </td>
        `;
        tablaUnidades.appendChild(fila);
    });
    // Asegurar que el acorde√≥n de Unidades Disponibles est√© abierto
    try {
        const acordeonU = document.getElementById('collapseUnidadesDisponibles');
        if (acordeonU && !acordeonU.classList.contains('show')) acordeonU.classList.add('show');
        const btnU = document.querySelector('[data-bs-target="#collapseUnidadesDisponibles"]');
        if (btnU) btnU.setAttribute('aria-expanded','true');
        const contU = document.getElementById('acordeonUnidadesDisponibles');
        if (contU) contU.style.display = '';
    } catch(e) {}
    // Revisar si hay que mostrar la distribuci√≥n sugerida
    decidirMostrarDistribucion();
}

function decidirMostrarDistribucion() {
    try {
        const totalVolumen = getNumericTotal('totalVolumenLlantas') || 0;
        const totalPeso = getNumericTotal('totalPesoLlantas') || 0;
        const unidadesFlota = typeof obtenerUnidadesFlota === 'function' ? obtenerUnidadesFlota() : [];
        const unidadApta = unidadesFlota.find(u => {
            const capVol = parseNumber(u.capacidadVolumen) || parseNumber(u.capacidad || u.capacidadVolumen) || 0;
            const capPeso = parseNumber(u.capacidadPeso) || parseNumber(u.capacidad_peso || u.capacidadPeso) || 0;
            return capVol >= totalVolumen && capPeso >= totalPeso;
        });
        const mostrar = (!unidadApta) && ((totalVolumen || 0) > 0 || (totalPeso || 0) > 0);
        const acordeon = document.getElementById('collapseDistribucionMultiple');
        const cont = document.getElementById('acordeonDistribucionMultiple');
        if (acordeon) {
            if (mostrar) {
                acordeon.classList.add('show');
                if (cont) cont.style.display = '';
            } else {
                acordeon.classList.remove('show');
                if (cont) cont.style.display = 'none';
            }
        } else {
            // Si no se encontr√≥ el collapse, al menos ajustar el contenedor
            if (cont) {
                if (mostrar) cont.style.display = '';
                else cont.style.display = 'none';
            }
        }
    } catch (e) { console.warn('No se pudo decidir mostrar la distribuci√≥n sugerida:', e); }
}

// =================== GESTI√ìN DE UNIDADES PENDIENTES ===================
// Arreglo global: unidadesPendientes (declarado en la secci√≥n de variables)

async function abrirPanelPendienteParaUnidad(unidad, economico, llantasAsignadas, descripcion, volumenAsignado, pesoAsignado, responsable) {
    // Mostrar un modal ligero para capturar el cliente y marcar la unidad como pendiente
    const htmlInfo = `
        <p><strong>Unidad:</strong> ${escapeHtml((unidad && (unidad.nombre||unidad.unidad))||'Sin nombre')} (${escapeHtml(economico)})</p>
        <p><strong>Llantas:</strong> ${llantasAsignadas} ‚Äî <strong>Tipos:</strong> ${escapeHtml(descripcion)}</p>
        <p><strong>Volumen:</strong> ${Number(volumenAsignado).toFixed(3)} m¬≥ ‚Äî <strong>Peso:</strong> ${Number(pesoAsignado).toFixed(1)} kg</p>
    `;

    // Mostrar confirmaci√≥n usando el nombre ya ingresado (no pedirlo de nuevo)
    const res = await Swal.fire({
        title: 'Agregar cliente y dejar pendiente',
        html: htmlInfo + `<p><strong>Cliente:</strong> ${escapeHtml(responsable || '')}</p>`,
        showCancelButton: true,
        confirmButtonText: 'Guardar como pendiente',
        cancelButtonText: 'Cancelar'
    });

    if (!res.isConfirmed) return;

    const cliente = (responsable || '');
    const fecha = new Date().toLocaleString('es-MX', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });

    unidadesPendientes.unshift({
        Fecha: fecha,
        Unidad: (unidad && (unidad.nombre||unidad.unidad)) || '',
        'Econ√≥mico': economico || '',
        Cliente: cliente,
        Nombre: responsable || '',
        Llantas: (llantasAsignadas || 0).toString(),
        Descripcion: descripcion,
        Volumen: Number(volumenAsignado || 0).toFixed(3),
        Peso: Number(pesoAsignado || 0).toFixed(1)
    });

    // Actualizar la UI local inmediatamente
    renderUnidadesPendientes();

    // Intentar persistir en la hoja 'Camiones pendientes' en background y sincronizar con pendingAsignaciones
    (async function(){
        try {
            const last = unidadesPendientes[0];
            const payload = {
                Fecha: last.Fecha || new Date().toLocaleString('es-MX'),
                Unidad: last.Unidad || '',
                'Econ√≥mico': last['Econ√≥mico'] || '',
                Nombre: last.Cliente || last.Nombre || '',
                Llantas: last.Llantas || '',
                Descripcion: last.Descripcion || '',
                Volumen: last.Volumen || '',
                Peso: last.Peso || ''
            };

            const res = await guardarReservaEnSheetDB(payload);
            if (res && res.success) {
                last._saved = true;
                last.row_id = res.data && (res.data.row_id || res.data.id || res.data._id);
            } else {
                last._saved = false;
                last._lastResponse = res && res.text ? String(res.text).slice(0,250) : (res && res.status ? 'ERR '+res.status : 'No response');
            }

            // Mantener tambi√©n copia en pendingAsignaciones para reintentos y para mostrar en la pesta√±a "Pedidos"
            const ecoKey = (payload['Econ√≥mico'] || '').toString();
            pendingAsignaciones[ecoKey] = pendingAsignaciones[ecoKey] || [];
            const copy = normalizePedidoForSheet(Object.assign({}, payload));
            copy._saved = !!last._saved;
            if (last.row_id) copy.row_id = last.row_id;
            copy._lastResponse = last._lastResponse || '';
            pendingAsignaciones[ecoKey].push(copy);
            try { renderPendingAsignaciones(); syncPendingToBurbujas(); } catch(e) { /* no cr√≠tico */ }

        } catch (e) {
            console.warn('Error persistiendo pendiente:', e);
            try {
                const last = unidadesPendientes[0];
                last._saved = false;
                last._lastResponse = String(e).slice(0,250);
                const ecoKey = (last['Econ√≥mico'] || '').toString();
                pendingAsignaciones[ecoKey] = pendingAsignaciones[ecoKey] || [];
                const copy = normalizePedidoForSheet(Object.assign({}, last));
                copy._saved = false;
                copy._lastResponse = last._lastResponse;
                pendingAsignaciones[ecoKey].push(copy);
                try { renderPendingAsignaciones(); syncPendingToBurbujas(); } catch(er){}
            } catch(err){ console.warn(err); }
        }
    })();

    // Limpiar la pesta√±a de C√°lculo R√°pida para empezar un nuevo pedido visualmente
    try { limpiarCalcRapida(); } catch(e) { console.warn('No se pudo limpiar la pesta√±a:', e); }

    // Recalcular disponibilidad para que la unidad pendiente no aparezca en resultados
    try { actualizarUnidadesDisponibles(); } catch (e) { console.warn(e); }
    try { calcularSugerenciaCalcRapida(); } catch (e) { console.warn(e); }
}

function renderUnidadesPendientes() {
    let panel = document.getElementById('panelUnidadesPendientes');
    if (!panel) {
        panel = document.createElement('div');
        panel.id = 'panelUnidadesPendientes';
        // Ajuste: bajar el panel para no cubrir la barra de pesta√±as y limitar su altura
        panel.style.cssText = 'position:fixed; right:20px; top:140px; width:340px; max-height:60vh; overflow:auto; z-index:999; box-shadow:0 8px 24px rgba(0,0,0,0.12);';
        document.body.appendChild(panel);
    }

    // Mostrar el panel s√≥lo cuando la pesta√±a activa sea 'calculo-rapido'
    try {
        const activeTab = (document.querySelector('.tablink.active') && document.querySelector('.tablink.active').dataset.tab) || '';
        if (String(activeTab).toLowerCase() !== 'calculo-rapido') {
            panel.style.display = 'none';
            return; // no renderizar contenido cuando estamos en otra pesta√±a
        }
        panel.style.display = '';
    } catch (e) { console.warn('No se pudo decidir visibilidad del panel de pendientes:', e); }

    if (!Array.isArray(unidadesPendientes) || unidadesPendientes.length === 0) {
        panel.innerHTML = `
            <div class="card">
                <div class="card-body p-2">
                    <small>No hay unidades pendientes</small>
                </div>
            </div>`;
        return;
    }

    // Construir opciones para el select
    const opciones = unidadesPendientes.map((u, i) => `<option value="${i}">${escapeHtml(u.Unidad || '')} ‚Äî ${escapeHtml(u['Econ√≥mico'] || '')} ‚Äî ${escapeHtml(u.Cliente || u.Nombre || '')}</option>`).join('');

    panel.innerHTML = `
        <div class="card p-2">
            <div style="display:flex;justify-content:space-between;align-items:center">
                <div><strong>Unidades contempladas</strong> <small>(${unidadesPendientes.length})</small></div>
                <div style="min-width:160px">
                    <select id="selectPendientes" class="form-select form-select-sm" onchange="mostrarDetallePendiente(this.value)">
                        ${opciones}
                    </select>
                </div>
            </div>
            <div id="detallePendiente" style="margin-top:8px; font-size:0.9em"></div>
        </div>
    `;

    // Mostrar detalle por defecto (preferir la unidad activa si aplica)
    try {
        let defaultIndex = 0;
        if (typeof activePendingEconomico !== 'undefined' && activePendingEconomico) {
            const foundIndex = unidadesPendientes.findIndex(u => normalizeKey(u['Econ√≥mico'] || u.economico || '') === normalizeKey(activePendingEconomico));
            if (foundIndex >= 0) defaultIndex = foundIndex;
            const sel = document.getElementById('selectPendientes'); if (sel) sel.value = defaultIndex;
        }
        mostrarDetallePendiente(defaultIndex);
    } catch(e) { /* no cr√≠tico */ }
}

function mostrarDetallePendiente(index) {
    index = Number(index || 0);
    const panel = document.getElementById('panelUnidadesPendientes');
    if (!panel) return;
    const detalle = panel.querySelector('#detallePendiente');
    if (!detalle) return;

    if (!Array.isArray(unidadesPendientes) || index < 0 || index >= unidadesPendientes.length) {
        detalle.innerHTML = '<small>Elemento no v√°lido.</small>';
        return;
    }

    const u = unidadesPendientes[index];

    // Buscar informaci√≥n de capacidad en la flota para calcular % de uso
    const unidadesFlota = typeof obtenerUnidadesFlota === 'function' ? obtenerUnidadesFlota() : (typeof flota !== 'undefined' ? flota : []);
    const key = (u['Econ√≥mico'] || u.economico || '').toString().trim().toLowerCase();
    const unidadObj = unidadesFlota.find(x => ((x.economico || x.codigo || '') + '').toString().trim().toLowerCase() === key) || {};

    const capVol = parseFloat(unidadObj.capacidadVolumen || unidadObj.capacidad || unidadObj.capacidad_volumen) || 0;
    const capPeso = parseFloat(unidadObj.capacidadPeso || unidadObj.capacidad_peso) || 0;

    const volAsign = parseFloat(u.Volumen || 0) || 0;
    const pesAsign = parseFloat(u.Peso || 0) || 0;

    const pctVol = capVol > 0 ? Math.min(100, (volAsign / capVol) * 100) : null;
    const pctPeso = capPeso > 0 ? Math.min(100, (pesAsign / capPeso) * 100) : null;

    const progClass = (p) => {
        if (p === null) return 'bg-secondary';
        if (p > 90) return 'bg-danger';
        if (p > 75) return 'bg-warning';
        return 'bg-success';
    };

    detalle.innerHTML = `
        <div><strong>Unidad:</strong> ${escapeHtml(u.Unidad || '')} <small>${escapeHtml(u['Econ√≥mico'] || '')}</small></div>
        <div><strong>Cliente:</strong> ${escapeHtml(u.Cliente || u.Nombre || '')}</div>
        <div><strong>Llantas:</strong> ${escapeHtml(u.Llantas || '')} ‚Äî ${escapeHtml(u.Descripcion || '')}</div>
        <div style="margin-top:6px">
            <div><small>Volumen: ${volAsign.toFixed(3)} m¬≥ ${capVol ? ' / ' + capVol.toFixed(3) + ' m¬≥' : ''} ${pctVol !== null ? ' ‚Äî ' + pctVol.toFixed(0) + '%' : ''}</small></div>
            <div class="progress" style="height:8px;margin-bottom:6px;"><div class="progress-bar ${progClass(pctVol)}" style="width:${pctVol !== null ? pctVol : 0}%;"></div></div>
            <div><small>Peso: ${pesAsign.toFixed(1)} kg ${capPeso ? ' / ' + capPeso.toFixed(1) + ' kg' : ''} ${pctPeso !== null ? ' ‚Äî ' + pctPeso.toFixed(0) + '%' : ''}</small></div>
            <div class="progress" style="height:8px;"><div class="progress-bar ${progClass(pctPeso)}" style="width:${pctPeso !== null ? pctPeso : 0}%;"></div></div>
        </div>
        <div style="margin-top:8px; text-align:right">
            <button class="btn btn-sm btn-success" id="btnApartar${index}" type="button">Apartar</button>
            <button class="btn btn-sm btn-danger" id="btnEliminar${index}" type="button">Eliminar</button>
            <button class="btn btn-sm btn-info" id="btnSeguir${index}" type="button">${activePendingEconomico === (u['Econ√≥mico']||u.economico||'') ? 'Activo - Detener' : 'Seguir agregando'}</button>
            ${ (activePendingEconomico === (u['Econ√≥mico']||u.economico||'')) ? '<button class="btn btn-sm btn-primary" id="btnEnviarAhora'+index+'" type="button" style="margin-left:6px">Enviar ahora</button>' : '' }
        </div>
    `; 

    // Attach button handlers (safer que onclick inline)
    try {
        const btnA = detalle.querySelector(`#btnApartar${index}`);
        if (btnA) btnA.addEventListener('click', () => marcarPendienteComoApartada(index));
        const btnE = detalle.querySelector(`#btnEliminar${index}`);
        if (btnE) btnE.addEventListener('click', () => eliminarUnidadPendiente(index));
        const btnS = detalle.querySelector(`#btnSeguir${index}`);
        if (btnS) btnS.addEventListener('click', () => { toggleSeguirAgregando(index); });

        const btnEnviar = detalle.querySelector(`#btnEnviarAhora${index}`);
        if (btnEnviar) {
            // habilitar/inhabilitar seg√∫n acumulado
            btnEnviar.disabled = !(Array.isArray(pedidosEnCurso) && pedidosEnCurso.length > 0);
            btnEnviar.style.pointerEvents = 'auto';
            btnEnviar.addEventListener('click', () => enviarAcumuladoAHora(index));
        }
    } catch (e) { console.warn('No se pudo enlazar handlers detallePendiente:', e); }
}

// Alternar modo "Seguir agregando" para una unidad pendiente
async function toggleSeguirAgregando(index) {
    index = Number(index || 0);
    if (!Array.isArray(unidadesPendientes) || index < 0 || index >= unidadesPendientes.length) {
        Swal.fire('Error', 'Unidad no v√°lida', 'error');
        return;
    }
    const u = unidadesPendientes[index];
    const econ = (u['Econ√≥mico'] || u.economico || '').toString();
    if (!econ) { Swal.fire('Error', 'La unidad no tiene n√∫mero econ√≥mico', 'error'); return; }

    // Si ya est√° activo para esta unidad, detener y guardar lo acumulado (si hay algo)
    if (activePendingEconomico === econ) {
        if (!pedidosEnCurso || pedidosEnCurso.length === 0) {
            activePendingEconomico = null;
            const inputEco = document.getElementById('inputPedidoNumEconomico'); if (inputEco) inputEco.disabled = false;
            Swal.fire('Detenido', `Se dej√≥ de agregar autom√°ticamente al cami√≥n ${econ}`, 'info');
            try { renderUnidadesPendientes(); renderPendingAsignaciones(); } catch(e){}
            return;
        }

        const { value: nombre } = await Swal.fire({
            title: 'Nombre del cliente',
            input: 'text',
            inputLabel: `Guardar llantas en el cami√≥n ${econ}`,
            inputPlaceholder: 'Nombre completo',
            inputValue: u.Nombre || u.Cliente || '',
            showCancelButton: true,
            confirmButtonText: 'Guardar',
            cancelButtonText: 'Cancelar',
            inputValidator: (v) => v ? null : 'Debe ingresar un nombre'
        });

        if (!nombre) return;

        // Calcular totales
        let totalVolumen = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.volumen || cur.Volumen || 0), 0);
        let totalPeso = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.peso || cur.Peso || 0), 0);
        let totalCantidad = pedidosEnCurso.reduce((acc, cur) => acc + (Number(cur.cantidad) || 0), 0);
        const descripcionLlantas = pedidosEnCurso.map(p => `‚Ä¢ ${p.cantidad} x ${p.descripcion}`).join('\n');

        const found = (flota || []).find(f => String(f.economico) === String(econ));
        const unidadName = found ? (found.unidad || '') : (u.Unidad || '');

        const pedidoObj = {
            Fecha: new Date().toLocaleDateString(),
            Unidad: unidadName,
            'Econ√≥mico': econ,
            Nombre: nombre,
            Llantas: String(totalCantidad),
            Descripcion: descripcionLlantas,
            Volumen: String(totalVolumen.toFixed(2)),
            Peso: String(totalPeso.toFixed(2))
        };

        pendingAsignaciones[econ] = pendingAsignaciones[econ] || [];
        if (pendingAsignaciones[econ].length >= 4) {
            Swal.fire('L√≠mite alcanzado', 'No puede agregar m√°s de 4 clientes a este cami√≥n.', 'warning');
            return;
        }

        pendingAsignaciones[econ].push(Object.assign({}, pedidoObj));
        try { await guardarReservaEnSheetDB(pedidoObj); } catch(e){ console.warn('Error guardando pedido desde toggleSeguirAgregando', e); }

        pedidosEnCurso = [];
        activePendingEconomico = null;
        const inputEco = document.getElementById('inputPedidoNumEconomico'); if (inputEco) inputEco.disabled = false;

        try { renderPendingAsignaciones(); renderUnidadesPendientes(); syncPendingToBurbujas(); actualizarGraficas(); } catch(e){}

        Swal.fire('Guardado', `Pedido agregado al cami√≥n ${econ} y sincronizado (si el servidor respondi√≥ correctamente).`, 'success');
        return;
    }

    // Activar modo para esta unidad
    activePendingEconomico = econ;
    const inputEco = document.getElementById('inputPedidoNumEconomico'); if (inputEco) { inputEco.value = econ; inputEco.disabled = true; }
    Swal.fire('Activo', `Ahora se agregar√°n llantas autom√°ticamente al cami√≥n ${econ}`, 'success');
    try { renderUnidadesPendientes(); renderPendingAsignaciones(); } catch(e){}
}

// Enviar las llantas acumuladas AHORA a la unidad activa sin detener el modo
async function enviarAcumuladoAHora(index) {
    index = Number(index || 0);
    if (!Array.isArray(unidadesPendientes) || index < 0 || index >= unidadesPendientes.length) { Swal.fire('Error', 'Unidad no v√°lida', 'error'); return; }
    const u = unidadesPendientes[index];
    const econ = (u['Econ√≥mico'] || u.economico || '').toString();
    if (!econ) { Swal.fire('Error', 'La unidad no tiene n√∫mero econ√≥mico', 'error'); return; }
    if (!activePendingEconomico || String(activePendingEconomico) !== String(econ)) { Swal.fire('Info', 'El modo activo no corresponde a esta unidad', 'info'); return; }
    if (!pedidosEnCurso || pedidosEnCurso.length === 0) { Swal.fire('Info', 'No hay llantas acumuladas para enviar', 'info'); return; }

    const { value: nombre } = await Swal.fire({
        title: 'Nombre del cliente',
        input: 'text',
        inputLabel: `Guardar llantas en el cami√≥n ${econ}`,
        inputPlaceholder: 'Nombre completo',
        inputValue: u.Nombre || u.Cliente || '',
        showCancelButton: true,
        confirmButtonText: 'Guardar',
        cancelButtonText: 'Cancelar',
        inputValidator: (v) => v ? null : 'Debe ingresar un nombre'
    });

    if (!nombre) return;

    // Calcular totales
    let totalVolumen = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.volumen || cur.Volumen || 0), 0);
    let totalPeso = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.peso || cur.Peso || 0), 0);
    let totalCantidad = pedidosEnCurso.reduce((acc, cur) => acc + (Number(cur.cantidad) || 0), 0);
    const descripcionLlantas = pedidosEnCurso.map(p => `‚Ä¢ ${p.cantidad} x ${p.descripcion}`).join('\n');

    const found = (flota || []).find(f => String(f.economico) === String(econ));
    const unidadName = found ? (found.unidad || '') : (u.Unidad || '');

    const pedidoObj = {
        Fecha: new Date().toLocaleDateString(),
        Unidad: unidadName,
        'Econ√≥mico': econ,
        Nombre: nombre,
        Llantas: String(totalCantidad),
        Descripcion: descripcionLlantas,
        Volumen: String(totalVolumen.toFixed(2)),
        Peso: String(totalPeso.toFixed(2))
    };

    // Guardar en pendingAsignaciones (cola) y en unidadesPendientes (UI inmediata)
    pendingAsignaciones[econ] = pendingAsignaciones[econ] || [];
    if (pendingAsignaciones[econ].length >= 4) {
        Swal.fire('L√≠mite alcanzado', 'No puede agregar m√°s de 4 clientes a este cami√≥n.', 'warning');
        return;
    }

    const pedidoCopia = Object.assign({}, pedidoObj);
    pendingAsignaciones[econ].push(pedidoCopia);

    // A√±adir entrada visual en unidadesPendientes (como si se hubiera creado desde el modal)
    try {
        const fecha = new Date().toLocaleString('es-MX', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
        const nuevaUnidad = {
            Fecha: fecha,
            Unidad: unidadName,
            'Econ√≥mico': econ,
            Cliente: nombre,
            Nombre: nombre,
            Llantas: String(totalCantidad),
            Descripcion: descripcionLlantas,
            Volumen: String(Number(totalVolumen || 0).toFixed(3)),
            Peso: String(Number(totalPeso || 0).toFixed(1))
        };

        unidadesPendientes.unshift(nuevaUnidad);

        // Intentar persistir en SheetDB y marcar estado en pendingAsignaciones
        try {
            const res = await guardarReservaEnSheetDB(pedidoCopia);
            if (res && res.success) {
                // marcar el ultimo en pendingAsignaciones como guardado
                const last = pendingAsignaciones[econ][pendingAsignaciones[econ].length - 1];
                if (last) { last._saved = true; last.row_id = res.data && (res.data.row_id || res.data.id || res.data._id); last._lastResponse = `OK ${res.status || ''}`; }
                // marcar la unidad visual como guardada
                const up = unidadesPendientes.find(u2 => normalizeKey(u2['Econ√≥mico'] || u2.economico || '') === normalizeKey(econ) && normalizeKey(u2.Nombre || u2.Cliente || '') === normalizeKey(nombre));
                if (up) { up._saved = true; up.row_id = res.data && (res.data.row_id || res.data.id || res.data._id); }
            } else {
                const last = pendingAsignaciones[econ][pendingAsignaciones[econ].length - 1]; if (last) { last._saved = false; last._lastResponse = `ERR: ${(res && res.text) ? String(res.text).slice(0,300) : 'no-response'}`; }
            }
        } catch (e) { console.warn('Error guardando pedido desde enviarAcumuladoAHora', e); }

    } catch (e) {
        console.warn('Error actualizando unidadesPendientes desde enviarAcumuladoAHora', e);
    }

    // Limpiar acumulado pero mantener el modo activo
    pedidosEnCurso = [];

    try { renderPedidosActuales(); renderPendingAsignaciones(); renderUnidadesPendientes(); actualizarGraficas(); } catch(e){}

    Swal.fire('Guardado', `Pedido agregado al cami√≥n ${econ} y sincronizado (si el servidor respondi√≥ correctamente). Puedes seguir agregando.`, 'success');
}

// Limpiar la pesta√±a de C√°lculo R√°pida (tabla, totales y resultados)
function limpiarCalcRapida() {
    try {
        const tbody = document.querySelector('#tablaLlantasAgregadas tbody');
        if (tbody) tbody.innerHTML = '';
        const totalDiv = document.getElementById('totalLlantas');
        if (totalDiv) totalDiv.innerText = '0';
        const resultadoDiv = document.getElementById('resultadoSugerencia');
        if (resultadoDiv) resultadoDiv.innerHTML = '';
        const resultadoCalc = document.getElementById('resultadoCalcRapida');
        if (resultadoCalc) resultadoCalc.innerHTML = '';
        // Colapsar panel de distribuci√≥n m√∫ltiple si existe
        const acordeon = document.getElementById('collapseDistribucionMultiple');
        if (acordeon) acordeon.classList.remove('show');
        const cont = document.getElementById('acordeonDistribucionMultiple');
        if (cont) cont.style.display = 'none';
    } catch (e) { console.warn('Error limpiando CalcRapida:', e); }
}


async function eliminarUnidadPendiente(index) {
    if (!Array.isArray(unidadesPendientes) || index < 0 || index >= unidadesPendientes.length) return;
    const item = unidadesPendientes[index];
    const econ = item['Econ√≥mico'] || '';
    const nombre = item.Cliente || item.Nombre || '';

    const res = await Swal.fire({
        title: 'Eliminar unidad pendiente',
        html: `¬øEliminar <strong>${escapeHtml(item.Unidad || item['Econ√≥mico'] || '')}</strong> de pendientes y del servidor?`,
        icon: 'warning',
        showCancelButton: true,
        confirmButtonText: 'S√≠, eliminar'
    });

    if (!res.isConfirmed) return;

    try {
        // Intentar eliminar de SheetDB
        const deleted = await eliminarReservaDeSheetDB(econ, nombre);
        if (!deleted) {
            await Swal.fire('Error', 'No se pudo eliminar del servidor. El elemento permanece local y se intentar√° posteriormente.', 'error');
            return;
        }

        // Eliminar de estructuras locales
        unidadesPendientes.splice(index, 1);
        if (activePendingEconomico === econ) { activePendingEconomico = null; const inputEco = document.getElementById('inputPedidoNumEconomico'); if (inputEco) inputEco.disabled = false; }
        if (pendingAsignaciones && pendingAsignaciones[econ]) delete pendingAsignaciones[econ];
        renderUnidadesPendientes();
        try { renderPendingAsignaciones(); syncPendingToBurbujas(); } catch(e){}
        try { actualizarUnidadesDisponibles(); } catch (e) { console.warn(e); }
        try { calcularSugerenciaCalcRapida(); } catch(e) { console.warn(e); }
        await Swal.fire('Eliminado', 'La unidad y sus pendientes fueron eliminados del servidor', 'success');
    } catch (e) {
        console.warn('Error eliminando unidad pendiente:', e);
        await Swal.fire('Error', 'Ocurri√≥ un error al eliminar. Revisa la consola.', 'error');
    }
} 

async function marcarPendienteComoApartada(index) {
    if (!Array.isArray(unidadesPendientes) || index < 0 || index >= unidadesPendientes.length) return;
    const p = unidadesPendientes[index];

    const { value: nombreResponsable } = await Swal.fire({
        title: 'Confirmar Apartado',
        input: 'text',
        inputLabel: 'Nombre del cliente',
        inputPlaceholder: 'Ingresa nombre',
        inputValue: p.Nombre || p.Cliente || '',
        showCancelButton: true,
        confirmButtonText: 'Apartar'
    });

    if (!nombreResponsable) return;

    // Preparar datos para POST (misma estructura que en apartarUnidadCalcRapida)
    const fecha = new Date().toLocaleString('es-MX', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
    const datosParaEnviar = { data: [{
        Fecha: fecha,
        Unidad: p.Unidad || '',
        'Econ√≥mico': p['Econ√≥mico'] || '',
        Nombre: nombreResponsable,
        Llantas: (p.Llantas || 0).toString(),
        Descripcion: p.Descripcion || '',
        Volumen: Number(p.Volumen || 0).toFixed(3),
        Peso: Number(p.Peso || 0).toFixed(1)
    }] };

    try {
        const url = buildSheetdbUrl('Apartados');
        const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(datosParaEnviar) });
        if (!response.ok) throw new Error('Error al guardar en Apartados: ' + (response.status || 'no-status'));

        // Mover a pedidosApartados localmente
        pedidosApartados.unshift({
            Fecha: fecha,
            Unidad: p.Unidad || '',
            'Econ√≥mico': p['Econ√≥mico'] || '',
            Nombre: nombreResponsable,
            Llantas: (p.Llantas || 0).toString(),
            Descripcion: p.Descripcion || '',
            Volumen: Number(p.Volumen || 0).toFixed(3),
            Peso: Number(p.Peso || 0).toFixed(1)
        });

        // Eliminar de pendientes localmente
        unidadesPendientes.splice(index, 1);
        if (activePendingEconomico === (p['Econ√≥mico'] || p.economico || '')) {
            activePendingEconomico = null;
            const inputEco = document.getElementById('inputPedidoNumEconomico'); if (inputEco) inputEco.disabled = false;
        }
        renderUnidadesPendientes();

        // Intentar eliminar entradas previas en 'Camiones pendientes' para limpiar la base
        (async function(){
            try {
                const eco = (p && p['Econ√≥mico']) || '';
                const nombreP = nombreResponsable || p.Nombre || p.Cliente || '';
                const deleted = await eliminarReservaDeSheetDB(eco, nombreP);
                if (deleted) {
                    if (pendingAsignaciones && pendingAsignaciones[eco]) delete pendingAsignaciones[eco];
                    try { renderPendingAsignaciones(); syncPendingToBurbujas(); } catch(e){}
                }
            } catch(e) { console.warn('No se pudo eliminar fila pendiente tras apartar:', e); }
        })();

        // Refrescar vistas
        try { actualizarTablaPedidosApartados(); } catch(e) { console.warn(e); }
        try { fetchPedidosApartados(); } catch(e) { console.warn(e); }
        try { actualizarUnidadesDisponibles(); } catch(e) { console.warn(e); }
        try { calcularSugerenciaCalcRapida(); } catch(e) { console.warn(e); }

        Swal.fire('Apartada', 'La unidad pendiente fue apartada correctamente', 'success');
    } catch (error) {
        console.error('Error al apartar pendiente:', error);
        Swal.fire('Error', 'No se pudo apartar la unidad pendiente', 'error');
    }
}

/* Sistema de burbujas eliminado por petici√≥n del usuario. 
   Se dejaron stubs m√≠nimos para evitar errores si alguna parte del c√≥digo invoca funciones antiguas. */
window.burbujas = {};
function abrirBurbuja() { console.info('abrirBurbuja: funcionalidad eliminada'); }
function promptAgregarClienteEnBurbuja() { return Swal.fire('Funci√≥n deshabilitada', 'La funcionalidad de burbujas fue removida.', 'info'); }
function agregarClienteABurbuja() { console.info('agregarClienteABurbuja: stub'); }
function finalizarBurbuja() { return Swal.fire('Funci√≥n deshabilitada', 'La funcionalidad de burbujas fue removida.', 'info'); }
function vaciarBurbuja() { console.info('vaciarBurbuja: stub'); }
function cerrarBurbuja() { console.info('cerrarBurbuja: stub'); }
function eliminarClienteDeBurbuja() { console.info('eliminarClienteDeBurbuja: stub'); }
function renderBurbuja() { /* no-op */ }
function renderBurbujasList() { /* no-op */ }
function focusBurbuja() { /* no-op */ }
function updateBurbujaChart() { /* no-op */ }



async function agregarBloqueEnModo(continuarAgregando = false) {
    const folioRaw = document.getElementById('inputBusquedaBloqueNuevo').value.trim();
    const folio = normalizeKey(folioRaw);
    const divResultado = document.getElementById('resultadoBusquedaBloqueNuevo');
    const bloquesPendientesDiv = document.getElementById('bloquesPendientesNuevoModo');
    
    if (!folioRaw) {
        divResultado.innerHTML = `
            <div class="alert alert-warning">
                <i class="bi bi-exclamation-circle"></i> Por favor, ingrese un folio v√°lido.
            </div>`;
        return;
    }

    try {
        let llantasParaAgregar = [];
        
        console.log("=== DIAGN√ìSTICO DE AGREGACI√ìN ===");
        console.log("Folio ingresado (raw):", folioRaw);
        console.log("Folio normalizado:", folio);
        
        // Buscar en todas las fuentes y recolectar las llantas
        const traspasosRecientes = traspasosParaGuardar.filter(f => {
            const nombre = normalizeKey(f.Nombre || f.nombre || '');
            const fol = normalizeKey(f.Folio || f.folio || '');
            return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
        });
        if (traspasosRecientes.length > 0) {
            console.log("‚úì Encontrado en traspasos recientes:", traspasosRecientes);
            llantasParaAgregar = llantasParaAgregar.concat(traspasosRecientes);
        }

        try {
            const resEscaneados = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=FACTURAS');
            if (resEscaneados.ok) {
                const escaneados = filterMeaningfulRows(await resEscaneados.json());
                const escaneadosDelFolio = escaneados.filter(r => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                });
                if (escaneadosDelFolio.length > 0) {
                    console.log("‚úì Encontrado en FACTURAS:", escaneadosDelFolio);
                    llantasParaAgregar = llantasParaAgregar.concat(escaneadosDelFolio);
                }
            }
        } catch (e) {
            console.warn('Error buscando en FACTURAS:', e);
        }

        try {
            const resTrasp = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=traspasos');
            if (resTrasp.ok) {
                const traspasos = filterMeaningfulRows(await resTrasp.json());
                const traspasosDelFolio = traspasos.filter(r => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                });
                if (traspasosDelFolio.length > 0) {
                    console.log("‚úì Encontrado en traspasos (sheet):", traspasosDelFolio);
                    llantasParaAgregar = llantasParaAgregar.concat(traspasosDelFolio);
                }
            }
        } catch (e) {
            console.warn('Error buscando en traspasos (sheet):', e);
        }

        const bloquesFactura = bloquestraspasos.filter(b => {
            const nombreBloque = normalizeKey(b.nombre || '');
            return nombreBloque === folio || nombreBloque.includes(folio);
        });
        if (bloquesFactura.length > 0) {
            console.log("‚úì Encontrado en bloques de traspasos:", bloquesFactura);
            llantasParaAgregar = llantasParaAgregar.concat(bloquesFactura[0].datos || []);
        }

        if (llantasParaAgregar.length > 0) {
            console.log("‚úì Total de llantas encontradas para agregar:", llantasParaAgregar.length);
            
            // Procesar el bloque encontrado
            try {
                await procesarBloquetraspasos(llantasParaAgregar, folio);
            } catch (e) {
                console.error('Error al procesar bloque:', e);
                divResultado.innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle"></i> Error al procesar el bloque: ${e.message}
                    </div>`;
                return;
            }
            
            if (continuarAgregando) {
                // Agregar al √°rea de bloques pendientes
                const bloquePendiente = document.createElement('div');
                bloquePendiente.className = 'alert alert-info mt-2 d-flex justify-content-between align-items-center';
                bloquePendiente.innerHTML = `
                    <span>
                        <i class="bi bi-box"></i> 
                        Bloque "${folioRaw}" agregado (${llantasParaAgregar.length} llantas)
                    </span>
                `;
                bloquesPendientesDiv.appendChild(bloquePendiente);
                
                // Limpiar solo el input, mantener la tabla actualizada
                document.getElementById('inputBusquedaBloqueNuevo').value = '';
                divResultado.innerHTML = `
                    <div class="alert alert-success">
                        <i class="bi bi-plus-circle"></i>
                        Bloque agregado. Puede seguir a√±adiendo m√°s bloques.
                    </div>`;
            } else {
                // Finalizar la combinaci√≥n
                document.getElementById('inputBusquedaBloqueNuevo').value = '';
                bloquesPendientesDiv.innerHTML = '';
                divResultado.innerHTML = `
                    <div class="alert alert-success">
                        <i class="bi bi-check-circle"></i> 
                        Se agregaron ${llantasParaAgregar.length} llantas al bloque.
                    </div>`;
            }
            
            // Actualizar tablas
            renderPedidosActuales();
            actualizarGraficas();
        } else {
            console.log("‚ùå No se encontraron llantas para el folio:", folio);
            divResultado.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-x-circle"></i> No se encontraron llantas para agregar.
                </div>`;
        }

    } catch (error) {
        console.error('Error al agregar el bloque:', error);
        divResultado.innerHTML = `
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> Error al agregar el bloque: ${error.message}
            </div>`;
    }
}

function limpiarBusquedaBloqueEnModo() {
    if (!confirm('¬øEst√°s seguro de que quieres limpiar todos los datos de la b√∫squeda de bloques?')) return;
    clearEverything();
    // Re-apply b√∫squeda-bloque specific UI resets after a short delay
    setTimeout(() => {
        try { document.getElementById('inputBuscarLlantaCodigo').value = ''; } catch (e) { }
        try { document.getElementById('inputBuscarLlantaDescripcion').value = ''; } catch (e) { }
        try { document.getElementById('inputBuscarLlantaCantidad').value = '1'; } catch (e) { }
        try { document.getElementById('resultadoBusquedaLlanta').innerHTML = ''; } catch (e) { }
        try { const acr = document.getElementById('autocompleteCodigoResultados'); if (acr) { acr.innerHTML=''; acr.style.display='none'; } } catch (e) { }
        try { const adr = document.getElementById('autocompleteDescripcionResultados'); if (adr) { adr.innerHTML=''; adr.style.display='none'; } } catch (e) { }
        try { const tbl = document.getElementById('tablaLlantasSeleccionadas'); if (tbl && tbl.querySelector('tbody')) tbl.querySelector('tbody').innerHTML = ''; } catch (e) { }
        try { const tbl = document.getElementById('tablaUnidadesSugeridasBusqueda'); if (tbl && tbl.querySelector('tbody')) tbl.querySelector('tbody').innerHTML = ''; } catch (e) { }
        try { const total = document.getElementById('totalLlantas'); if (total) { total.innerHTML=''; total.style.display='none'; } } catch (e) { }
        try { const res = document.getElementById('resultadosBusqueda'); if (res) res.innerHTML = ''; } catch (e) { }
        try { const cont = document.getElementById('contadorTotalLlantasBloque'); if (cont) cont.textContent = '0'; } catch (e) { }
        try { const bp = document.getElementById('bloquesPendientesNuevo'); if (bp) bp.innerHTML = ''; } catch (e) { }
        try { const col = document.getElementById('collapseDistribucionMultiple'); if (col) col.classList.remove('show'); } catch (e) { }
    }, 50);
    console.log('‚úÖ [B√öSQUEDA BLOQUES] Limpieza completada y delegado a clearEverything');
}

// --- B√∫squeda r√°pida de llanta en la pesta√±a de b√∫squeda de bloque ---
// Inserta una barra (c√≥digo/descr + cantidad) y permite agregar la llanta encontrada al bloque
function setupBusquedaLlantaEnPedidos() {
    try {
        // Intentar colocar el control cerca de la tabla de llantas seleccionadas
        const tabla = document.getElementById('tablaLlantasSeleccionadas');
        const contDestino = tabla ? tabla.parentElement : document.getElementById('seccionUnidadSugeridaBusqueda') || document.getElementById('bloquesPendientesNuevo');
        if (!contDestino) return;

        // Evitar insertar m√°s de una vez
        if (document.getElementById('busquedaLlantaRapid')) return;

        const wrapper = document.createElement('div');
        wrapper.id = 'busquedaLlantaRapid';
        wrapper.className = 'mb-3 d-flex align-items-center gap-2';
        wrapper.innerHTML = `
            <div style="position:relative;width:180px">
                <input type="text" id="inputBuscarLlantaCodigo" class="form-control" placeholder="C√≥digo de la llanta" autocomplete="off">
                <div id="autocompleteCodigoResultados" class="autocomplete-list" style="position:absolute;top:100%;left:0;right:0;z-index:1001;"></div>
            </div>
            <div style="position:relative;width:320px">
                <input type="text" id="inputBuscarLlantaDescripcion" class="form-control" placeholder="Descripci√≥n de la llanta" autocomplete="off">
                <div id="autocompleteDescripcionResultados" class="autocomplete-list" style="position:absolute;top:100%;left:0;right:0;z-index:1001;"></div>
            </div>
            <input type="number" id="inputBuscarLlantaCantidad" class="form-control" placeholder="Cantidad" min="1" value="1" style="width:110px">
            <button id="btnAgregarLlantaBloque" class="btn btn-success">Agregar al bloque</button>
            <div id="resultadoBusquedaLlanta" style="min-width:120px;margin-left:8px"></div>
        `;
        // --- AUTOCOMPLETADO DE C√ìDIGO Y DESCRIPCI√ìN ---
        const inputCodigo = wrapper.querySelector('#inputBuscarLlantaCodigo');
        const inputDescripcion = wrapper.querySelector('#inputBuscarLlantaDescripcion');
        const autocompleteCodigo = wrapper.querySelector('#autocompleteCodigoResultados');
        const autocompleteDescripcion = wrapper.querySelector('#autocompleteDescripcionResultados');

        // Autocompletar c√≥digo
        inputCodigo.addEventListener('input', function() {
            const term = inputCodigo.value.trim().toLowerCase();
            autocompleteCodigo.innerHTML = '';
            if (!term || !Array.isArray(INVENTARIO)) {
                autocompleteCodigo.style.display = 'none';
                return;
            }
            const matches = INVENTARIO.filter(item => {
                const codigo = (item.clave || item.C√≥digo || item.Codigo || item.codigo || '').toString().toLowerCase();
                return codigo.includes(term);
            }).slice(0, 10);
            if (matches.length === 0) {
                autocompleteCodigo.style.display = 'none';
                return;
            }
            matches.forEach(item => {
                const codigo = item.clave || item.C√≥digo || item.Codigo || item.codigo || '';
                const desc = item.descripcion || item.Descripci√≥n || item.Descripcion || '';
                const option = document.createElement('div');
                option.className = 'autocomplete-item';
                option.style.padding = '8px';
                option.style.cursor = 'pointer';
                option.style.borderBottom = '1px solid #eee';
                option.textContent = `${codigo}`;
                option.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    inputCodigo.value = codigo;
                    inputDescripcion.value = desc;
                    autocompleteCodigo.innerHTML = '';
                    autocompleteCodigo.style.display = 'none';
                    autocompleteDescripcion.innerHTML = '';
                    autocompleteDescripcion.style.display = 'none';
                });
                autocompleteCodigo.appendChild(option);
            });
            autocompleteCodigo.style.display = 'block';
        });
        inputCodigo.addEventListener('blur', function() {
            setTimeout(() => { autocompleteCodigo.innerHTML = ''; autocompleteCodigo.style.display = 'none'; }, 150);
        });

        // Autocompletar descripci√≥n
        inputDescripcion.addEventListener('input', function() {
            const term = inputDescripcion.value.trim().toLowerCase();
            autocompleteDescripcion.innerHTML = '';
            if (!term || !Array.isArray(INVENTARIO)) {
                autocompleteDescripcion.style.display = 'none';
                return;
            }
            const matches = INVENTARIO.filter(item => {
                const desc = (item.descripcion || item.Descripci√≥n || item.Descripcion || '').toString().toLowerCase();
                return desc.includes(term);
            }).slice(0, 10);
            if (matches.length === 0) {
                autocompleteDescripcion.style.display = 'none';
                return;
            }
            matches.forEach(item => {
                const codigo = item.clave || item.C√≥digo || item.Codigo || item.codigo || '';
                const desc = item.descripcion || item.Descripci√≥n || item.Descripcion || '';
                const option = document.createElement('div');
                option.className = 'autocomplete-item';
                option.style.padding = '8px';
                option.style.cursor = 'pointer';
                option.style.borderBottom = '1px solid #eee';
                option.textContent = `${desc}`;
                option.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    inputCodigo.value = codigo;
                    inputDescripcion.value = desc;
                    autocompleteDescripcion.innerHTML = '';
                    autocompleteDescripcion.style.display = 'none';
                    autocompleteCodigo.innerHTML = '';
                    autocompleteCodigo.style.display = 'none';
                });
                autocompleteDescripcion.appendChild(option);
            });
            autocompleteDescripcion.style.display = 'block';
        });
        inputDescripcion.addEventListener('blur', function() {
            setTimeout(() => { autocompleteDescripcion.innerHTML = ''; autocompleteDescripcion.style.display = 'none'; }, 150);
        });

        // --- ESTILO AUTOCOMPLETADO ---
        if (!document.getElementById('autocompleteLlantaStyle')) {
            const style = document.createElement('style');
            style.id = 'autocompleteLlantaStyle';
            style.textContent = `
                .autocomplete-list { background: #fff; border: 1px solid #ccc; max-height: 220px; overflow-y: auto; border-radius: 0 0 6px 6px; box-shadow: 0 2px 8px #0001; }
                .autocomplete-item:hover { background: #e6f7e6; }
            `;
            document.head.appendChild(style);
        }

        if (tabla && tabla.parentElement) {
            tabla.parentElement.insertBefore(wrapper, tabla);
        } else {
            contDestino.insertBefore(wrapper, contDestino.firstChild);
        }

        document.getElementById('btnAgregarLlantaBloque').addEventListener('click', async () => {
            const codigo = inputCodigo.value.trim();
            const descripcion = inputDescripcion.value.trim();
            let qty = parseInt(document.getElementById('inputBuscarLlantaCantidad').value, 10) || 1;
            const output = document.getElementById('resultadoBusquedaLlanta');
            output.innerHTML = '';
            if (!codigo && !descripcion) { output.innerHTML = '<span class="text-warning">Ingresa c√≥digo o descripci√≥n</span>'; return; }

            try {
                // Buscar en el INVENTARIO local (array `INVENTARIO` asumido existente)
                const matches = (Array.isArray(INVENTARIO) ? INVENTARIO : []).filter(item => {
                    const cod = (item.clave || item.C√≥digo || item.Codigo || item.codigo || '').toString().trim();
                    const desc = (item.descripcion || item.Descripci√≥n || item.Descripcion || '').toString().trim();
                    return (codigo && cod === codigo) || (descripcion && desc === descripcion);
                });

                if (matches.length === 0) {
                    output.innerHTML = '<span class="text-danger">No se encontr√≥</span>';
                    return;
                }

                // Si hay varias coincidencias, mostrar un select para elegir
                if (matches.length > 1) {
                    output.innerHTML = '';
                    const sel = document.createElement('select');
                    sel.className = 'form-select form-select-sm';
                    sel.style.maxWidth = '420px';
                    matches.slice(0, 10).forEach((m, idx) => {
                        const opt = document.createElement('option');
                        const code = m.clave || m.C√≥digo || m.Codigo || m.codigo || '';
                        const d = m.descripcion || m.Descripci√≥n || m.Descripcion || '';
                        opt.value = idx;
                        opt.text = `${code} ‚Äî ${d}`;
                        sel.appendChild(opt);
                    });
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-primary btn-sm';
                    btn.style.marginLeft = '6px';
                    btn.textContent = 'Seleccionar y agregar';
                    output.appendChild(sel);
                    output.appendChild(btn);
                    btn.addEventListener('click', () => {
                        const chosen = matches[parseInt(sel.value, 10) || 0];
                        agregarLlantaElegidaABloque(chosen, qty);
                        output.innerHTML = '<span class="text-success">Agregado</span>';
                    });
                    return;
                }

                // Coincidencia √∫nica
                agregarLlantaElegidaABloque(matches[0], qty);
                output.innerHTML = '<span class="text-success">Agregado</span>';

            } catch (err) {
                console.error('Error en b√∫squeda r√°pida de llanta:', err);
                output.innerHTML = '<span class="text-danger">Error</span>';
            }
        });

    } catch (e) {
        console.warn('setupBusquedaLlantaEnPedidos fall√≥:', e);
    }
}

function agregarLlantaElegidaABloque(item, cantidad) {
    try {
        if (!item) return;
        const codigo = item.clave || item.C√≥digo || item.Codigo || item.codigo || '';
        const descripcion = item.descripcion || item.Descripci√≥n || item.Descripcion || '';
        const peso = parseFloat(item.peso || item.Peso || item['Peso unitario']) || 0;
        const volumen = parseFloat(item.volumen || item.Volumen || item['Volumen unitario']) || 0;
        const valor = item.precio || item.valor || item['Valor unitario'] || 0;

        // Buscar si ya existe en llantasAcumuladasEnBloque (mismo c√≥digo y descripci√≥n)
        let existente = (llantasAcumuladasEnBloque || []).find(l => String(l.C√≥digo || l.clave || '').trim() === String(codigo).trim() && String(l.Descripci√≥n || l.descripcion || '').trim() === String(descripcion).trim());
        if (existente) {
            existente.Cantidad = (parseInt(existente.Cantidad, 10) || 0) + cantidad;
        } else {
            const nuevo = {
                C√≥digo: codigo,
                Descripci√≥n: descripcion,
                Cantidad: cantidad,
                'Peso unitario': peso,
                'Volumen unitario': volumen,
                'Valor unitario': valor
            };
            llantasAcumuladasEnBloque = llantasAcumuladasEnBloque || [];
            llantasAcumuladasEnBloque.push(nuevo);
        }

        // Actualizar la tabla visible usando la funci√≥n existente
        if (typeof actualizarTablaLlantasBloque === 'function') {
            actualizarTablaLlantasBloque(llantasAcumuladasEnBloque);
        } else {
            console.warn('actualizarTablaLlantasBloque no encontrada, tabla no actualizada');
        }
    } catch (e) {
        console.error('Error agregando llanta al bloque:', e);
    }
}

// Inicializar cuando el DOM est√© listo (si ya se invoca en otro lado no importa)
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupBusquedaLlantaEnPedidos);
} else {
    setupBusquedaLlantaEnPedidos();
}


function eliminarLlantaBloque(codigo) {
    // Confirmar antes de eliminar
    if (confirm('¬øEst√° seguro de eliminar esta llanta del bloque?')) {
        const tablaLlantas = document.getElementById('tablaLlantasBloque');
        const filas = tablaLlantas.getElementsByTagName('tr');
        
        // Crear un nuevo array sin la llanta eliminada
        const llantasActualizadas = [];
        for (let fila of filas) {
            const codigoFila = fila.cells[0].textContent;
            if (codigoFila !== codigo) {
                llantasActualizadas.push({
                    ID: codigoFila,
                    Descripcion: fila.cells[1].textContent,
                    Linea: fila.cells[2].textContent,
                    Cantidad: parseInt(fila.cells[3].textContent),
                    Volumen: parseFloat(fila.cells[4].textContent),
                    Peso: parseFloat(fila.cells[5].textContent),
                    Valor: parseFloat(fila.cells[6].textContent.replace('$', ''))
                });
            }
        }
        
        // Actualizar la tabla
        actualizarTablaLlantasBloque(llantasActualizadas);
    }
}

async function actualizarTablaLlantasBloque(llantas) {
    const tablaLlantas = document.getElementById('tablaLlantasBloque');
    
    if (!tablaLlantas) {
        console.error('No se encontr√≥ la tabla de llantas');
        return;
    }

    // Actualizar la tabla de unidades disponibles despu√©s de actualizar el bloque
    setTimeout(async () => {
        await actualizarUnidadesDisponibles();
        
        // Calcular y mostrar la distribuci√≥n m√∫ltiple
        try {
            const distribucion = await calcularDistribucionMultiple(llantas);
                if (distribucion && distribucion.length > 0) {
                    actualizarTablaDistribucion(distribucion);
                    // NOTA: No forzamos la apertura del acorde√≥n aqu√≠.
                    // La visibilidad la decide `actualizarTablaDistribucion` seg√∫n la l√≥gica de capacidades.
                }
        } catch (error) {
            console.error('Error al calcular distribuci√≥n m√∫ltiple:', error);
        }
    }, 100); // Peque√±o retraso para asegurar que los totales est√©n actualizados

    // Limpiar la tabla actual
    tablaLlantas.innerHTML = '';

    // Variables para totales
    let totalCantidad = 0;
    let totalVolumen = 0;
    let totalPeso = 0;
    let totalValor = 0;

    // Agrupar llantas por c√≥digo. No depender exclusivamente del INVENTARIO: usar datos del objeto llanta o calcular valores si faltan.
    const llantasAgrupadas = {};
    for (const llanta of llantas) {
        const codigo = (llanta.C√≥digo || llanta.codigo || llanta.clave || '').toString() || 'Sin c√≥digo';
        const descripcion = llanta.Descripci√≥n || llanta.descripcion || llanta.Descripcion || 'Sin descripci√≥n';
        const cantidad = parseInt(llanta.Cantidad || llanta.cantidad || llanta.Cantidad || 1, 10) || 1;

        // Buscar en INVENTARIO si existe
        const llantaINVENTARIO = INVENTARIO.find(item => item.ID === codigo || item.clave === codigo || item.C√≥digo === codigo);
        if (!llantaINVENTARIO) {
            console.warn(`No se encontr√≥ la llanta con c√≥digo ${codigo} en el INVENTARIO; se usar√°n valores aportados o calculados.`);
        }

        // Intentar leer volumen/peso/valor desde la entrada del bloque (prioridad) -> luego INVENTARIO -> valores calculados
        let volumenUnitario = parseNumber(llanta['Volumen unitario'] || llanta['Volumen'] || llanta.Volumen || llanta.volumen || (llantaINVENTARIO && (llantaINVENTARIO.Volumen || llantaINVENTARIO.volumen)) || 0);
        let pesoUnitario = parseNumber(llanta['Peso unitario'] || llanta['Peso'] || llanta.Peso || llanta.peso || (llantaINVENTARIO && (llantaINVENTARIO.Peso || llantaINVENTARIO.peso)) || 0);
        let valorUnitario = parseNumber(llanta['Valor unitario'] || llanta['Valor'] || llanta.Valor || llanta.valor || (llantaINVENTARIO && (llantaINVENTARIO.Valor || llantaINVENTARIO.valor)) || 0);

        // Si faltan, intentar calcular heur√≠sticamente (no abortar)
        try {
            if ((!volumenUnitario || volumenUnitario === 0) && typeof calcularVolumenLlanta === 'function') {
                const v = await calcularVolumenLlanta(descripcion || '');
                volumenUnitario = (v && !isNaN(v)) ? Number(v) : volumenUnitario;
            }
        } catch (e) {
            console.warn('Error calculando volumen para', codigo, e);
        }
        try {
            if ((!pesoUnitario || pesoUnitario === 0) && typeof calcularPesoLlanta === 'function') {
                const p = await calcularPesoLlanta(descripcion || '');
                pesoUnitario = (p && !isNaN(p)) ? Number(p) : pesoUnitario;
            }
        } catch (e) {
            console.warn('Error calculando peso para', codigo, e);
        }

        // No abortar si siguen siendo cero; incluir la fila con ceros en totales parciales
        const volumen = (isNaN(volumenUnitario) ? 0 : volumenUnitario) * cantidad;
        const peso = (isNaN(pesoUnitario) ? 0 : pesoUnitario) * cantidad;
        const valor = (isNaN(valorUnitario) ? 0 : valorUnitario) * cantidad;

        if (!llantasAgrupadas[codigo]) {
            llantasAgrupadas[codigo] = {
                codigo: codigo,
                descripcion: descripcion,
                linea: (llantaINVENTARIO && (llantaINVENTARIO.Linea || llantaINVENTARIO.linea)) || llanta.Linea || llanta.linea || '',
                cantidad: 0,
                volTotal: 0,
                pesoTotal: 0,
                valorTotal: 0
            };
        }

        llantasAgrupadas[codigo].cantidad += cantidad;
        llantasAgrupadas[codigo].volTotal += volumen;
        llantasAgrupadas[codigo].pesoTotal += peso;
        llantasAgrupadas[codigo].valorTotal += valor;

        totalCantidad += cantidad;
        totalVolumen += volumen;
        totalPeso += peso;
        totalValor += valor;
    }

    // Agregar filas a la tabla
    Object.values(llantasAgrupadas).forEach(datos => {
        const fila = document.createElement('tr');
        fila.innerHTML = `
            <td>${datos.codigo}</td>
            <td>${datos.descripcion}</td>
            <td>${datos.linea}</td>
            <td style="text-align: center;">${datos.cantidad}</td>
            <td style="text-align: right;">${formatNumber(datos.volTotal, 3)}</td>
            <td style="text-align: right;">${formatNumber(datos.pesoTotal, 3)}</td>
            <td style="text-align: right;">$${formatNumber(datos.valorTotal, 2)}</td>
            <td class="text-center">
                <button class="btn btn-sm btn-danger" onclick="eliminarLlantaBloque('${datos.codigo}')">
                    <i class="bi bi-trash"></i>
                </button>
            </td>
        `;
        tablaLlantas.appendChild(fila);
    });

    // Actualizar totales en el pie de la tabla (guardar valor num√©rico en dataset.value y mostrar formateado)
    const elTotalCantidad = document.getElementById('totalCantidadLlantas');
    const elTotalVolumen = document.getElementById('totalVolumenLlantas');
    const elTotalPeso = document.getElementById('totalPesoLlantas');
    const elTotalValor = document.getElementById('totalValorLlantas');
    if (elTotalCantidad) { elTotalCantidad.textContent = totalCantidad; elTotalCantidad.dataset.value = totalCantidad; }
    if (elTotalVolumen) { elTotalVolumen.textContent = formatNumber(totalVolumen, 3); elTotalVolumen.dataset.value = totalVolumen; }
    if (elTotalPeso) { elTotalPeso.textContent = formatNumber(totalPeso, 3); elTotalPeso.dataset.value = totalPeso; }
    if (elTotalValor) { elTotalValor.textContent = `$${formatNumber(totalValor, 2)}`; elTotalValor.dataset.value = totalValor; }
    
    // Actualizar el contador en el encabezado del acorde√≥n
    document.getElementById('contadorLlantasBloque').textContent = 
        Object.keys(llantasAgrupadas).length > 0 ? `${Object.keys(llantasAgrupadas).length} tipos` : '0';
}


// Funciones auxiliares para procesar cada tipo de bloque
async function procesarBloquetraspasos(datos, blockId = null) {
    console.log('üîµ [PROCESAMIENTO DE BLOQUE] Iniciando procesamiento...');
    console.log('   Productos totales en datos:', datos.length);
    console.log('   Datos:', datos);
    
    // Crear una huella √∫nica para el bloque: preferir el blockId (folio) si est√° disponible.
    let fingerprint;
    try {
        if (blockId) {
            fingerprint = `F:${String(blockId)}`;
        } else {
            // Agregar por c√≥digo y cantidad para generar un fingerprint estable y ordenado
            const agg = {};
            (datos || []).forEach(p => {
                const code = String(p['C√≥digo'] || p.Codigo || p.codigo || '').trim();
                const qty = Number(p['Cantidad'] || p.Cantidad || p.cantidad || 0) || 0;
                if (!code) return;
                agg[code] = (agg[code] || 0) + qty;
            });
            const entries = Object.keys(agg).sort().map(k => `${k}:${agg[k]}`);
            fingerprint = `H:${entries.join('|')}`;
        }
    } catch (e) {
        console.warn('Error calculando fingerprint del bloque:', e);
        fingerprint = `H:UNKNOWN_${Date.now()}`;
    }

    // Si ya procesamos este bloque, omitimos para evitar duplicados
    if (bloquesPedidosAgregados.has(fingerprint)) {
        console.log(`Omitido: Bloque ya agregado (fingerprint=${fingerprint})`);
        // Mensaje al usuario si hay un elemento de resultado visible
        try {
            const divResultado = document.getElementById('bloqueBuscadoPedido');
            if (divResultado) divResultado.innerHTML = `<div class="alert alert-warning mt-2">Este bloque ya fue agregado al pedido anteriormente.</div>`;
            mostrarMensaje && mostrarMensaje('Este bloque ya fue agregado al pedido.', 'warning');
        } catch (e) { /* ignore */ }
        return; // No procesar de nuevo
    }

    let seAgregaron = false;
    const nuevosParaINVENTARIO = [];
    let productosEnINVENTARIO = 0;
    let productosEnPedidosActuales = 0;
    let productosNuevos = 0;
    let productosConActualizacionCantidad = 0;

    for (let idx = 0; idx < datos.length; idx++) {
        const producto = datos[idx];
        const codigoProd = producto.C√≥digo?.toString?.() || producto.codigo?.toString?.() || '';
        const descripcionProd = sanitizeFacturaDesc((producto.Descripci√≥n || producto.Descripcion || producto.descripcion || '').toString());
        const cantidad = Number(producto.Cantidad) || 1;

        console.log(`   [${idx + 1}/${datos.length}] Procesando: c√≥digo="${codigoProd}", desc="${descripcionProd}", cantidad=${cantidad}`);

        const llanta = INVENTARIO.find(item => item.clave?.toString() === codigoProd);
        if (llanta) {
            productosEnINVENTARIO++;
            console.log(`      ‚úì Encontrado en INVENTARIO. Clave: ${llanta.clave}`);
            
            let pedidoExistente = pedidosEnCurso.find(p => p.clave === llanta.clave);
            if (pedidoExistente) {
                // Actualizar cantidad existente
                const cantidadAnterior = pedidoExistente.cantidad;
                pedidoExistente.cantidad += cantidad;
                pedidoExistente.peso = safeNum(getField(llanta,'peso')) * pedidoExistente.cantidad;
                pedidoExistente.volumen = safeNum(getField(llanta,'volumen')) * pedidoExistente.cantidad;
                pedidoExistente.valor = safeNum(getField(llanta,'valor')) * pedidoExistente.cantidad;
                productosConActualizacionCantidad++;
                console.log(`      ‚ÜóÔ∏è Actualizado cantidad en pedido: ${cantidadAnterior} ‚Üí ${pedidoExistente.cantidad}`);
            } else {
                // Agregar nueva llanta al pedido (asegurar peso/volumen por unidad antes de multiplicar)
                productosEnPedidosActuales++;
                let unidad = {
                    descripcion: llanta.descripcion,
                    volumen: Number(safeNum(getField(llanta,'volumen'))) || 0,
                    peso: Number(safeNum(getField(llanta,'peso'))) || 0
                };
                unidad = await ensurePesoVolumen(unidad);
                pedidosEnCurso.push({
                    clave: llanta.clave,
                    descripcion: llanta.descripcion,
                    linea: llanta.linea || '',
                    cantidad: cantidad,
                    peso: unidad.peso * cantidad,
                    volumen: unidad.volumen * cantidad,
                    valor: safeNum(getField(llanta,'valor')) * cantidad
                });
                console.log(`      ‚ú® Agregado nuevo al pedido actual (con c√°lculo de unidad asegurado)`);
            }
        } else {
            // Si la llanta no existe en INVENTARIO, agregar una entrada temporal al pedido
            console.log(`      ‚ö†Ô∏è NO encontrado en INVENTARIO. Calculando volumen/peso...`);
            let volumenCalc = Number(await calcularVolumenLlanta(descripcionProd)) || 0;
            let pesoCalc = Number(await calcularPesoLlanta(descripcionProd)) || 0;
            
            // Si las calculadoras devolvieron 0, usar valores por defecto
            if (!volumenCalc || volumenCalc === 0) volumenCalc = 0.030; // 30 litros por defecto
            if (!pesoCalc || pesoCalc === 0) pesoCalc = 10; // 10 kg por defecto
            
            console.log(`      Valores calculados/default: volumen=${volumenCalc}m¬≥, peso=${pesoCalc}kg`);

            productosNuevos++;
            // Crear unidad temporal y asegurarse de que tenga peso/volumen por unidad
            let unidadTemp = {
                descripcion: descripcionProd,
                volumen: volumenCalc,
                peso: pesoCalc
            };
            unidadTemp = await ensurePesoVolumen(unidadTemp);
            pedidosEnCurso.push({
                clave: codigoProd || '',
                descripcion: descripcionProd,
                linea: determinarTipoLlanta(descripcionProd),
                cantidad: cantidad,
                peso: unidadTemp.peso * cantidad,
                volumen: unidadTemp.volumen * cantidad,
                valor: 0
            });
            console.log(`      ‚ú® Agregado temporal al pedido (sin INVENTARIO) con Vol=${unidadTemp.volumen * cantidad}m¬≥, Peso=${unidadTemp.peso * cantidad}kg`);

            // Preparar para agregar al INVENTARIO (si tiene c√≥digo y descripci√≥n)
            if (codigoProd && descripcionProd) {
                nuevosParaINVENTARIO.push({
                    C√≥digo: codigoProd,
                    Descripci√≥n: descripcionProd,
                    Cantidad: cantidad,
                    volumen: unidadTemp.volumen,
                    peso: unidadTemp.peso
                });
            }
        }
    }

    console.log('üîµ [RESUMEN DE PROCESAMIENTO]');
    console.log(`   Total procesados: ${datos.length}`);
    console.log(`   - En INVENTARIO: ${productosEnINVENTARIO}`);
    console.log(`   - Nuevos al pedido: ${productosEnPedidosActuales}`);
    console.log(`   - Cantidad actualizada: ${productosConActualizacionCantidad}`);
    console.log(`   - Sin INVENTARIO (temp): ${productosNuevos}`);
    console.log(`   Productos agregados al pedido en curso: ${pedidosEnCurso.length} items`);
    console.log('   Pedidos en curso:', pedidosEnCurso);

    // Intentar agregar los nuevos productos al INVENTARIO (evita duplicados internamente)
    if (nuevosParaINVENTARIO.length > 0) {
        console.log(`üîµ Intentando agregar ${nuevosParaINVENTARIO.length} nuevos productos al INVENTARIO...`);
        try {
            await agregarNuevosProductosAlINVENTARIO(nuevosParaINVENTARIO);
            console.log('‚úÖ Productos nuevos agregados al INVENTARIO exitosamente');
        } catch (e) {
            console.warn('‚ùå No se pudieron agregar autom√°ticamente los nuevos productos al INVENTARIO:', e);
        }
    }

    // Registrar fingerprint para evitar re-agregados futuros
    try { if (fingerprint && !bloquesPedidosAgregados.has(fingerprint)) bloquesPedidosAgregados.add(fingerprint); } catch(e){console.warn('No se pudo registrar fingerprint:', e);} 

    renderPedidosActuales();
    actualizarGraficas();
}

    // Modal Management Functions
    const modalManager = {
        open: function(id) {
            document.getElementById(id).style.display = 'block';
        },
        close: function(id) {
            document.getElementById(id).style.display = 'none';
        },
        cleanup: function() {
            // Remove backdrops
            document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
            
            // Reset body styles
            document.body.classList.remove('modal-open');
            document.body.style.removeProperty('overflow');
            document.body.style.removeProperty('padding-right');
            
            // Close active modals
            document.querySelectorAll('.modal.show').forEach(modal => {
                const bootstrapModal = bootstrap.Modal.getInstance(modal);
                if (bootstrapModal) bootstrapModal.hide();
                modal.remove();
            });
        }
    };

    // Modal event handlers
    const openModal = modalManager.open;
    const closeModal = modalManager.close;
    const limpiarModales = modalManager.cleanup;

    // Click outside modal handler
    window.addEventListener('click', (event) => {
        ['modalINVENTARIO', 'modalFlota'].forEach(id => {
            const modal = document.getElementById(id);
            if (event.target === modal) modal.style.display = 'none';
        });
    });

    // ---------- Funciones para cargar datos ---------
    async function fetchINVENTARIO() {
        try {
            const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey');
            if (!res.ok) {
                console.warn('fetchINVENTARIO: respuesta no OK', res.status);
                return; // no sobrescribir INVENTARIO si falla
            }
            const data = filterMeaningfulRows(await res.json());
            if (!Array.isArray(data) || data.length === 0) {
                console.warn('fetchINVENTARIO: datos vac√≠os o filtrados, manteniendo INVENTARIO existente');
                return;
            }
            INVENTARIO = data;
            console.log(`fetchINVENTARIO: cargado INVENTARIO (${INVENTARIO.length} √≠tems)`);
            renderINVENTARIO();
            // Cargar las descripciones en el select despu√©s de actualizar el INVENTARIO
            cargarDescripcionesLlantas();
        } catch (e) {
            console.warn('No se pudo cargar el INVENTARIO:', e);
        }
    }
    async function fetchFlota() {
        try {
            const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=flota');
            if (!res.ok) throw new Error('Error al cargar flota');
            flota = filterMeaningfulRows(await res.json());
            renderFlota();
        } catch (e) {
            alert('No se pudo cargar la flota: ' + e.message);
        }
    }
    fetchINVENTARIO();
    fetchFlota();

    // Funci√≥n para cargar pedidos Apartados desde hoja
    async function fetchPedidosApartados() {
        try {
            // A√±adir par√°metro timestamp para evitar respuestas cacheadas
            const url = `https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=Apartados&t=${Date.now()}`;
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Error al cargar pedidos Apartados: ${response.status}`);
            }
            const data = filterMeaningfulRows(await response.json());
            console.log('Datos recibidos de SheetDB:', data);
            
            // Normalizar los datos manteniendo la estructura original
            pedidosApartados = data.map(pedido => ({
                ...pedido,
                'Econ√≥mico': pedido['Econ√≥mico'] || pedido['Economico'] || pedido['economico'] || '', // Mantener la versi√≥n con tilde
                'Unidad': pedido['Unidad'] || pedido['unidad'] || '', // No forzar KENWORTH cuando no hay dato
                'Fecha': pedido['Fecha'] || '',
                'Nombre': pedido['Nombre'] || '',
                'Llantas': pedido['Llantas'] || '',
                'Descripcion': pedido['Descripcion'] || '',
                'Volumen': pedido['Volumen'] || '',
                'Peso': pedido['Peso'] || ''
            }));
            console.log('Datos normalizados:', pedidosApartados);
            actualizarTablaPedidosApartados();
        } catch (e) {
            alert('No se pudieron cargar los pedidos Apartados: ' + e.message);
        }
    }
    async function cargarReservas() {
    try {
        const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=reservados');
        if (!res.ok) throw new Error('Error al cargar reservas');
        const reservas = filterMeaningfulRows(await res.json());
        return reservas;
    } catch (error) {
        console.error('Error al cargar reservas:', error);
        return [];
    }
}

    // ----- Cambiar pesta√±as -----
    const tablinks = document.querySelectorAll('.tablink');
    const tabcontents = document.querySelectorAll('.tabcontent');
    tablinks.forEach(button => {
        button.addEventListener('click', () => {
            const requested = String(button.dataset.tab || '').toLowerCase();
            console.log(`Pesta√±a solicitada: ${requested} | INVENTARIO items: ${Array.isArray(INVENTARIO) ? INVENTARIO.length : 'n/a'}`);
            tablinks.forEach(btn => btn.classList.remove('active'));
            tabcontents.forEach(tc => tc.classList.remove('active'));
            button.classList.add('active');
            // Resolve tab content id case-insensitively: try exact id, then uppercased
            const rawId = button.dataset.tab || '';
            let tabContent = document.getElementById(rawId);
            if (!tabContent) tabContent = document.getElementById(String(rawId).toUpperCase());
            if (tabContent) tabContent.classList.add('active');
            // Solo recargar si es necesario, usando llave normalizada
            if (requested === 'inventario') renderINVENTARIO();
            if (requested === 'flota') renderFlota();
            if (requested === 'pedidos') {
                // Refrescar pendientes al entrar a la pesta√±a para asegurar sincron√≠a con la hoja
                try { resetPedidoInputs(); cargarReservasDePendientes(); } catch(e) { console.warn('Error refrescando pendientes al abrir pesta√±a pedidos:', e); }
            }
            if (requested === 'calculo-rapido') renderCalculoRapido();
            if (requested === 'pedidos-apartados' || requested === 'pedidos-apartados') fetchPedidosApartados();

            // Ocultar las "burbujas" cuando se entra a la pesta√±a de traspasos,
            // ya que no son necesarias ah√≠
            try {
                const top = document.getElementById('burbujasTop');
                if (top) top.style.display = (requested === 'traspasos' ? 'none' : (Object.keys(window.burbujas || {}).length ? 'flex' : 'none'));
            } catch (e) { console.warn(e); }

            // Mostrar u ocultar panel flotante de Unidades pendientes: solo visible en la pesta√±a "calculo-rapido"
            try {
                const panel = document.getElementById('panelUnidadesPendientes');
                if (panel) panel.style.display = (requested === 'calculo-rapido' ? '' : 'none');
            } catch(e) { console.warn('Error ajustando visibilidad de panelUnidadesPendientes:', e); }
        });
    });
    // (Se elimin√≥ la definici√≥n duplicada de agregarBloquePorFolioPedido)
        // ...existing code...

    // Establecer visibilidad inicial del panel de Unidades Pendientes seg√∫n la pesta√±a activa al cargar
    try {
        const currentActive = document.querySelector('.tablink.active')?.dataset.tab || '';
        const panelInit = document.getElementById('panelUnidadesPendientes');
        if (panelInit) panelInit.style.display = (String(currentActive).toLowerCase() === 'calculo-rapido' ? '' : 'none');
    } catch(e) { console.warn('Error al ajustar visibilidad inicial del panel de pendientes:', e); }
        // Ajustar el bot√≥n Limpiar para solo limpiar los campos
        const btnLimpiar = document.querySelector('#modoBusqueda button[onclick*="limpiarBusquedaBloqueEnModo"]');
        if (btnLimpiar) {
            btnLimpiar.addEventListener('click', function() {
                const inputCodigo = document.getElementById('inputBuscarLlantaCodigo');
                const inputDescripcion = document.getElementById('inputBuscarLlantaDescripcion');
                const inputCantidad = document.getElementById('inputBuscarLlantaCantidad');
                if (inputCodigo) inputCodigo.value = '';
                if (inputDescripcion) inputDescripcion.value = '';
                if (inputCantidad) inputCantidad.value = '1';
                const resultado = document.getElementById('resultadoBusquedaLlanta');
                if (resultado) resultado.innerHTML = '';
            });
        }
function renderINVENTARIO() {
    const tbody = document.querySelector('#tablaINVENTARIO tbody');
    if (!tbody) {
        console.warn('‚ö†Ô∏è [INVENTARIO] No se encontr√≥ el elemento tbody de la tabla');
        return;
    }
    console.log(`renderINVENTARIO() llamado. INVENTARIO length = ${Array.isArray(INVENTARIO) ? INVENTARIO.length : 'n/a'}`);
    
    if (!INVENTARIO || INVENTARIO.length === 0) {
        console.warn('‚ö†Ô∏è [INVENTARIO] Array INVENTARIO vac√≠o, no hay datos para mostrar');
        tbody.innerHTML = ''; // asegurar tabla vac√≠a si no hay datos
        return;
    }
    
    tbody.innerHTML = '';
    INVENTARIO.forEach(llanta => {
        const tr = document.createElement('tr');
        // Si volumenGrande est√° marcado o volumen > 2, fondo azul claro
        if (llanta.volumenGrande || (safeNum(llanta.volumen) > 2)) {
            tr.style.background = '#cce6ff';
        }
        const pesoMostrar = (() => {
            const v = getField(llanta, 'peso');
            const n = safeNum(v);
            return (v === undefined || v === null || String(v).trim() === '') ? '-' : n.toFixed(3);
        })();
        const volumenMostrar = (() => {
            const v = getField(llanta, 'volumen');
            const n = safeNum(v);
            return (v === undefined || v === null || String(v).trim() === '') ? '-' : n.toFixed(3);
        })();
        const valorMostrar = (() => {
            const v = getField(llanta, 'valor');
            const n = safeNum(v);
            return (v === undefined || v === null || String(v).trim() === '') ? '-' : '$' + n.toFixed(2);
        })();

        tr.innerHTML = `
            <td>${llanta.clave}</td>
            <td>${llanta.descripcion}</td>
            <td>${llanta.linea || ''}</td>
            <td>${pesoMostrar}</td>
            <td>${volumenMostrar}</td>
            <td>${valorMostrar}</td>
            <td>
                <button onclick="editarLlanta('${llanta.clave}')">Editar</button>
                <button onclick="eliminarLlanta('${llanta.clave}')">Eliminar</button>
            </td>
        `;     
        tbody.appendChild(tr);
    });
    highlightSearch('INVENTARIO', document.getElementById('searchINVENTARIO').value);
}
async function calcularPesosINVENTARIO() {
    let filasActualizadas = [];
    let noCalculadas = [];
    let filasFallidas = [];   

    try {
        mostrarEstado('Iniciando c√°lculos de peso...');
        
        for (const llanta of INVENTARIO) {
            if (!llanta.peso || Number(llanta.peso) === 0) {
                let desc = (llanta.descripcion || '').replace(/[()]/g, '').toUpperCase();
                let peso = 0;

                // Patrones de medidas espec√≠ficos para diferentes tipos
                const patrones = [
                    // 1. Llantas de auto/SUV con formato XXX/YY RZZ (ej: 205/55 R16)
                    {
                        regex: /^(\d{3})[\s\/](\d{2})[\s\/]?R(\d{2})/i,
                        calc: (m, desc = '') => {
                            const ancho = Number(m[1]);
                            const perfil = Number(m[2]);
                            const rin = Number(m[3]);
                            const base = (ancho * perfil/100 * rin/25.4) * 0.2;
                            // Ajustar por tipo de uso
                            let factor = 1.0;  
                            if (desc.includes('SUV') || desc.includes('CAMIONETA')) factor *= 0.90;
                            if (desc.includes('PERFOR')) factor *= 0.90;
                            if (desc.includes('AGATE')) factor *= 0.90;
                            if (desc.includes('BLACKHAWK')) factor *= 1.90;
                            if (desc.includes('EFFICIENT')) factor *= 0.90;
                            if (desc.includes('ANTARES')) factor *= 0.90;
                            if (desc.includes('ATLAS')) factor *= 1.00;
                            if (desc.includes('CACHLAND')) factor *= 0.90;
                            if (desc.includes('DOUBLEKING')) factor *= 0.90;
                            if (desc.includes('FRONWAY')) factor *= 0.90;
                            if (desc.includes('KAPSEN')) factor *= 0.90;
                            if (desc.includes('LINGLONG')) factor *= 0.90;
                            if (desc.includes('MAXTREK')) factor *= 0.90;
                            if (desc.includes('MIRAGE')) factor *= 0.90;
                            if (desc.includes('SAFERICH')) factor *= 0.90;
                            if (desc.includes('SAILUN')) factor *= 0.90;
                            if (desc.includes('AT') || desc.includes('ALL TERRAIN')) factor *= 0.90;
                            if (desc.includes('MT') || desc.includes('MUD TERRAIN')) factor *= 0.90;
                            if (desc.includes('SPORT') || desc.includes('RACING')) factor *= 0.90;
                            return { 
                                peso: base * factor,
                                tipo: desc.includes('SUV') || desc.includes('CAMIONETA') ? 'SUV' : 'AUTO'
                            };
                        }
                    },

                    // 2. Llantas de cami√≥n pesado con formato XXR YY.Z (ej: 11R24.5)
                    {
                        regex: /^(\d{2})R(\d{2}\.?\d*)/i,
                        calc: (m, desc = '') => {
                            const ancho = Number(m[1]) * 25.4; // Convertir pulgadas a mm
                            const rin = Number(m[2]);
                            const base = (ancho * 0.8 * rin/25.4) * 0.39;
                            // Ajustes por uso
                            let factor = 1.50;
                            if (desc.includes('TRACCION')) factor *= 0.90;
                            if (desc.includes('DIRECCION')) factor *= 0.90;
                            if (desc.includes('MIXTA')) factor *= 0.90;
                            if (desc.includes('MINERA')) factor *= 0.50;
                            return { 
                                peso: base * factor,
                                tipo: 'CAMION'
                            };
                        }
                    },

                    // 3. Llantas convencionales XX.XX-YY (ej: 10.00-20)
                    // Mejorado: detecta variantes como '7.50-16 F2 ... (10) AGRO' y marca como AGRICOLA cuando aplique
                    {
                        regex: /^(\d+\.\d+)-(\d{2})(?:\s*([A-Z0-9\-]+))?/i,
                        calc: (m, desc) => {
                            const ancho = Number(m[1]) * 25.4; // Convertir a mm
                            const rin = Number(m[2]);
                            const base = (ancho * rin/25.4) * 0.4;

                            // Detecciones por descripci√≥n
                            const esConvencional = desc.includes('CONVENCIONAL');
                            const esAgro = /\bAGRO\b|\bAGRICOL|\bFARM\b/i.test(desc) || desc.includes('AG');
                            const esTL = /\bTL\b|\bTUBELESS\b/i.test(desc);

                            // Factor base: convencional ligeramente mayor; si es agr√≠cola aplicar factor adicional
                            let factor = esConvencional ? 1.2 : 1.0;
                            if (esAgro) factor *= 2.10; // incremento para usos agr√≠colas/agro
                            if (esTL) factor *= 0.98; // tubeless suele ser algo m√°s ligero

                            // Devolver tipo seg√∫n detecci√≥n (priorizar AGRICOLA cuando corresponda)
                            const tipo = esAgro ? 'AGRICOLA' : (esConvencional ? 'CONVENCIONAL' : 'AUTO');

                            return {
                                peso: base * factor,
                                tipo: tipo
                            };
                        }
                    },

                    // 3.5 Llantas simple "ANCHO RIN" (ej: 215 R14, 225 R15) - formato directo mm sin perfil
                    {
                        regex: /^(\d{3})[\s\/]R(\d{2})(?:\s|$)/i,
                        calc: (m, desc = '') => {
                            // Formato: 215 R14 -> m[1]=215 (ancho en mm), m[2]=14 (rin en pulgadas)
                            const anchoMm = Number(m[1]);
                            const rin = Number(m[2]);
                            
                            // Asumir perfil est√°ndar (65-70%) si no se indica
                            // base ~ (ancho_mm * rin_mm * coeficiente) 
                            // Para 215 R14 (t√≠pico auto): 215 * 14 * 0.055 ~ 165 (peso realista ~18 kg)
                            const base = (anchoMm * rin) * 0.055;
                            
                            let factor = 1.0;
                            // Ajustes por marca/tipo
                            if (desc.includes('DOUBLEKING') || desc.includes('DK228')) factor *= 0.95;  // Marca econ√≥mica
                            if (desc.includes('MICHELIN') || desc.includes('PIRELLI') || desc.includes('CONTINENTAL')) factor *= 1.15;  // Premium
                            if (desc.includes('SPORT') || desc.includes('RACING')) factor *= 1.10;
                            if (desc.includes('ECO') || desc.includes('ECONOMY')) factor *= 0.90;
                            
                            // √çndice de carga (ej: "110/108R" -> extrae 110)
                            const cargaMatch = desc.match(/(\d{3})\/(\d{3})R/);
                            if (cargaMatch) {
                                const indice = Number(cargaMatch[1]);
                                if (indice > 100) factor *= 1.08; // Ligeramente m√°s pesadas
                            }
                            
                            return { peso: base * factor, tipo: 'AUTO' };
                        }
                    },

                    // 4. Llantas MT/AT (Todo Terreno) con formato XXXYY.ZZ RWW
                    {
                        regex: /^(\d{2,3})[Xx](\d{1,2}\.?\d*)[\s-]?R(\d{2})/i,
                        calc: (m, desc = '') => {
                            // Formato tipo "27X8.50 R14" -> m[1]=27 (di√°metro en in), m[2]=8.50 (ancho en in), m[3]=14 (rin)
                            const diamIn = Number(m[1]);
                            const anchoIn = Number(m[2]);
                            const rin = Number(m[3]);

                            // Convertir ancho a mm
                            const anchoMm = anchoIn * 25.4;

                            // Estimaci√≥n basada en secci√≥n (ancho) y rin: producir un peso razonable
                            // base ~ (ancho_mm * (rin_inches)) * coeficiente
                            // coeficiente ajustado para que 27x8.50 R14 quede en rango realista (~15-25 kg)
                            const base = (anchoMm * (rin / 25.4)) * 0.45;

                            let factor = 1.0;
                            // Ajustes por descripci√≥n (mantener compatibilidad con flags AT/MT/HD)
                            if (desc.includes('MT') || desc.includes('MUD TERRAIN')) factor *= 1.15;
                            if (desc.includes('AT') || desc.includes('ALL TERRAIN')) factor *= 1.05;
                            if (desc.includes('HEAVY DUTY') || desc.includes('HD')) factor *= 1.30;
                            if (desc.includes('REFORZADA') || desc.includes('REINFORCED')) factor *= 1.25;

                            return { peso: base * factor, tipo: 'TODO_TERRENO' };
                        }
                    },

                    // 5. Llantas agr√≠colas/industriales XX-YY.Z
                    {
                        regex: /^(\d+(?:\.\d+)?)-(\d+\.?\d*)\s*(IND|AG)?/i,
                        calc: (m, desc = '') => {
                            const ancho = Number(m[1]) * 25.4;
                            const rin = Number(m[2]);
                            const base = ancho * rin/25.4 * 0.6;
                            
                            // Determinar tipo y factor base
                            let tipo, factorBase;
                            if (desc.includes('MINERIA') || desc.includes('MINING')) {
                                tipo = 'MINERIA';
                                factorBase = 0.20;
                            } else if (desc.includes('AG') || desc.includes('AGRICOLA') || desc.includes('FARM')) {
                                tipo = 'AGRICOLA';
                                factorBase = 2.00;
                            } else if (desc.includes('IND') || desc.includes('INDUSTRIAL')) {
                                tipo = 'INDUSTRIAL';
                                factorBase = 0.50;
                            } else { 
                                tipo = 'INDUSTRIAL';
                                factorBase = 0.50;
                            }
                            
                            // Ajustes adicionales por uso espec√≠fico
                            let factorAdicional = 1.0;
                            if (desc.includes('HEAVY DUTY') || desc.includes('HD')) factorAdicional *= 0.50;
                            if (desc.includes('L5') || desc.includes('ROCK')) factorAdicional *= 0.50;
                            if (desc.includes('ESPECIAL') || desc.includes('SPECIAL')) factorAdicional *= 0.50;
                            if (desc.includes('REFORZADA') || desc.includes('REINFORCED')) factorAdicional *= 0.50;
                            
                            return { 
                                peso: base * factorBase * factorAdicional,
                                tipo: tipo
                            };
                        }
                    },       

                    // 6. Patr√≥n para llantas de alta carga (√≠ndice >100)
                    {
                        regex: /(\d{3})\/(\d{2})R(\d{2})\s+\w+\s+(\d{3})/i,
                        calc: (m, desc = '') => {
                            const ancho = Number(m[1]);
                            const perfil = Number(m[2]);
                            const rin = Number(m[3]);
                            const indice = Number(m[4]);
                            const base = (ancho * perfil/100 * rin/25.4) * 0.25;
                            
                            // Factor base por √≠ndice de carga
                            let factor = indice > 100 ? 1.4 : 1;
                            
                            // Ajustes adicionales por tipo y uso
                            if (desc.includes('XL') || desc.includes('EXTRA LOAD')) factor *= 0.50;
                            if (desc.includes('REFORZADA') || desc.includes('REINFORCED')) factor *= 0.50;
                            if (desc.includes('HEAVY DUTY') || desc.includes('HD')) factor *= 0.50;
                            if (desc.includes('COMERCIAL') || desc.includes('COMMERCIAL')) factor *= 0.50;
                            
                            return {
                                peso: base * factor,
                                tipo: 'CARGA_ALTA'
                            };
                        }
                    }
                ];

                // Factores de ajuste espec√≠ficos
                const factoresAjuste = {
                    'XL': 0.50,      // Extra Load
                    'RF': 0.50,      // Reinforced
                    'PR': 0.50,      // Ply Rating base
                    'SKS': 0.50,     // Super resistentes
                    'L5': 0.50,      // L5 extra profundo
                    'SOLID': 0.50,    // Macizas
                    'HT': 0.50,      // Highway Terrain
                    'AT': 0.50,      // All Terrain
                    'MT': 0.50,      // Mud Terrain
                    'TRACCION': 0.50, // Llantas de tracci√≥n
                    'DIRECCION': 0.50,// Llantas direccionales
                    'COMERCIAL': 0.50,// Uso comercial
                    'PERFOR': 0.50,   // Performance
                    'EFFICIENT': 0.50,// Eficiente/Econ√≥mica
                    'MIXTA': 0.50    // Uso mixto
                };

                // Determinar tipo base por descripci√≥n
                let tipoBase = '';
                if (desc.match(/AGRICOLA|TRACTOR|R-1|FARM/i)) tipoBase = 'AGRICOLA';
                else if (desc.match(/OTR|INDUSTRIAL|L-[2-5]|SKS|IND/i)) tipoBase = 'INDUSTRIAL';
                else if (desc.match(/CAMION|TRACCION|295|315|385|11R|10\.00-20|11\.00-20/i)) tipoBase = 'CAMION';
                else if (desc.match(/4X4|SUV|LT|PICKUP|AT|MT|TODO TERRENO/i)) tipoBase = 'SUV';
                else if (desc.match(/CONVENCIONAL/i)) tipoBase = 'CONVENCIONAL';
                else if (desc.match(/COMERCIAL|CARGA/i)) tipoBase = 'COMERCIAL';
                else tipoBase = 'AUTO';

                // Ajustes por uso espec√≠fico
                let usoEspecifico = '';
                if (desc.match(/H\/T|HIGHWAY/i)) usoEspecifico = 'CARRETERA';
                else if (desc.match(/A\/T|ALL[\s-]TERRAIN/i)) usoEspecifico = 'TODO_TERRENO';
                else if (desc.match(/M\/T|MUD[\s-]TERRAIN/i)) usoEspecifico = 'CAMPO';
                else if (desc.match(/DIRECCION|STEERING/i)) usoEspecifico = 'DIRECCIONAL';
                else if (desc.match(/TRACCION|TRACTION/i)) usoEspecifico = 'TRACCION';
                else if (desc.match(/MIXTA|MIXED/i)) usoEspecifico = 'MIXTA';

                // Buscar patr√≥n coincidente
                let resultado = null;    
                for (const patron of patrones) {
                    const match = desc.match(patron.regex);
                    if (match) {
                        resultado = patron.calc(match, desc); // Pasar tambi√©n la descripci√≥n
                        break;
                    }
                }
                
                // Si no se encontr√≥ ning√∫n patr√≥n o no se pudo calcular
                if (!resultado) {
                    noCalculadas.push({
                        clave: llanta.clave,
                        descripcion: desc
                    });
                    continue;
                }

                let pesoBase = resultado.peso;
                tipoBase = resultado.tipo || tipoBase;

                // Aplicar factores de ajuste
                let factorTotal = 1.0;
                for (const [clave, factor] of Object.entries(factoresAjuste)) {
                    if (desc.includes(clave)) factorTotal *= factor;
                }

                // Ajustes adicionales por n√∫mero de capas
                const capasMatch = desc.match(/\((\d{1,2})\)/);
                if (capasMatch) {
                    const capas = Number(capasMatch[1]);
                    if (capas > 8) factorTotal *= (1 + (capas-8)*0.05);
                }

                // Ajustes por material/construcci√≥n
                if (desc.includes('STEEL')) factorTotal *= 0.50;
                if (desc.includes('RADIAL')) factorTotal *= 0.50;
                if (desc.includes('NYLON')) factorTotal *= 0.50;

                // C√°lculo final del peso
                peso = pesoBase * factorTotal;

                // Redondeo y validaci√≥n final
                if (peso > 0) {
                    peso = Math.round(peso * 100) / 100; // Redondeo a 2 decimales

                    try {
                        const res = await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey/clave/${llanta.clave}`, {
                            method: 'PATCH',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({ data: { peso: peso } })
                        });

                        if (!res.ok) throw new Error('Error en PATCH');
                        llanta.peso = peso;
                        filasActualizadas.push({
                            clave: llanta.clave,
                            peso: peso,
                            tipo: tipoBase
                        });
                    } catch (err) {
                        filasFallidas.push({
                            clave: llanta.clave,
                            descripcion: desc,
                            error: err.message
                        });
                    }
                } else {
                    noCalculadas.push({
                        clave: llanta.clave,
                        descripcion: desc
                    });
                }
            }
        }

        renderINVENTARIO();5
        
        // Mostrar resultados usando SweetAlert2
        let mensaje = '<div style="text-align: left;">';
        
        if (filasActualizadas.length > 0) {
            mensaje += `<h4>‚úÖ Llantas actualizadas (${filasActualizadas.length}):</h4><ul>`;
            filasActualizadas.slice(0, 5).forEach(item => {
                mensaje += `<li>Clave: ${item.clave} - Peso: ${item.peso}kg (${item.tipo})</li>`;
            });
            if (filasActualizadas.length > 5) mensaje += `<li>... y ${filasActualizadas.length - 5} m√°s</li>`;
            mensaje += '</ul>';
        }

        if (noCalculadas.length > 0) {
            mensaje += `<h4>‚ö†Ô∏è No se pudo calcular (${noCalculadas.length}):</h4><ul>`;
            noCalculadas.slice(0, 5).forEach(item => {
                mensaje += `<li>Clave: ${item.clave} - ${item.descripcion}</li>`;
            });
            if (noCalculadas.length > 5) mensaje += `<li>... y ${noCalculadas.length - 5} m√°s</li>`;
            mensaje += '</ul>';
        }

        if (filasFallidas.length > 0) {
            mensaje += `<h4>‚ùå Errores al actualizar (${filasFallidas.length}):</h4><ul>`;
            filasFallidas.slice(0, 5).forEach(item => {
                mensaje += `<li>Clave: ${item.clave} - Error: ${item.error}</li>`;
            });
            if (filasFallidas.length > 5) mensaje += `<li>... y ${filasFallidas.length - 5} m√°s</li>`;
            mensaje += '</ul>';
        }

        mensaje += '</div>';

        Swal.fire({
            title: 'Resultados del c√°lculo de pesos',
            html: mensaje,
            icon: filasActualizadas.length > 0 ? 'success' : 'warning',
            confirmButtonText: 'Aceptar',
            width: '600px'
        });

    } catch (error) {
        console.error('Error en c√°lculos:', error);
        Swal.fire({
            title: 'Error',
            text: `Error en c√°lculos: ${error.message}`,
            icon: 'error',
            confirmButtonText: 'Aceptar'
        });
    }
}
// ...existing code...

   async function eliminarLlanta(clave) {
     if (!confirm('¬øSeguro que deseas eliminar esta llanta?')) return;
     try {
       const res = await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey/clave/${clave}`, {
         method: 'DELETE'
      });
      if (!res.ok) throw new Error('No se pudo eliminar');
      INVENTARIO = INVENTARIO.filter(item => item.clave !== clave);
      renderINVENTARIO();
      alert('Llanta eliminada correctamente.');
    } catch (error) {
      alert('Error al eliminar: ' + error.message);
    }
  }
  function editarLlanta(clave) {
  const llanta = INVENTARIO.find(item => item.clave === clave);
  // Muestra el modal con los datos actuales
  document.getElementById('modalINVENTARIO').innerHTML = `
    <div class="modal-content">
      <h3>Editar Llanta</h3>
      <label>Descripci√≥n: <input id="editDescripcion" value="${llanta.descripcion}" /></label><br>
      <label>L√≠nea: <input id="editLinea" value="${llanta.linea}" /></label><br>
      <label>Peso: <input id="editPeso" type="number" step="0.0001" value="${llanta.peso}" /></label><br>
      <label>Volumen: <input id="editVolumen" type="number" step="0.0001" value="${llanta.volumen}" /></label><br>
      <label>Valor: <input id="editValor" type="number" step="0.0001" value="${llanta.valor}" /></label><br>
      <button onclick="guardarEdicionLlanta('${llanta.clave}')">Guardar</button>
      <button onclick="closeModal('modalINVENTARIO')">Cancelar</button>
    </div>
  `;
  openModal('modalINVENTARIO');
}
// --- PEGA AQU√ç ---
async function guardarEdicionLlanta(clave) {
    const nuevosDatos = {
        descripcion: document.getElementById('editDescripcion').value,
        linea: document.getElementById('editLinea').value,
        peso: document.getElementById('editPeso').value,
        volumen: document.getElementById('editVolumen').value,
        valor: document.getElementById('editValor').value
    };

    try {
        const res = await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey/clave/${clave}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ data: nuevosDatos })
        });
        if (!res.ok) throw new Error('No se pudo editar');
        
        const llanta = INVENTARIO.find(item => item.clave === clave);
        Object.assign(llanta, nuevosDatos);
        renderINVENTARIO();
        closeModal('modalINVENTARIO');
        alert('Llanta editada correctamente.');
    } catch (error) {
        alert('Error al editar: ' + error.message);
    }
}
// Despu√©s de editarLlanta() y antes de guardarEdicionLlanta()
async function calcularVolumenINVENTARIO() {
    let filasActualizadas = [];
    let noCalculadas = [];
    let filasFallidas = [];

    try {
        // Mostrar indicador de carga
        Swal.fire({
            title: 'Calculando vol√∫menes...',
            text: 'Por favor espere mientras se procesan los datos...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading();
            }
        });
        
        const botonCalc = document.querySelector('button[onclick="calcularVolumenINVENTARIO()"]');
        if (botonCalc) botonCalc.disabled = true;

        INVENTARIO.sort((a, b) => Number(a.clave) - Number(b.clave));
        

        for (const llanta of INVENTARIO) {
            if (!llanta.volumen || Number(llanta.volumen) === 0) {
                let ancho, perfil, rin;
                let desc = (llanta.descripcion || '').replace(/[()]/g, '').toUpperCase();

                // Patrones para diferentes tipos de llantas
                // Se agrega soporte para formatos tipo '31X10.50 R15' (off-road / 4X4)
                const patrones = [
                    // Patr√≥n para formato '31X10.50 R15' o '31X10.50R15' (di√°metro x ancho R rin)
                    {
                        regex: /^(\d{2,3})X(\d{1,2}\.\d{1,2}|\d{1,2})\s*R?(\d{2})/i,
                        calc: (m) => {
                            const overallIn = Number(m[1]); // di√°metro total en pulgadas
                            const widthIn = Number(m[2]); // ancho en pulgadas
                            const rimIn = Number(m[3]); // rin en pulgadas
                            const ancho = widthIn * 25.4 / 1000;
                            const rin = rimIn * 0.0254;
                            // Estimar perfil a partir del di√°metro exterior cuando sea posible
                            // perfil = (overall - rim) / (2 * width)
                            let perfil = 0.65; // valor por defecto
                            if (overallIn > rimIn && widthIn > 0) {
                                perfil = (overallIn - rimIn) / (2 * widthIn);
                                if (perfil <= 0 || !isFinite(perfil)) perfil = 0.65;
                            }
                            return {
                                ancho,
                                perfil,
                                rin,
                                tipo: '4X4'
                            };
                        }
                    },
                    // 1. Patr√≥n para llantas comerciales/autos (ej: 185 R14 AGATE AG-06)
                    {
                       regex: /^(\d{3})\s*R(\d{2})\s*.*?(?:\((\d{1,2})\))?.*?(\d{3}\/\d{3}R)?/i,
                       calc: (m) => ({
                           ancho: Number(m[1]) / 1000, // 185mm a metros
                           perfil: 0.82, // Perfil est√°ndar para llantas R
                           rin: Number(m[2]) * 0.0254, // 14 pulgadas a metros
                           tipo: 'COMERCIAL',
                           capas: m[3] ? Number(m[3]) : 8 // Capas, por defecto 8
                        })
                    },

                    // 2. Patr√≥n para llantas industriales (ej: 19.5L-24 IND ALLWIN SEVERE)
                    {
                         regex: /^(\d+\.?\d*)L-(\d+)\s*(?:IND|INDUSTRIAL)?\s*.*?(?:\((\d{1,2})\))?.*?(L[2-5]|SEVERE)?/i,
                         calc: (m) => {
                             const ancho = Number(m[1]) * 25.4 / 1000; // Convertir pulgadas a metros
                             const rin = Number(m[2]) * 0.0254;
                             const capas = m[3] ? Number(m[3]) : 12; // Por defecto 12 capas
                             const esSevere = m[4]?.includes('SEVERE') || false;
        
                            return {
                                ancho,
                                perfil: 0.90, // Perfil t√≠pico para industrial
                                rin,
                                tipo: 'INDUSTRIAL',
                                capas,
                                factorAdicional: esSevere ? 1.1 : 1.0 // 10% extra para SEVERE
                            };
                        }
                    },
                    // 3. Patr√≥n espec√≠fico para llantas 11L-16 y similares
                    {
                        regex: /^(\d{2})L-(\d{2})\s*(?:\((\d{1,2})\))?\s*((?:SKS|F3|IND|AGRO|CT).*)?/i,
                        calc: (m) => {
                            const ancho = Number(m[1]) * 25.4 * 1.15 / 1000; // 15% m√°s ancho
                            const rin = Number(m[2]) * 0.0254;
                            const capas = m[3] ? Number(m[3]) : 12; // Por defecto 12 capas
                            const tipo = m[4]?.includes('IND') || m[4]?.includes('SKS') ? 'INDUSTRIAL' : 
                                       m[4]?.includes('AGRO') ? 'AGRICOLA' : 'INDUSTRIAL';
                            return {
                                ancho,
                                perfil: 0.90, // Perfil fijo para industrial/agr√≠cola
                                rin,
                                tipo,
                                capas
                            };
                        }
                    },
                    // 4. Llantas de Auto/SUV: 185/60 R14
                    {
                        regex: /^[P]?(\d{3})[\/\s\-](\d{2})[\/\s\-]?R?(\d{2})/,
                        calc: (m) => ({
                            ancho: Number(m[1]) / 1000,
                            perfil: Number(m[2]) / 100,
                            rin: Number(m[3]) * 0.0254,
                            tipo: 'AUTO'
                        })
                    },
                    // 5. Llantas de Cami√≥n: 11R22.5
                    {
                       regex: /^(\d{2,3})R(\d{2}\.\d*)|(^\d{3}\/\d{2}R\d{2}\.\d*)/,
                       calc: (m) => ({
                           ancho: Number(m[1] || m[3]) * 25.4 / 1000,
                           perfil: 0.80,
                           rin: Number(m[2] || m[4]) * 0.0254,
                           tipo: 'CAMION'
                        })
                    },
                    // 6. Llantas de Cami√≥n: 11R22.5
                    {
                       regex: /^(\d{2,3})R(\d{2}\.?\d*)|(^\d{3}\/\d{2}R\d{2}\.?\d*)/,
                       calc: (m) => ({
                           ancho: Number(m[1] || m[3]) * 25.4 / 1000,
                           perfil: 0.80,
                           rin: Number(m[2] || m[4]) * 0.0254,
                           tipo: 'CAMION'
                        })
                    },
                    // . Llantas agr√≠colas tradicionales
                    {
                        regex: /^(\d{1,2}\.?\d*)[\/\-](?:(\d{2})[\/\-])?(\d{2})/,
                        calc: (m) => ({
                            ancho: Number(m[1]) * 25.4 / 1000,
                            perfil: Number(m[2] || 90) / 100,
                            rin: Number(m[3]) * 0.0254,
                            tipo: 'AGRICOLA'
                        })
                    }
                ];

                let medidas = null;
                let tipoLlanta = '';

                // Determinar tipo por descripci√≥n y patr√≥n
                if (desc.includes('AGRICOLA') || desc.includes('TRACTOR') || desc.includes('AGRO') || /\bR1\b/.test(desc)) {
                    tipoLlanta = 'AGRICOLA';
                             } else if (
                                        desc.includes('INDUSTRIAL') ||
                                        desc.includes('OTR') ||
                                        /\bE[3-4]\/L[3-5]\b/.test(desc) ||       // atributos tipo E3/L3, etc.
                                        /\b\d{2,2}\.\d{2}-\d{2}\b/.test(desc) ||  // formato 14.00-24
                                        /\b\d{2,2}-\d{2,2}\.?\d{0,1}\b/.test(desc) ||  // formato 12-16.5 o 12-16
                                        /\bL-?5\b/.test(desc) // detectar L5 o L-5 (ej: 'L5')
                                ) {
                                        tipoLlanta = 'INDUSTRIAL';
                             } else if (desc.includes('CAMION')) {
                                        tipoLlanta = 'CAMION';
                             } else if (desc.includes('4X4')) {
                                        tipoLlanta = '4X4';
                             } else if (/\b\d{2,3}R\d{2}\.\d{1,2}\b/.test(desc) || /\b\d{3}\/\d{2}R\d{2}\.\d{1,2}\b/.test(desc) || desc.match(/^11R22\.5/)) {
                                        tipoLlanta = 'CAMION';
                             } else {
                                        tipoLlanta = 'AUTO';
                                     }

                // Buscar patr√≥n coincidente
                for (const patron of patrones) {
                    const match = desc.match(patron.regex);
                    if (match) {
                        medidas = patron.calc(match);
                        break;
                    }
                }

                // Si el patr√≥n devolvi√≥ un tipo, usarlo (esto permite que patrones especiales
                // como '31X10.50 R15' establezcan '4X4' aunque la detecci√≥n previa no lo hiciera)
                if (medidas && medidas.tipo) {
                    tipoLlanta = medidas.tipo;
                }

                if (!medidas) {
                    noCalculadas.push({
                        descripcion: llanta.descripcion || '(sin descripci√≥n)',
                        clave: llanta.clave
                    });
                    continue;
                }
                // C√°lculo y par√°metros diferenciados por tipo de llanta
                let factorCorreccion, margenLogisticoTipo, volumen_m3;
                if (tipoLlanta === 'AGRICOLA') {
                    factorCorreccion = desc.includes('L-') ? 1.0 : 1.0;
                    margenLogisticoTipo = 1.900;
                    let alturaFlanco = medidas.perfil * medidas.ancho;
                    let diametroExterno = (medidas.rin + 2 * alturaFlanco) * 1.10;
                    volumen_m3 = Math.PI * Math.pow(diametroExterno/2, 2) * medidas.ancho * factorCorreccion * margenLogisticoTipo;
                    if (medidas.capas && medidas.capas > 12) {
                        volumen_m3 *= (1 + (medidas.capas - 12) * 0.025);
                    }
                } else if (tipoLlanta === 'INDUSTRIAL') {
                    factorCorreccion = desc.includes('SKS') ? 1.10 : 1.10;
                    margenLogisticoTipo = 1.50;
                    let alturaFlanco = medidas.perfil * medidas.ancho;
                    let diametroExterno = (medidas.rin + 2 * alturaFlanco) * 1.09;
                    volumen_m3 = Math.PI * Math.pow(diametroExterno/2, 2) * medidas.ancho * factorCorreccion * margenLogisticoTipo;
                    if (desc.match(/SKS-[1-3]|L-5/)) {
                        volumen_m3 *= 1.12;
                    }
                    if (medidas.capas && medidas.capas > 12) {
                        volumen_m3 *= (1 + (medidas.capas - 12) * 0.02);
                    }
                } else if (tipoLlanta === 'CAMION') {
                    factorCorreccion = 1.20;
                    margenLogisticoTipo = 1.20;
                    let alturaFlanco = medidas.perfil * medidas.ancho;
                    let diametroExterno = medidas.rin + 2 * alturaFlanco;
                    volumen_m3 = Math.PI * Math.pow(diametroExterno/2, 2) * medidas.ancho * factorCorreccion * margenLogisticoTipo;
                } else if (tipoLlanta === '4X4') {
                    factorCorreccion = 1.45;
                    margenLogisticoTipo = 1.22;
                    let alturaFlanco = medidas.perfil * medidas.ancho;
                    let diametroExterno = medidas.rin + 2 * alturaFlanco;
                    volumen_m3 = Math.PI * Math.pow(diametroExterno/2, 2) * medidas.ancho * factorCorreccion * margenLogisticoTipo;
                } else {
                    // AUTO y otros
                    factorCorreccion = 0.90;
                    margenLogisticoTipo = 0.90;
                    let alturaFlanco = medidas.perfil * medidas.ancho;
                    let diametroExterno = medidas.rin + 2 * alturaFlanco;
                    volumen_m3 = Math.PI * Math.pow(diametroExterno/2, 2) * medidas.ancho * factorCorreccion * margenLogisticoTipo;
                }

                const nuevoVolumen = volumen_m3.toFixed(4);

                try {
                    const res = await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey/clave/${llanta.clave}`, {
                        method: 'PATCH',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ data: { volumen: nuevoVolumen } })
                    });

                    if (!res.ok) throw new Error('Error en PATCH: ' + res.status);
                    llanta.volumen = nuevoVolumen;
                    filasActualizadas.push({ 
                        clave: llanta.clave, 
                        volumen: nuevoVolumen,
                        tipo: tipoLlanta 
                    });
                    await new Promise(r => setTimeout(r, 120));
                } catch (err) {
                    filasFallidas.push({ 
                        clave: llanta.clave, 
                        descripcion: llanta.descripcion || '', 
                        error: err.message 
                    });
                }
            }
        }

        renderINVENTARIO();
        
        // Mostrar resultados usando SweetAlert2
        let mensaje = '<div style="text-align: left;">';
        
        if (filasActualizadas.length > 0) {
            mensaje += `<h4>‚úÖ Llantas actualizadas (${filasActualizadas.length}):</h4><ul>`;
            filasActualizadas.slice(0, 5).forEach(item => {
                mensaje += `<li>Clave: ${item.clave} - Volumen: ${item.volumen}m¬≥ (${item.tipo})</li>`;
            });
            if (filasActualizadas.length > 5) mensaje += `<li>... y ${filasActualizadas.length - 5} m√°s</li>`;
            mensaje += '</ul>';
        }

        if (noCalculadas.length > 0) {
            mensaje += `<h4>‚ö†Ô∏è No se pudo calcular (${noCalculadas.length}):</h4><ul>`;
            noCalculadas.slice(0, 5).forEach(item => {
                mensaje += `<li>Clave: ${item.clave} - ${item.descripcion}</li>`;
            });
            if (noCalculadas.length > 5) mensaje += `<li>... y ${noCalculadas.length - 5} m√°s</li>`;
            mensaje += '</ul>';
        }

        if (filasFallidas.length > 0) {
            mensaje += `<h4>‚ùå Errores al actualizar (${filasFallidas.length}):</h4><ul>`;
            filasFallidas.slice(0, 5).forEach(item => {
                mensaje += `<li>Clave: ${item.clave} - Error: ${item.error}</li>`;
            });
            if (filasFallidas.length > 5) mensaje += `<li>... y ${filasFallidas.length - 5} m√°s</li>`;
            mensaje += '</ul>';
        }

        mensaje += '</div>';

        Swal.fire({
            title: 'Resultados del c√°lculo de vol√∫menes',
            html: mensaje,
            icon: filasActualizadas.length > 0 ? 'success' : 'warning',
            confirmButtonText: 'Aceptar',
            width: '600px'
        });

    } catch (error) {
        console.error('Error en c√°lculos:', error);
        Swal.fire({
            title: 'Error',
            text: `Error en c√°lculos: ${error.message}`,
            icon: 'error',
            confirmButtonText: 'Aceptar'
        });
    } finally {
        const botonCalc = document.querySelector('button[onclick="calcularVolumenINVENTARIO()"]');
        if (botonCalc) botonCalc.disabled = false;
    }
}
// Buscar ID INVENTARIO
function searchINVENTARIO() {
    const filter = document.getElementById('searchINVENTARIO').value.toLowerCase();
    const tbody = document.querySelector('#tablaINVENTARIO tbody');
     for (let row of tbody.rows) {
        const claveCell = row.cells[0].textContent.toLowerCase();
        const descripcionCell = row.cells[1].textContent.toLowerCase();
        // Busca en clave o descripci√≥n
        const match = claveCell.includes(filter) || descripcionCell.includes(filter);
        row.style.display = match ? '' : 'none';
        if (match && filter) {
            row.classList.add('highlight-yellow');
                setTimeout(() => row.classList.remove('highlight-yellow'), 1100);
            }
        }
    }
    function highlightSearch(tab, valor) {
        if (!valor) return;
        let rows = document.querySelector(`#tabla${tab.charAt(0).toUpperCase() + tab.slice(1)} tbody`).rows;
        [...rows].forEach(row => {
            if (row.cells[0].textContent.toLowerCase().includes(valor.toLowerCase())) {
                row.classList.add('highlight-yellow');
                row.scrollIntoView({ behavior: "smooth", block: "center" });
                setTimeout(() => row.classList.remove('highlight-yellow'), 900);
            }
        });
    }
    function buscarLlantaPorId(id) {
        return INVENTARIO.find(llanta => llanta.id === id);
    }

    // ---------- Agregar nueva llanta a SheetDB ----------
    async function agregarNuevaLlanta() {
    // Obtener valores de los campos correctos
    const clave = document.getElementById('agregarId').value.trim();
    const descripcion = document.getElementById('agregarDescripcion').value.trim();
    const peso = document.getElementById('agregarPeso').value.trim();
    const volumen = document.getElementById('agregarVolumen').value.trim();
    const valor = document.getElementById('agregarValor').value.trim();
    const linea = document.getElementById('agregarLinea').value.trim();

    // Validar solo campos requeridos
    if (!clave) {
        alert('El c√≥digo/ID es obligatorio');
        return;
    }
    if (!descripcion) {
        alert('La descripci√≥n es obligatoria');
        return;
    }

    // Crear objeto con datos
    const nuevaLlanta = {
        clave: clave,
        descripcion: descripcion,
        peso: peso || '',
        volumen: volumen || '',
        valor: valor || '',
        linea: linea || ''
    };

    // Si no se proporcionaron peso/volumen, intentar calcularlos antes de guardar
    if (!nuevaLlanta.peso || !nuevaLlanta.volumen) {
        try {
            const asegurada = await ensurePesoVolumen({ descripcion: nuevaLlanta.descripcion, peso: Number(nuevaLlanta.peso) || 0, volumen: Number(nuevaLlanta.volumen) || 0 });
            nuevaLlanta.peso = asegurada.peso;
            nuevaLlanta.volumen = asegurada.volumen;
        } catch (e) {
            console.warn('No se pudo calcular peso/volumen al agregar manualmente la llanta:', e);
            // dejar los valores tal cual (la API los puede aceptar como cadena vac√≠a)
        }
    }

    try {
        const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                data: [nuevaLlanta]
            })
        });

        if (!response.ok) {
            throw new Error('Error al guardar la llanta');
        }

        // Agregar al INVENTARIO local
        INVENTARIO.push(nuevaLlanta);
        
        // Actualizar tabla
        renderINVENTARIO();
        
        // Limpiar formulario
        document.getElementById('formAgregarLlanta').reset();
        
        // Cerrar modal
        closeModal('modalINVENTARIO');

        alert('Llanta agregada correctamente');

    } catch (error) {
        console.error('Error:', error);
        alert('Error al agregar la llanta: ' + error.message);
    }
}
    function generarNuevoIdINVENTARIO() {
        if (!INVENTARIO.length) return "1";
        let maxId = INVENTARIO.reduce((max, ll) => {
            let n = parseInt(ll.id);
            return n > max ? n : max;
        }, 0);
        return String(maxId + 1);
    }

    // Extrae c√≥digo y descripci√≥n de un objeto llanta recibido desde distintas fuentes
    function _extraerCodigoDescripcion(item) {
        if (!item) return { code: '', desc: '' };
        const code = (item.clave || item.Clave || item.codigo || item.Codigo || item.code || item.id || item.ID || item.CODIGO || item.COD) || '';
        const desc = (item.descripcion || item.Descripcion || item.DESCRIPCION || item.nombre || item.Nombre || item.producto || item.Producto || item.descripcionProducto) || '';
        return { code: String(code).trim(), desc: String(desc).trim() };
    }

    // Asegura que cada llanta del array exista en INVENTARIO; si falta, la agrega a SheetDB e INVENTARIO local.
    async function asegurarLlantasEnINVENTARIO(llantas) {
        if (!Array.isArray(llantas) || llantas.length === 0) return [];
        const base = 'https://sheetdb.io/api/v1/gdn5wqo960cey';
        const a√±adidas = [];

        for (const item of llantas) {
            const { code, desc } = _extraerCodigoDescripcion(item);
            const descripcionNormal = (desc || '').toUpperCase();

            // Buscar coincidencia por clave exacta
            let existe = false;
            if (code) {
                existe = INVENTARIO.some(i => String(i.clave || i.Clave || i.ID || i.id || '').toUpperCase() === String(code).toUpperCase());
            }

            // Si no existe por clave, intentar buscar por descripci√≥n parcial
            if (!existe && descripcionNormal) {
                existe = INVENTARIO.some(i => (i.descripcion || '').toUpperCase().includes(descripcionNormal) || descripcionNormal.includes((i.descripcion || '').toUpperCase()));
            }

            if (!existe) {
                // Preparar objeto m√≠nimo para agregar
                const nuevaClave = code || generarNuevoIdINVENTARIO();
                let nueva = {
                    clave: nuevaClave,
                    descripcion: desc || 'Sin descripci√≥n'
                };

                // Asegurar peso/volumen antes de enviar al servidor
                try {
                    nueva = await ensurePesoVolumen(nueva);
                } catch (e) {
                    console.warn('ensurePesoVolumen fall√≥ para nueva entrada en asegurarLlantasEnINVENTARIO', nueva.descripcion, e);
                }

                try {
                    const res = await fetch(base, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ data: [nueva] })
                    });
                    if (res.ok) {
                        // A√±adir al INVENTARIO local con campos m√≠nimos (el resto puede completarse luego)
                        INVENTARIO.push(Object.assign({ peso: '', volumen: '', valor: '', linea: '' }, nueva));
                        a√±adidas.push(nueva);
                        // Peque√±a pausa para no saturar la API
                        await new Promise(r => setTimeout(r, 120));
                    } else {
                        console.warn('No se pudo agregar llanta a SheetDB', await res.text());
                    }
                } catch (err) {
                    console.warn('Error al agregar llanta a SheetDB:', err);
                }
            }
        }

        if (a√±adidas.length > 0) renderINVENTARIO();
        return a√±adidas;
    }
    function limpiarFormularioINVENTARIO() {
        document.getElementById('agregarId').value = '';
        document.getElementById('agregarDescripcion').value = '';
        document.getElementById('agregarPeso').value = '';
        document.getElementById('agregarVolumen').value = '';
        document.getElementById('agregarValor').value = '';
    }
    function searchFlota() {
    const filter = document.getElementById('searchFlota').value.toLowerCase();
    const tbody = document.querySelector('#tablaFlota tbody');
    for (let row of tbody.rows) {
        const economicoCell = row.cells[0].textContent.toLowerCase();
        const match = economicoCell.includes(filter);
        row.style.display = match ? '' : 'none';
        if (match && filter) {
            row.classList.add('highlight-yellow');
            setTimeout(() => row.classList.remove('highlight-yellow'), 1100);
        }
    }
}
    // ---------- Renderizar Flota ----------
  function renderFlota() {
    const tbody = document.querySelector('#tablaFlota tbody');
    tbody.innerHTML = '';

    // Filtrar entradas que no contienen datos significativos para evitar filas vac√≠as
    const meaningful = (flota || []).filter(camion => {
        const keysToCheck = [
            camion.economico,
            camion.unidad,
            camion.asignado || camion.encargado,
            camion.modelo,
            camion.identificacion,
            camion.ubicacion,
            camion['capacidad de carga (kg)'],
            camion.carga,
            camion['volumen'],
            camion.volumen
        ];
        return keysToCheck.some(v => {
            if (v === null || v === undefined) return false;
            const s = String(v).trim();
            if (!s || s === '-' || s.toLowerCase() === 'n/a') return false;
            // Si es n√∫mero y 0 consideramos que no aporta (evitar muchas filas con ceros)
            const n = Number(s.replace(/,/g, '.'));
            if (!isNaN(n) && n === 0) return false;
            return true;
        });
    });

    if (meaningful.length === 0) {
        // Mostrar mensaje amigable en lugar de m√∫ltiples filas vac√≠as
        const trEmpty = document.createElement('tr');
        trEmpty.innerHTML = `<td colspan="9" class="text-center text-muted">No hay unidades cargadas o no se encontraron datos v√°lidos</td>`;
        tbody.appendChild(trEmpty);
        return;
    }

    meaningful.forEach(camion => {
        const cargaNum = safeNum(camion["capacidad de carga (kg)"] || camion.carga);
        const volumenNum = safeNum(camion["volumen"] || camion.volumen);
        const cargaMostrar = cargaNum === 0 ? '-' : cargaNum.toFixed(3);
        const volumenMostrar = volumenNum === 0 ? '-' : volumenNum.toFixed(3);
        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${camion.economico || '-'}</td>
            <td>${camion.unidad || '-'}</td>
            <td>${camion.asignado || camion.encargado || '-'}</td>
            <td>${camion.modelo || '-'}</td>
            <td>${camion.identificacion || '-'}</td>
            <td>${camion.ubicacion || '-'}</td>
            <td>${cargaMostrar}</td>
            <td>${volumenMostrar}</td>
            <td>
            <button onclick="editarCamion('${camion.economico}')">Editar</button>
            <button onclick="eliminarCamion('${camion.economico}')">Eliminar</button>
            </td>
         `;
        tbody.appendChild(tr);
    });
    highlightSearch('flota', document.getElementById('searchFlota').value);
}
     async function eliminarCamion(economico) {
       if (!confirm('¬øSeguro que deseas eliminar este cami√≥n?')) return;
       try {
         const res = await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey/economico/${economico}?sheet=flota`, {
           method: 'DELETE'
         });
         if (!res.ok) throw new Error('No se pudo eliminar');
         flota = flota.filter(item => item.economico !== economico);
         renderFlota();
         alert('Cami√≥n eliminado correctamente.');
       } catch (error) {
         alert('Error al eliminar: ' + error.message);
       }
     } 
    function editarCamion(economico) {
        const camion = flota.find(item => item.economico === economico);
        document.getElementById('modalFlota').innerHTML = `
          <div class="modal-content">
            <h3>Editar Cami√≥n</h3>
            <label>N√∫mero Econ√≥mico: <input id="editCamionEconomico" value="${camion.economico}" readonly /></label><br>
            <label>Nombre (Unidad): <input id="editCamionUnidad" value="${camion.unidad || ''}" /></label><br>
            <label>Capacidad de carga (kg): <input id="editCamionCarga" type="number" step="0.001" value="${camion['capacidad de carga (kg)'] || camion.carga || ''}" /></label><br>
            <label>Volumen (m¬≥): <input id="editCamionVolumen" type="number" step="0.001" value="${camion.volumen || ''}" /></label><br>
            <button onclick="guardarEdicionCamion('${camion.economico}')">Guardar</button>
            <button onclick="closeModal('modalFlota')">Cancelar</button>
          </div>
        `;
        openModal('modalFlota');
    }

    async function guardarEdicionCamion(economico) {
      const nuevosDatos = {
        unidad: document.getElementById('editCamionUnidad').value,
        "capacidad de carga (kg)": document.getElementById('editCamionCarga').value,
        volumen: document.getElementById('editCamionVolumen').value
      };
      try {
        const res = await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey/economico/${economico}?sheet=flota`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ data: nuevosDatos })
        });
        if (!res.ok) throw new Error('No se pudo editar');
        const camion = flota.find(item => item.economico === economico);
        Object.assign(camion, nuevosDatos);
        renderFlota();
        closeModal('modalFlota');
        alert('Cami√≥n editado correctamente.');
      } catch (error) {          
        alert('Error al editar: ' + error.message);
      }
    }

    // ---------- Agregar nuevo cami√≥n a SheetDB ----------
    async function agregarNuevoCamion() {
        const economicoInput = document.getElementById('agregarEconomico').value.trim();
        const unidad = document.getElementById('agregarUnidad').value.trim();
        const asignado = document.getElementById('agregarAsignado').value.trim();
        const modelo = document.getElementById('agregarModelo').value.trim();
        const placas = document.getElementById('agregarPlacas').value.trim();
        const ubicacion = document.getElementById('agregarUbicacion').value.trim();
        const carga = parseFloat(document.getElementById('agregarCarga').value);
        const volumen = parseFloat(document.getElementById('agregarVolumenCamion').value);
        const msgDiv = document.getElementById('msgFlota');
        msgDiv.textContent = '';
        msgDiv.className = 'msg';

        if (!unidad || !asignado || !modelo || !placas || !ubicacion || isNaN(carga) || isNaN(volumen)) {
            msgDiv.textContent = 'Por favor completa todos los campos correctamente.';
            msgDiv.classList.add('error');
            return;
        }

        let economico = economicoInput || generarNuevoEconomico();

        if (flota.some(cam => cam.economico === economico)) {
            msgDiv.textContent = 'El n√∫mero econ√≥mico ya existe. Por favor usa otro.';
            msgDiv.classList.add('error');
            return;
        }

        const nuevoDato = {
            economico,
            unidad,
            asignado,
            modelo,
            placas,
            ubicacion,
            carga,
            volumen
        };

        try {
            const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=flota', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ data: nuevoDato })
            });
            if (!res.ok) throw new Error('Error al agregar cami√≥n');
            msgDiv.textContent = 'Cami√≥n agregado correctamente!';
            msgDiv.classList.add('success');
            limpiarFormularioFlota();
            await fetchFlota();
            closeModal('modalFlota');
        } catch (e) {
            msgDiv.textContent = 'Error: ' + e.message;
            msgDiv.classList.add('error');
        }
    }
    function generarNuevoEconomico() {
        if (!flota.length) return "1";
        let maxEco = flota.reduce((max, cam) => {
            let n = parseInt(cam.economico);
            return n > max ? n : max;
        }, 0);
        return String(maxEco + 1);
    }
    // Funci√≥n para manejar el debounce de actualizaci√≥n
    let timeoutId = null;
    function actualizarSugerenciaUnidad() {
        // Cancelar el timeout anterior si existe
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        
        // Establecer un nuevo timeout
        timeoutId = setTimeout(() => {
            calcularSugerenciaUnidad();
        }, 300); // Esperar 300ms despu√©s de la √∫ltima entrada
    }

    // Definir promedios seg√∫n el tipo de llanta
    const PROMEDIOS_LLANTAS = {
        'AUTO': { volumen: 0.047, peso: 7},
        'SUV_CAMIONETA': { volumen: 0.060, peso: 12.5 },
        'COMERCIAL_LIGERO': { volumen: 0.120, peso: 25 },
        'PESADO': { volumen: 0.350, peso: 60 },
        'AGRICOLA_MINERO': { volumen: 0.400, peso: 80 },
        'CAMARAS': { volumen: 0.010, peso: 2 }
    };

    // Array para almacenar las llantas agregadas
    let llantasAgregadas = [];

    // Funci√≥n para filtrar y mostrar sugerencias de llantas
    function mostrarSugerenciasLlantas(busqueda) {
        const contenedorSugerencias = document.getElementById('sugerenciasLlantas');
        const inputBusqueda = document.getElementById('busquedaLlanta');
        const inputHidden = document.getElementById('descripcionLlanta');
        
        if (!busqueda) {
            contenedorSugerencias.style.display = 'none';
            return;
        }

        // Filtrar INVENTARIO basado en la b√∫squeda
        const sugerencias = INVENTARIO.filter(llanta => 
            llanta.descripcion && 
            llanta.volumen && 
            llanta.peso && 
            llanta.descripcion.toLowerCase().includes(busqueda.toLowerCase())
        );

        if (sugerencias.length > 0) {
            contenedorSugerencias.innerHTML = sugerencias.map(llanta => `
                <div class="p-2 border-bottom hover-bg-light cursor-pointer sugerencia-item" 
                     style="cursor: pointer;"
                     data-valor='${JSON.stringify({
                         descripcion: llanta.descripcion,
                         volumen: parseFloat(llanta.volumen),
                         peso: parseFloat(llanta.peso)
                     })}'>
                    ${llanta.descripcion}
                </div>
            `).join('');
            
            contenedorSugerencias.style.display = 'block';

            // Agregar eventos click a las sugerencias
            contenedorSugerencias.querySelectorAll('.sugerencia-item').forEach(item => {
                item.addEventListener('click', () => {
                    const datos = JSON.parse(item.getAttribute('data-valor'));
                    inputBusqueda.value = datos.descripcion;
                    inputHidden.value = JSON.stringify(datos);
                    contenedorSugerencias.style.display = 'none';
                });
            });
        } else {
            contenedorSugerencias.innerHTML = '<div class="p-2 text-muted">No se encontraron llantas</div>';
            contenedorSugerencias.style.display = 'block';
        }
    }

    // Agregar el evento de b√∫squeda al input
    document.getElementById('busquedaLlanta').addEventListener('input', (e) => {
        mostrarSugerenciasLlantas(e.target.value);
    });

    // Cerrar sugerencias al hacer click fuera
    document.addEventListener('click', (e) => {
        const contenedorSugerencias = document.getElementById('sugerenciasLlantas');
        const inputBusqueda = document.getElementById('busquedaLlanta');
        if (!inputBusqueda.contains(e.target) && !contenedorSugerencias.contains(e.target)) {
            contenedorSugerencias.style.display = 'none';
        }
    });

    // Funci√≥n para agregar una llanta a la lista
    function agregarTipoLlanta() {
        const cantidad = parseInt(document.getElementById('sugestionCantidad').value) || 0;
        const inputHidden = document.getElementById('descripcionLlanta');
        let llantaSeleccionada;
        
        try {
            llantaSeleccionada = JSON.parse(inputHidden.value);
        } catch (e) {
            llantaSeleccionada = null;
        }

        if (cantidad <= 0) {
            alert('Por favor ingrese una cantidad v√°lida');
            return;
        }

        if (!llantaSeleccionada) {
            alert('Por favor seleccione una llanta del listado');
            return;
        }

        // Calcular el volumen y peso de las llantas usando datos reales
        const volumen = cantidad * llantaSeleccionada.volumen;
        const peso = cantidad * llantaSeleccionada.peso;

        // Crear objeto de llanta con datos reales
        const llanta = {
            descripcion: llantaSeleccionada.descripcion,
            cantidad: cantidad,
            volumen: volumen,
            peso: peso
        };

        // Si hay un cami√≥n activo para agregar autom√°ticamente, direccionar la llanta ah√≠
        if (typeof activePendingEconomico !== 'undefined' && activePendingEconomico) {
            // Agregar al pedido en curso (se guardar√° cuando el usuario detenga el modo o confirme)
            pedidosEnCurso.push(Object.assign({}, llanta, { clave: llantaSeleccionada.clave || '', linea: llantaSeleccionada.linea || '' }));
            try { renderPedidosActuales(); } catch(e) { console.warn('No se pudo renderizar pedidos actuales tras agregar a cami√≥n activo', e); }
            try { actualizarGraficas(); } catch(e) {}
            try { renderUnidadesPendientes(); } catch(e) {}

            // Notificar al usuario (toast)
            try {
                Swal.fire({ toast: true, position: 'top-end', icon: 'success', title: `Agregado al cami√≥n ${activePendingEconomico}`, showConfirmButton: false, timer: 1500 });
            } catch(e) { console.log('Agregado al cami√≥n', activePendingEconomico); }

            // No sugerir unidades mientras se est√° agregando directamente
            // Limpiar input
            document.getElementById('sugestionCantidad').value = '1';
            document.getElementById('descripcionLlanta').value = '';
            document.getElementById('busquedaLlanta').value = '';
            return;
        }

        // Agregar la llanta y actualizar la interfaz (comportamiento por defecto)
        llantasAgregadas.push(llanta);
        actualizarTablaLlantas();
        
        // Forzar la actualizaci√≥n de la sugerencia
        setTimeout(() => {
            calcularSugerenciaUnidad();
            document.getElementById('resultadoSugerencia').classList.remove('d-none');
        }, 100);

        // Limpiar campos
        document.getElementById('sugestionCantidad').value = '1';
    }

    // Funci√≥n para eliminar un tipo de llanta
    function eliminarTipoLlanta(index) {
        llantasAgregadas.splice(index, 1);
        actualizarTablaLlantas();
        calcularSugerenciaUnidad();
    }

    // Funci√≥n para enviar datos a la hoja de SheetDB
    async function enviarDatosAHojaApartados(pedido) {
        try {
            // Validar que pedido tenga todos los campos necesarios
            if (!pedido || !pedido.detallesLlantas) {
                throw new Error('Datos de pedido incompletos');
            }

            // Agrupar llantas por descripci√≥n
            const llantasPorTipo = pedido.detallesLlantas.reduce((grupos, llanta) => {
                const tipo = llanta.descripcion;
                if (!grupos[tipo]) {
                    grupos[tipo] = {
                        cantidad: 0,
                        volumen: 0,
                        peso: 0
                    };
                }
                grupos[tipo].cantidad += parseInt(llanta.cantidad) || 0;
                grupos[tipo].volumen += parseFloat(llanta.volumen) || 0;
                grupos[tipo].peso += parseFloat(llanta.peso) || 0;
                return grupos;
            }, {});

            // Preparar las descripciones y cantidades separadas
            const descripciones = [];
            const cantidades = [];
            const volumenes = [];
            const pesos = [];

            Object.entries(llantasPorTipo).forEach(([descripcion, datos]) => {
                descripciones.push(descripcion);
                cantidades.push(datos.cantidad.toString());
                volumenes.push(datos.volumen.toFixed(2));
                pesos.push(datos.peso.toFixed(2));
            });

            // Formatear valores totales
            const totalLlantas = cantidades.reduce((sum, cant) => sum + parseInt(cant), 0);
            const volumenTotal = volumenes.reduce((sum, vol) => sum + parseFloat(vol), 0);
            const pesoTotal = pesos.reduce((sum, peso) => sum + parseFloat(peso), 0);

            // Formatear las descripciones y cantidades con saltos de l√≠nea
            const descripcionLlantas = descripciones.map((desc, i) => 
                `${cantidades[i]}x ${desc}`
            ).join('\n');
            const volumenFormateado = volumenTotal.toFixed(2);
            const pesoFormateado = pesoTotal.toFixed(2);

            // Formatear los datos como lo requiere SheetDB - usando los nombres exactos de las columnas
            const datosParaEnviar = [{
                "Fecha": pedido.fecha,
                "Unidad": pedido.unidad,
                "Econ√≥mico": pedido.economico,
                "Llantas": totalLlantas.toString(),
                "Descripcion": descripcionLlantas,
                "Volumen": volumenFormateado,
                "Peso": pesoFormateado,
                "Detalles": JSON.stringify(llantasPorTipo) // Guardamos los detalles completos por si son necesarios despu√©s
            }];
            
            console.log('Datos a enviar:', datosParaEnviar);

            const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=Apartados', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({
                    data: datosParaEnviar
                })
            });

            if (!response.ok) {
                const responseText = await response.text();
                console.error('Error en la respuesta:', response.status, responseText);
                throw new Error(`Error al enviar datos: ${response.status} ${responseText}`);
            }

            const responseData = await response.json();
            console.log('Respuesta exitosa:', responseData);

        } catch (error) {
            console.error('Error detallado:', error);
            console.error('Stack trace:', error.stack);
            alert('Hubo un error al enviar los datos a la hoja de c√°lculo. Por favor, revisa la consola para m√°s detalles.');
            throw error; // Re-lanzar el error para que podamos verlo en la consola
        }
    }

    // Funci√≥n helper para formatear la fecha
    function obtenerFechaFormateada() {
        const fecha = new Date();
        const dia = fecha.getDate().toString().padStart(2, '0');
        const mes = (fecha.getMonth() + 1).toString().padStart(2, '0');
        const a√±o = fecha.getFullYear();
        return `${dia}/${mes}/${a√±o}`;
    }

    // Funci√≥n para apartar un bloque y enviarlo a Apartados
    async function apartarBloque(unidad, economico, llantas, descripcion, volumen, peso) {
        const fecha = obtenerFechaFormateada();
        
        // Crear el objeto con los datos del pedido confirmado
        const pedidoConfirmado = {
            Fecha: fecha,
            Unidad: unidad,
            Econ√≥mico: economico,
            Llantas: llantas,
            Descripci√≥n: descripcion,
            Volumen: volumen,
            Peso: peso
        };

        try {
            // Enviar los datos a la hoja de c√°lculo de Apartados
            const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=Apartados', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    data: [pedidoConfirmado]
                })
            });

            if (!response.ok) throw new Error('Error al guardar en Apartados');

            // Actualizar la vista de pedidos Apartados
            await fetchPedidosApartados();
            
            // Mostrar mensaje de √©xito
            alert('Bloque apartado y enviado a Apartados exitosamente');
            
            // Cambiar a la pesta√±a de Apartados
            document.querySelector('[data-tab="pedidos-Apartados"]').click();
        } catch (error) {
            alert('Error al apartar el bloque: ' + error.message);
        }
    }

    // Funci√≥n para apartar una unidad y enviarla a Apartados
    async function enviarDatosAHojaConfirmados(pedido) {
        console.log('Enviando datos a hoja confirmados:', pedido);
        
        try {
            // Validar datos del pedido
            if (!pedido || 
                !pedido.Econ√≥mico || 
                !pedido.Nombre || 
                !pedido.Llantas || 
                !pedido.Unidad) {
                console.error('Datos del pedido incompletos:', pedido);
                throw new Error('Datos de pedido incompletos');
            }

            // Preparar los datos para enviar y asegurar que la descripci√≥n use \n literal
            const descripcionLimpia = pedido.Descripcion ? 
                pedido.Descripcion.replace(/\\n/g, '\n') : '';

            const datosPedido = {
                Fecha: pedido.Fecha || new Date().toLocaleDateString(),
                Unidad: pedido.Unidad,
                Econ√≥mico: pedido.Econ√≥mico,
                Nombre: pedido.Nombre,
                Llantas: pedido.Llantas,
                Descripcion: descripcionLimpia,
                Volumen: pedido.Volumen || '0.00',
                Peso: pedido.Peso || '0.00'
            };

            console.log('Datos preparados para enviar:', datosPedido);

            // Los datos ya vienen preparados en el formato correcto
            const datosParaEnviar = datosPedido;

            console.log('Datos preparados para enviar:', datosParaEnviar);

            // Enviar a SheetDB
            const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=Apartados', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    data: [datosParaEnviar]
                })
            });

            if (!response.ok) {
                throw new Error(`Error al enviar datos: ${response.status}`);
            }

            const resultado = await response.json();
            console.log('Datos enviados exitosamente:', resultado);
            
            // Agregar a la lista de pedidos apartados
            if (!window.pedidosApartados) {
                window.pedidosApartados = [];
            }
            window.pedidosApartados.push(datosParaEnviar);

            return resultado;

        } catch (error) {
            console.error('Error en enviarDatosAHojaApartados:', error);
            throw new Error(`Error al enviar datos: ${error.message}`);
        }
    }

    function calcularDistribucionLlantas(llantasOriginales, cantidadObjetivo) {
        console.log('Calculando distribuci√≥n para:', {
            llantasOriginales,
            cantidadObjetivo
        });

        // Crear una copia de las llantas originales y su cantidad disponible
        let llantasDisponibles = llantasOriginales.map(l => ({...l}));
        const distribucion = llantasOriginales.map(l => ({...l, cantidad: 0}));
        let llantasPorAsignar = cantidadObjetivo;

        // Procesar cada tipo de llanta en orden
        for (let i = 0; i < llantasDisponibles.length && llantasPorAsignar > 0; i++) {
            // Ver cu√°ntas llantas podemos tomar de este tipo
            const disponibles = llantasDisponibles[i].cantidad;
            const aAsignar = Math.min(llantasPorAsignar, disponibles);

            if (aAsignar > 0) {
                distribucion[i].cantidad = aAsignar;
                llantasDisponibles[i].cantidad -= aAsignar;
                llantasPorAsignar -= aAsignar;

                console.log(`Asignadas ${aAsignar} llantas del tipo ${distribucion[i].descripcion}`);
            }
        }

        // Solo retornar los tipos de llantas que se usaron
        return distribucion.filter(l => l.cantidad > 0);
    }

    // Funci√≥n para limpiar la pesta√±a de distribuci√≥n manteniendo la estructura
    function limpiarPestanaDistribucion() {
        // Limpiar tabla de llantas manteniendo la estructura
        const tabla = document.getElementById('tablaDistribucionSugerida');
        if (tabla) {
            // Mantener el encabezado si existe y limpiar solo el contenido
            const filas = tabla.rows;
            while (filas.length > 0) {
                tabla.deleteRow(0);
            }
        }

        // Reiniciar contadores y totales (usar formato local y dataset)
        const elVol = document.getElementById('totalVolumenLlantas');
        const elPes = document.getElementById('totalPesoLlantas');
        if (elVol) { elVol.dataset.value = 0; elVol.textContent = formatNumber(0,3); }
        if (elPes) { elPes.dataset.value = 0; elPes.textContent = formatNumber(0,3); }

        // Limpiar el bot√≥n de apartar
        const botonApartar = document.querySelector('#botonesDistribucionMultiple button');
        if (botonApartar) {  
            botonApartar.dataset.unidades = '[]';
        }

        // Limpiar variables globales 
        llantasAgregadas = [];
        
        // Ocultar secciones de resultados
        const contenedorDetalles = document.getElementById('unidadSugeridaDetalles');
        if (contenedorDetalles) {
            contenedorDetalles.innerHTML = '';
        }

        // Colapsar el acorde√≥n de distribuci√≥n m√∫ltiple
        const acordeon = document.getElementById('collapseDistribucionMultiple');
        if (acordeon) {
            acordeon.classList.remove('show');
        }

        // Actualizar las unidades disponibles
        actualizarUnidadesDisponibles();
    }

    async function apartarDistribucionCompleta(button) {
        try {
            // Obtener las unidades del atributo data
            const unidades = button.dataset.unidades ? JSON.parse(button.dataset.unidades) : [];
            
            if (!Array.isArray(unidades) || unidades.length === 0) {
                throw new Error('No hay unidades para apartar');
            }

            // Solicitar el nombre del cliente/responsable
            const nombre = await Swal.fire({
                title: 'Nombre del cliente',
                input: 'text',
                inputLabel: 'Por favor, ingrese el nombre del cliente del pedido',
                inputPlaceholder: 'Nombre completo',
                showCancelButton: true,
                inputValidator: (value) => {
                    if (!value) {
                        return 'Debe ingresar un nombre';
                    }
                }
            });

            if (!nombre.isConfirmed || !nombre.value) {
                return;
            }

            // Formatear los datos para el resumen
            const resumen = unidades.map(u => {
                const volumen = Number(u.volumen || u.volumenAsignado || 0);
                const peso = Number(u.peso || u.pesoAsignado || 0);
                return `- ${u.unidad} (${u.economico}): ${u.llantasEstimadas} llantas, ${volumen.toFixed(2)} m¬≥, ${peso.toFixed(2)} kg`;
            }).join('\\n');

            const confirmar = await Swal.fire({
                title: '¬øConfirmar Distribuci√≥n?',
                html: `
                    <div class="text-start">
                        <p><strong>Cliente:</strong> ${nombre.value}</p>
                        <p><strong>Unidades a apartar:</strong></p>
                        <pre>${resumen}</pre>
                    </div>
                `,
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: 'S√≠, Apartar',
                cancelButtonText: 'Cancelar'
            });

            if (!confirmar.isConfirmed) {
                return;
            }

            // Deshabilitar el bot√≥n mientras se procesa
            button.disabled = true;
            button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Apartando...';

            console.log('Iniciando apartado de distribuci√≥n completa:', unidades);

            // Procesar cada unidad en secuencia
            for (const unidad of unidades) {
                console.log('Apartando unidad:', unidad.economico);
                
                // Formatear la descripci√≥n de las llantas.
                // Priorizar las descripciones calculadas por la Distribuci√≥n Sugerida
                let descripcionFormateada = '';

                // Si la unidad ya trae descripciones (desde calcularDistribucionMultiple), usarla
                if (unidad.descripciones && unidad.descripciones.toString().trim() !== '') {
                    // unidad.descripciones ya viene con saltos de l√≠nea '\n'
                    const lineas = unidad.descripciones.toString().split('\n').map(s => s.trim()).filter(Boolean);
                    // Asegurarse de que cada l√≠nea tenga el formato '‚Ä¢ {cantidad}x {descripcion}'
                    descripcionFormateada = lineas.map(l => l.startsWith('‚Ä¢') ? l : `‚Ä¢ ${l}`).join('\n');
                    console.log('Usando descripciones desde la distribuci√≥n sugerida:', descripcionFormateada);
                } else {
                    // Fallback: intentar leer la tabla de llantas del bloque (si existe)
                    const tablaLlantas = document.getElementById('tablaLlantasBloque');
                    if (tablaLlantas) {
                        const filas = Array.from(tablaLlantas.getElementsByTagName('tr'));
                        const descripciones = [];
                        for (const fila of filas) {
                            const celdas = fila.getElementsByTagName('td');
                            if (celdas.length >= 2) {
                                const cantidad = parseInt(celdas[0].textContent.trim()) || 0;
                                const descripcionCompleta = celdas[1].textContent.trim();
                                const descripcion = descripcionCompleta.split(' ').slice(1).join(' ');
                                if (cantidad && descripcion) descripciones.push(`‚Ä¢ ${cantidad}x ${descripcion}`);
                            }
                        }
                        descripcionFormateada = descripciones.join('\n');
                        console.log('Descripciones obtenidas de la tabla (fallback):', descripcionFormateada);
                    } else {
                        console.warn('No se encontr√≥ la tabla de llantas del bloque y la unidad no trae descripciones');
                    }
                }

                // Construir arreglo de llantas para el env√≠o: preferir unidad.llantas si existe
                let llantas = [];
                if (Array.isArray(unidad.llantas) && unidad.llantas.length > 0) {
                    llantas = unidad.llantas.map(l => ({
                        codigo: l.codigo || '',
                        descripcion: l.descripcion || l.detalle || '',
                        cantidad: parseInt(l.cantidad) || parseInt(l.cant) || 0
                    })).filter(x => x.cantidad > 0);
                } else if (document.getElementById('tablaLlantasBloque')) {
                    const tablaLlantas = document.getElementById('tablaLlantasBloque');
                    llantas = Array.from(tablaLlantas.rows)
                        .filter(row => row.cells.length >= 4)
                        .map(row => ({
                            codigo: row.cells[0].textContent.trim(),
                            descripcion: row.cells[1].textContent.trim().split(' ').slice(1).join(' '),
                            cantidad: parseInt(row.cells[3].textContent) || 0
                        }))
                        .filter(l => l.cantidad > 0);
                }

                if (llantas.length === 0 && descripcionFormateada === '') {
                    throw new Error('No se encontraron llantas v√°lidas ni descripciones para procesar');
                }

                // Procesar las llantas para obtener descripciones finales (usar descripcionFormateada si existe)
                const descripcionesLlantas = descripcionFormateada || llantas.map(l => `‚Ä¢ ${l.cantidad}x ${l.descripcion}`).join('\n');

                // Crear el pedido para esta unidad con todos los datos necesarios
                const pedido = {
                    Fecha: new Date().toLocaleString('es-MX', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    }),
                    Unidad: unidad.unidad,
                    Econ√≥mico: unidad.economico,
                    Nombre: nombre.value,
                    Llantas: unidad.llantasEstimadas || 0,
                    Descripcion: descripcionesLlantas || '‚Ä¢ Sin llantas especificadas',
                    Volumen: Number(unidad.volumen || unidad.volumenAsignado || 0).toFixed(2),
                    Peso: Number(unidad.peso || unidad.pesoAsignado || 0).toFixed(2)
                };
                
                console.log('Pedido creado con descripci√≥n:', pedido.Descripcion);
                
                console.log('Pedido a enviar:', pedido);

                try {
                    // Enviar a la hoja de confirmados
                    await enviarDatosAHojaConfirmados(pedido);
                    console.log('Unidad apartada exitosamente:', unidad.economico);
                } catch (errorUnidad) {
                    console.error('Error al apartar unidad:', unidad.economico, errorUnidad);
                    throw new Error(`Error al apartar unidad ${unidad.economico}: ${errorUnidad.message}`);
                }
            }

            // Actualizar la interfaz
            await fetchPedidosConfirmados();
            
            // Limpiar la pesta√±a completa manteniendo la estructura
            limpiarPestanaDistribucion();
            
            // Mostrar mensaje de √©xito
            await Swal.fire({
                icon: 'success',
                title: 'Distribuci√≥n apartada exitosamente',
                text: `Se han apartado exitosamente ${unidades.length} unidades para este pedido.`,
                confirmButtonText: 'Aceptar'
            });

            // Cambiar a la pesta√±a de apartados
            const tabApartados = document.querySelector('[data-tab="pedidos-Apartados"]');
            if (tabApartados) {
                tabApartados.click();
            }

        } catch (error) {
            console.error('Error al apartar distribuci√≥n:', error);
            alert('Error: ' + error.message);
        } finally {
            // Rehabilitar el bot√≥n
            button.disabled = false;
            button.innerHTML = '<i class="bi bi-box-arrow-right"></i> Apartar Distribuci√≥n Completa';
            
            // Actualizar c√°lculos
            calcularSugerenciaUnidad();
        }
    }

    async function apartarUnidadConDetalles(codigoEconomico, llantas, volumenTotal, pesoTotal) {
        try {
            console.log('Iniciando apartarUnidadConDetalles con:', {
                codigoEconomico,
                llantas,
                volumenTotal,
                pesoTotal
            });

            // Validar c√≥digo econ√≥mico
            if (!codigoEconomico || codigoEconomico.trim() === '') {
                throw new Error('El c√≥digo econ√≥mico es requerido');
            }

            // Buscar la unidad en la flota
            const unidadEncontrada = flota.find(u => 
                String(u.economico).trim().toLowerCase() === String(codigoEconomico).trim().toLowerCase() ||
                String(u.codigo).trim().toLowerCase() === String(codigoEconomico).trim().toLowerCase()
            );

            if (!unidadEncontrada) {
                throw new Error(`No se encontr√≥ la unidad con c√≥digo econ√≥mico: ${codigoEconomico}`);
            }

            // Asegurarse de que flota est√© disponible
            if (!flota || !Array.isArray(flota)) {
                console.error('Error: flota no est√° definida o no es un array');
                alert('Error al buscar la unidad: La flota no est√° disponible');
                return;
            }

            // Si codigoEconomico es un objeto, extraer el c√≥digo
            let codigoFinal = codigoEconomico;
            if (typeof codigoEconomico === 'object' && codigoEconomico !== null) {
                codigoFinal = codigoEconomico.codigo || codigoEconomico.economico;
            }

            // Normalizar el c√≥digo econ√≥mico
            const codigoNormalizado = codigoFinal.toString().trim().toLowerCase();
            console.log('C√≥digo normalizado:', codigoNormalizado);

            // Buscar la unidad en la flota
            const unidad = flota.find(u => {
                const economicoUnidad = (u.economico || '').toString().trim().toLowerCase();
                const codigoUnidad = (u.codigo || '').toString().trim().toLowerCase();
                return economicoUnidad === codigoNormalizado || codigoUnidad === codigoNormalizado;
            });

            if (!unidad) {
                console.error('No se encontr√≥ la unidad con c√≥digo:', codigoNormalizado);
                alert('No se encontr√≥ la unidad en la flota');
                return;
            }

            // Guardar la unidad como unidadParam para uso en el template
            const unidadParam = unidad;

            // Solicitar el nombre del cliente que hace el pedido usando SweetAlert2
            const nombreResult = await Swal.fire({
                title: 'Nombre del cliente',
                input: 'text',
                inputLabel: 'Por favor, ingrese el nombre del cliente que hace el pedido',
                inputPlaceholder: 'Nombre completo',
                showCancelButton: true,
                confirmButtonText: 'Continuar',
                cancelButtonText: 'Cancelar',
                inputValidator: (value) => {
                    if (!value) {
                        return 'Debe ingresar un nombre';
                    }
                }
            });

            if (!nombreResult.isConfirmed || !nombreResult.value) {
                throw new Error('Se requiere ingresar un nombre para el pedido');
            }

            const nombrePedido = nombreResult.value;

            // Confirmar la operaci√≥n (agregada opci√≥n 'Agregar otro cliente')
            const result = await Swal.fire({
                icon: 'question',
                title: '¬øConfirmar pedido?',
                html: `
                    <p>Cliente: <strong>${nombrePedido}</strong></p>
                    <p>¬øEst√° seguro que desea procesar este pedido?</p>
                `,
                showCancelButton: true,
                showDenyButton: true,
                denyButtonText: 'Agregar otro cliente',
                confirmButtonText: 'S√≠, procesar',
                cancelButtonText: 'Cancelar'
            });

            // Si eligi√≥ 'Agregar otro cliente', agregar a la burbuja de la unidad y salir
            if (result.isDenied) {
                try {
                    const llantasObj = { llantas: Array.isArray(llantas) ? llantas : [], volumen: Number(volumenTotal) || 0, peso: Number(pesoTotal) || 0 };
                    agregarClienteABurbuja(numeroEconomico || (unidad && unidad.economico), nombrePedido, llantasObj);
                    await Swal.fire({ icon: 'success', title: 'Cliente agregado', text: 'Se a√±adi√≥ el cliente a la unidad para seguir agregando.', timer: 1400, showConfirmButton: false });
                } catch (e) { console.warn('Error agregando cliente a burbuja:', e); }
                return;
            }

            if (!result.isConfirmed) {
                return;
            }

            // Funci√≥n auxiliar para limpiar las tablas
            function limpiarTablas() {
                // Limpiar tabla de llantas  
                const tablaLlantas = document.getElementById('tablaLlantasSeleccionadas');
                if (tablaLlantas && tablaLlantas.getElementsByTagName('tbody')[0]) {
                    tablaLlantas.getElementsByTagName('tbody')[0].innerHTML = '';
                }

                // Limpiar tabla de unidades sugeridas
                const tablaSugerencias = document.getElementById('tablaUnidadesSugeridasBusqueda');
                if (tablaSugerencias) {
                    tablaSugerencias.innerHTML = '';
                }

                // Limpiar resultados de b√∫squeda
                const resultadosBusqueda = document.getElementById('resultadosBusqueda');
                if (resultadosBusqueda) {
                    resultadosBusqueda.innerHTML = `
                        <div class="alert alert-success">
                            <h5 class="mb-0">
                                <i class="bi bi-check-circle me-2"></i>
                                Unidad apartada exitosamente
                            </h5>
                            <p class="mb-0 mt-2">
                                Unidad: ${unidadParam.codigo || unidadParam.economico}<br>
                                Apartada por: ${nombrePedido}
                            </p>
                        </div>
                    `;
                }

                // Limpiar campo de b√∫squeda
                const campoBusqueda = document.getElementById('busquedaBloque');
                if (campoBusqueda) {
                    campoBusqueda.value = '';
                }
            }

            console.log('Datos recibidos:', { codigoEconomico, llantas, volumenTotal, pesoTotal });
            console.log('Datos de la unidad encontrada:', unidad);
            
            // Obtener los datos actuales del bloque seleccionado
            const bloqueSeleccionado = window.bloqueSeleccionado || {};
            const llantasBloque = Array.isArray(llantas) ? llantas : (bloqueSeleccionado.llantas || []);
            
            // Obtener la fecha actual formateada
            const fecha = obtenerFechaFormateada();

            // Extraer los datos de la unidad considerando todas las posibles propiedades
            const nombreUnidad = unidad.unidad || '';  // El nombre de la unidad est√° en la propiedad 'unidad'
            // Intentar obtener el n√∫mero econ√≥mico de todas las posibles propiedades
            const numeroEconomico = (unidad.economico || unidad.codigo || '').toString().trim();
            
            // Validar que tengamos todos los datos necesarios
            if (!numeroEconomico) {
                throw new Error('No se pudo obtener el n√∫mero econ√≥mico de la unidad');
            }

            if (llantasBloque.length === 0) {
                throw new Error('No se han agregado llantas al pedido');
            }
            
            console.log('Datos procesados de la unidad:', { nombreUnidad, numeroEconomico });
            
            // Preparar los datos exactamente como los necesita la hoja de c√°lculo
            console.log('Enviando datos de la unidad:', {
                nombre: nombreUnidad,
                economico: numeroEconomico,
                solicitante: nombrePedido
            });

            // Asegurarse de que nombreUnidad est√© definido
            const nombreUnidadFinal = nombreUnidad || unidad.nombre || unidad.tipo || ''; // No mostrar KENWORTH por defecto
            
            const datosParaEnviar = {
                data: [{
                    "Fecha": fecha,
                    "Unidad": nombreUnidadFinal,
                    "Econ√≥mico": numeroEconomico,
                    "Nombre": nombrePedido,
                    "Llantas": llantasBloque.reduce((sum, l) => sum + (parseInt(l.cantidad) || 0), 0),
                    "Descripcion": llantasBloque.map(l => `${l.cantidad} x ${l.descripcion}`).join(', '),
                    "Volumen": Number(bloqueSeleccionado.volumenTotal || volumenTotal || 0).toFixed(2),
                    "Peso": Number(bloqueSeleccionado.pesoTotal || pesoTotal || 0).toFixed(2)
                }]
            };

            console.log('Datos a enviar:', datosParaEnviar);

            // Enviar los datos a la hoja de c√°lculo de Apartados
            const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=Apartados', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(datosParaEnviar)
            });

            if (!response.ok) throw new Error('Error al guardar en Apartados');

            // Actualizar la vista de pedidos Apartados
            await fetchPedidosApartados();
            
            // Limpiar todas las tablas y mostrar mensaje de confirmaci√≥n
            limpiarTablas();
            
            // Restablecer las variables globales
            window.bloqueSeleccionado = null;
            window.llantasBloque = [];
            
            // Mostrar mensaje de √©xito
            alert('Unidad apartada y enviada a Apartados exitosamente');
            
            // Cambiar a la pesta√±a de Apartados
            document.querySelector('[data-tab="pedidos-Apartados"]').click();

            // Limpiar la lista de llantas agregadas
            llantasAgregadas = [];
            actualizarTablaLlantas();
            
            // Ocultar la secci√≥n de unidad sugerida
            document.getElementById('resultadoSugerencia').classList.add('d-none');

        } catch (error) {
            console.error('Error al apartar la unidad:', error);
            alert('Error al apartar la unidad: ' + error.message);
        }
    }
    
    // Funci√≥n para liberar una unidad
    async function liberarUnidad(index) {
        if (confirm('¬øEst√° seguro de que desea liberar esta unidad?')) {
            try {
                const pedidoAEliminar = pedidosApartados[index];
                const numeroEconomico = pedidoAEliminar.Econ√≥mico || pedidoAEliminar.Economico || pedidoAEliminar.economico;
                
                if (!numeroEconomico) {
                    throw new Error('No se pudo obtener el n√∫mero econ√≥mico del pedido');
                }
                
                // Eliminar de SheetDB usando el n√∫mero econ√≥mico como identificador
                const response = await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey/Econ√≥mico/${numeroEconomico}?sheet=Apartados`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });   

                if (!response.ok) {
                    throw new Error(`Error al eliminar de la hoja de c√°lculo: ${response.status}`);
                }

                // Si la eliminaci√≥n en SheetDB fue exitosa, eliminar del array local
                pedidosApartados.splice(index, 1);
                actualizarTablaPedidosApartados();
                
                // Mostrar mensaje de √©xito
                alert('La unidad ha sido liberada exitosamente');
            } catch (error) {
                console.error('Error al liberar la unidad:', error);
                alert('Hubo un error al liberar la unidad. Por favor, intente nuevamente.');
            }
        }
    }
    
    // Funci√≥n para cargar datos desde SheetDB
    async function fetchPedidosConfirmados() {
        try {
            const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=Apartados');
            if (!response.ok) {
                throw new Error(`Error al cargar pedidos confirmados: ${response.status}`);
            }
            const data = filterMeaningfulRows(await response.json());
            console.log('Pedidos confirmados actualizados:', data);
            
            // Actualizar la variable global de pedidos confirmados
            window.pedidosApartados = data || [];
            
            // Actualizar la tabla de pedidos
            actualizarTablaPedidosApartados();
            
            return data;
        } catch (error) {
            console.error('Error al cargar pedidos confirmados:', error);
            alert('Error al actualizar los pedidos confirmados: ' + error.message);
            throw error;
        }
    }

    async function cargarDatosDesdeSheetDB() {
        try {
            const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=Apartados');
            
            if (!response.ok) {
                throw new Error(`Error al cargar datos: ${response.status}`);
            }

            const data = filterMeaningfulRows(await response.json());
            console.log('Datos cargados:', data); // Para debugging
            
            // Convertir los datos de SheetDB al formato de pedidosApartados
            pedidosApartados = data.map(row => {
                console.log('Procesando fila:', row); // Para debugging
                
                // Crear el detalle de llantas incluyendo la descripci√≥n completa
                const descripcionLlanta = row.Descripcion || ''; // Nota: sin tilde
                const detallesLlantas = [{
                    descripcion: descripcionLlanta,
                    cantidad: parseInt(row.Llantas) || 0,
                    volumen: parseFloat(row.Volumen) || 0,
                    peso: parseFloat(row.Peso) || 0
                }];

                return {
                    fecha: row.Fecha || '',
                    unidad: row.Unidad || '',
                    economico: row.Econ√≥mico || '', // Nota: sin tilde
                    detallesLlantas: detallesLlantas,
                    descripcionCompleta: descripcionLlanta,
                    volumenTotal: parseFloat(row.Volumen) || 0,
                    pesoTotal: parseFloat(row.Peso) || 0
                };
            });

            console.log('Datos procesados:', pedidosApartados); // Para debugging
            actualizarTablaPedidosApartados();
            
        } catch (error) {
            console.error('Error al cargar datos desde SheetDB:', error);
        }
    }

    // Funci√≥n para formatear la descripci√≥n con vi√±etas
    function formatearDescripcionConVinetas(descripcion) {
        if (!descripcion) return '';
        // Aceptar tanto separadores por coma, salto de l√≠nea o <br>, y mostrar cualquier item
        const parts = String(descripcion).split(/<br>|,|\n/).map(item => item.trim()).filter(Boolean);
        return parts.map(item => item.startsWith('‚Ä¢') ? item : `‚Ä¢ ${item}`).join('<br>');
    }

    // Funci√≥n para buscar en pedidos Apartados
    function buscarPedidoConfirmado() {
        const busqueda = document.getElementById('busquedaApartados').value.toLowerCase();
        actualizarTablaPedidosApartados(busqueda);
    }

    // Funci√≥n para actualizar la tabla de pedidos Apartados
    function actualizarTablaPedidosApartados(filtro = '') {
        const tbody = document.getElementById('tablaPedidosApartados');
        if (!tbody) return;
        tbody.innerHTML = '';
        
        if (!Array.isArray(pedidosApartados)) return;
        
        // Ordenar pedidos: primero los que coinciden con la b√∫squeda
        const pedidosOrdenados = [...pedidosApartados].sort((a, b) => {
            const aEconomico = (a['Econ√≥mico'] || '').toLowerCase();
            const bEconomico = (b['Econ√≥mico'] || '').toLowerCase();
            const aMatch = aEconomico.includes(filtro.toLowerCase());
            const bMatch = bEconomico.includes(filtro.toLowerCase());
            if (aMatch && !bMatch) return -1;
            if (!aMatch && bMatch) return 1;
            return new Date(b.Fecha || 0) - new Date(a.Fecha || 0); // ordenar por fecha si no hay coincidencia
        });
        
    // Exponer la lista ordenada para el flujo de edici√≥n
    window._pedidosOrdenadosForEdit = pedidosOrdenados;
    console.log('Pedidos a mostrar:', pedidosOrdenados);
        
        pedidosOrdenados.forEach((pedido, index) => {
             // Asegurarse de que los campos existan y tengan el formato correcto
             let fecha = pedido.Fecha || '';
             if (!isNaN(fecha)) {
                 // Si la fecha es un n√∫mero, la convertimos a objeto Date y la formateamos
                 const fechaObj = new Date(fecha);
                 if (!isNaN(fechaObj.getTime())) {
                     fecha = obtenerFechaFormateada();
                 }
            }
            
            // Extraer todos los campos necesarios y asegurar que tengan valores v√°lidos
            const nombreUnidad = pedido.Unidad || pedido.unidad || ''; // No mostrar KENWORTH por defecto
            const numEconomico = pedido['Econ√≥mico'] || ''; // Usar la versi√≥n exacta con tilde
            const nombre = pedido.Nombre || '';
            const llantas = pedido.Llantas || '0';
            const descripcion = pedido.Descripcion || '';
            const volumen = pedido.Volumen || '0.00';
            const peso = pedido.Peso || '0.00';

            console.log('Procesando pedido:', {
                fecha,
                unidad: nombreUnidad, // Usar nombreUnidad en lugar de unidad
                numEconomico,
                nombre,
                llantas,
                descripcion,
                volumen,
                peso
            });

            // Formatear la descripci√≥n con vi√±etas si es necesario
            const descripcionFormateada = descripcion.includes('‚Ä¢') ? descripcion : formatearDescripcionConVinetas(descripcion);

            // Crear la fila de la tabla
            const tr = document.createElement('tr');
    
            // Crear la celda de descripci√≥n con estilo
            tr.innerHTML = `
                <td class="text-center">${fecha}</td>
                <td>${nombreUnidad}</td>
                <td class="text-center">${numEconomico}</td>
                <td>${nombre}</td>
                <td class="text-center">${llantas}</td>
                <td style="white-space: pre-line; line-height: 1.5;">${descripcionFormateada}</td>
                <td class="text-end">${volumen} m¬≥</td>
                <td class="text-end">${peso} kg</td>
                <td class="text-center">
                    <button class="btn btn-secondary btn-sm me-1" onclick="abrirEditarPedido(${index})">
                        <i class="bi bi-pencil"></i> Editar
                    </button>
                    <button class="btn btn-danger btn-sm" onclick="liberarUnidad(${index})">
                        <i class="bi bi-x-circle"></i> Liberar
                   </button>
              </td>
         `;
         tbody.appendChild(tr);
        });
    }
    // Funciones para editar pedidos Apartados
    function abrirEditarPedido(index) {
        const pedidosOrdenados = window._pedidosOrdenadosForEdit || [];
        const pedido = pedidosOrdenados[index];
        if (!pedido) return alert('Pedido no encontrado para editar');

        // Rellenar campos del modal
        document.getElementById('editPedidoFecha').value = pedido.Fecha || '';
        document.getElementById('editPedidoUnidad').value = pedido.Unidad || pedido.unidad || '';
        document.getElementById('editPedidoEconomico').value = pedido['Econ√≥mico'] || pedido.Economico || '';
        document.getElementById('editPedidoNombre').value = pedido.Nombre || '';
        document.getElementById('editPedidoLlantas').value = pedido.Llantas || '';
        document.getElementById('editPedidoDescripcion').value = pedido.Descripcion || '';
        document.getElementById('editPedidoVolumen').value = pedido.Volumen || '';
        document.getElementById('editPedidoPeso').value = pedido.Peso || '';

        // Guardar una clave temporal en dataset para localizar el pedido original
        const modal = document.getElementById('editarPedidoModal');
        modal.dataset._editingKey = JSON.stringify({
            Fecha: pedido.Fecha,
            Economico: pedido['Econ√≥mico'] || pedido.Economico || '',
            Nombre: pedido.Nombre || '',
            __id: pedido.id || pedido.ID || ''
        });
        modal.style.display = 'block';
    }

    function cerrarEditarPedidoModal() {
        const modal = document.getElementById('editarPedidoModal');
        if (modal) modal.style.display = 'none';
    }

    async function guardarPedidoEditado() {
        const modal = document.getElementById('editarPedidoModal');
        if (!modal) return;
        const key = JSON.parse(modal.dataset._editingKey || '{}');

        const nueva = {
            Fecha: document.getElementById('editPedidoFecha').value,
            Unidad: document.getElementById('editPedidoUnidad').value,
            'Econ√≥mico': document.getElementById('editPedidoEconomico').value,
            Nombre: document.getElementById('editPedidoNombre').value,
            Llantas: String(document.getElementById('editPedidoLlantas').value || '0'),
            Descripcion: document.getElementById('editPedidoDescripcion').value,
            Volumen: String(document.getElementById('editPedidoVolumen').value || '0'),
            Peso: String(document.getElementById('editPedidoPeso').value || '0')
        };

        // Buscar √≠ndice en pedidosApartados usando id si existe, si no por combinaci√≥n de campos
        let idx = -1;
        if (key.__id) {
            idx = pedidosApartados.findIndex(p => (p.id == key.__id) || (p.ID == key.__id));
        }
        if (idx === -1) {
            idx = pedidosApartados.findIndex(p => {
                const eco = p['Econ√≥mico'] || p.Economico || p.economico || '';
                return (String(p.Fecha || '') === String(key.Fecha || '')) &&
                       (String(eco) === String(key.Economico || key.Economico)) &&
                       (String(p.Nombre || '') === String(key.Nombre || ''));
            });
        }

        if (idx === -1) {
            // Si no existe, s√≥lo cerrar y mostrar mensaje
            cerrarEditarPedidoModal();
            alert('No se pudo localizar el pedido original para guardar. Los cambios se aplicaron en la vista temporal.');
            // Agregar temporalmente a la lista
            pedidosApartados.push(nueva);
            actualizarTablaPedidosApartados();
            return;
        }

        // Actualizar en memoria
        pedidosApartados[idx] = { ...pedidosApartados[idx], ...nueva };
        actualizarTablaPedidosApartados();
        cerrarEditarPedidoModal();

        // Intentar persistir en SheetDB con varios enfoques y logging para depuraci√≥n
        const possibleId = pedidosApartados[idx].id || pedidosApartados[idx].ID || pedidosApartados[idx]._id || null;
        const economicoVal = nueva['Econ√≥mico'] || nueva.Economico || nueva.economico || pedidosApartados[idx]['Econ√≥mico'] || pedidosApartados[idx].Economico || pedidosApartados[idx].economico || '';

        let persisted = false;

        async function tryFetch(url, options) {
            try {
                console.log('Intentando petici√≥n a:', url, options);
                const r = await fetch(url, options);
                const text = await r.text();
                console.log('Respuesta status:', r.status, 'body:', text);
                return { ok: r.ok, status: r.status, body: text };
            } catch (err) {
                console.warn('Fetch fallo:', err);
                return { ok: false, error: err };
            }
        }

        // Estrategia A: PATCH por id (si hay id)
        if (possibleId) {
            const url = `https://sheetdb.io/api/v1/gdn5wqo960cey/id/${encodeURIComponent(possibleId)}`;
            const opts = {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ data: nueva })
            };
            const res = await tryFetch(url, opts);
            if (res.ok) {
                persisted = true;
                mostrarMensaje('Pedido actualizado en servidor (por id)', 'success');
                try { mostrarMensaje('Servidor respondi√≥: ' + (res.body || 'OK'), 'success'); } catch(e){ console.warn(e); }
                try { await fetchPedidosApartados(); } catch(e) { console.warn('No se pudo recargar pedidos:', e); }
            }
        }

        // Estrategia B: PATCH por campo econ√≥mico (usar el nombre real de la columna en la hoja, p.ej. "Econ√≥mico")
        if (!persisted && economicoVal) {
            // Intentar encontrar la clave real del objeto que represente el campo econ√≥mico
            const pedidoObj = pedidosApartados[idx] || {};
            const normalize = s => String(s || '').normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
            const econKey = Object.keys(pedidoObj).find(k => normalize(k) === 'economico') || Object.keys(pedidoObj).find(k => normalize(k).includes('econom'));
            const columnName = econKey || 'Econ√≥mico'; // fallback razonable
            const url = `https://sheetdb.io/api/v1/gdn5wqo960cey/${encodeURIComponent(columnName)}/${encodeURIComponent(economicoVal)}?sheet=Apartados`;
            const opts = {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ data: nueva })
            };
            const res2 = await tryFetch(url, opts);
            if (res2.ok) {
                persisted = true;
                mostrarMensaje('Pedido actualizado en servidor (por campo)', 'success');
                try { mostrarMensaje('Servidor respondi√≥: ' + (res2.body || 'OK'), 'success'); } catch(e){ console.warn(e); }
                try { await fetchPedidosApartados(); } catch(e) { console.warn('No se pudo recargar pedidos:', e); }
            } else {
                // Mostrar cuerpo de respuesta en consola/alert para depuraci√≥n
                try { console.warn('Respuesta al actualizar por campo:', res2); alert('Servidor respondi√≥: ' + (res2.body || JSON.stringify(res2))); } catch(e){}
            }
        }

        // Estrategia C: PUT completo por id (algunas integraciones requieren PUT a /Apartados/{id} con array)
        if (!persisted && possibleId) {
            const url = `https://sheetdb.io/api/v1/gdn5wqo960cey/Apartados/${encodeURIComponent(possibleId)}`;
            const opts = {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ data: [nueva] })
            };
            const res3 = await tryFetch(url, opts);
            if (res3.ok) {
                persisted = true;
                mostrarMensaje('Pedido actualizado en servidor (PUT por id)', 'success');
                try { mostrarMensaje('Servidor respondi√≥: ' + (res3.body || 'OK'), 'success'); } catch(e){ console.warn(e); }
                try { await fetchPedidosApartados(); } catch(e) { console.warn('No se pudo recargar pedidos:', e); }
            }
        }

        if (!persisted) {
            mostrarMensaje('Cambios guardados localmente. No fue posible guardar en servidor. Revisa la consola para detalles.', 'warning');
        }
    }

    // Funci√≥n para verificar si una unidad est√° apartada (robusta a variantes de nombre de campo)
    function estaUnidadApartada(economico) {
        if (!economico) return false;
        const key = (economico||'').toString().trim().toLowerCase();
        const enApartados = pedidosApartados.some(p => {
            const val = (p.economico || p.Econ√≥mico || p.Economico || p['Econ√≥mico'] || p.codigo || '').toString().trim().toLowerCase();
            return val === key;
        });
        if (enApartados) return true;
        // Tambi√©n se considera 'apartada' si fue marcada como pendiente por el usuario
        return unidadesPendientes.some(p => {
            const val = (p['Econ√≥mico'] || p.economico || '').toString().trim().toLowerCase();
            return val === key;
        });
    }

    // Funci√≥n para actualizar la tabla de llantas
    async function actualizarTablaLlantas() {
        console.log('Actualizando tabla de llantas...');
        
        const tbody = document.querySelector('#tablaLlantasAgregadas tbody');
        const totalDiv = document.getElementById('totalLlantas');
        const resultadoDiv = document.getElementById('resultadoSugerencia');
        
        let volumenTotal = 0;
        let pesoTotal = 0;
        
        tbody.innerHTML = '';
        
        // Asegurar que el contenedor de resultado est√© visible
        if (resultadoDiv) {
            resultadoDiv.style.display = 'block';
        }

        // Calcular y actualizar la distribuci√≥n m√∫ltiple si hay llantas
        if (llantasAgregadas.length > 0) {
            try {
                const distribucion = await calcularDistribucionMultiple(llantasAgregadas);
                if (distribucion && distribucion.length > 0) {
                    actualizarTablaDistribucion(distribucion);
                    // No forzamos mostrar el acorde√≥n aqu√≠; la funci√≥n `actualizarTablaDistribucion`
                    // decide mostrar u ocultar seg√∫n si la distribuci√≥n realmente requiere m√∫ltiples unidades.
                }
            } catch (error) {
                console.error('Error al calcular distribuci√≥n m√∫ltiple:', error);
            }
        }
        
        llantasAgregadas.forEach((llanta, index) => {
            volumenTotal += llanta.volumen;
            pesoTotal += llanta.peso;
            
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${llanta.descripcion}</td>
                <td>${llanta.cantidad}</td>
                <td>${llanta.volumen.toFixed(2)} m¬≥</td>
                <td>${llanta.peso.toFixed(2)} kg</td>
                <td>
                    <button class="btn btn-danger btn-sm" onclick="eliminarTipoLlanta(${index})">
                        <i class="bi bi-trash"></i>
                    </button>
                </td>
            `;
            tbody.appendChild(tr);
        });

        totalDiv.innerHTML = `
            Total: ${llantasAgregadas.reduce((sum, l) => sum + l.cantidad, 0)} llantas | 
            Volumen: ${volumenTotal.toFixed(2)} m¬≥ | 
            Peso: ${pesoTotal.toFixed(2)} kg
        `;
    }

    // Funci√≥n para calcular la sugerencia de unidad
    async function calcularSugerenciaUnidad() {
        console.log('Iniciando c√°lculo de sugerencia...');
        
        // Si no hay llantas agregadas, no hacer nada
        if (llantasAgregadas.length === 0) {
            document.getElementById('resultadoSugerencia').classList.add('d-none');
            return;
        }

        // Inicializar elementos UI
        const contenedorResultado = document.getElementById('resultadoSugerencia');
        const contenedorDetalles = document.getElementById('unidadSugeridaDetalles');

        // Verificar que flota tenga datos
        if (!Array.isArray(flota) || flota.length === 0) {
            console.error('No hay unidades en la flota');
            contenedorResultado.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle"></i>
                    Error: No hay unidades registradas en la flota.
                </div>
            `;
            contenedorResultado.classList.remove('d-none');
            return;
        }

        console.log('Total unidades en flota:', flota.length);
        console.log('Total pedidos Apartados:', pedidosApartados.length);

        // Si hay un cami√≥n activo para agregaci√≥n directa, no mostrar sugerencias
        if (typeof activePendingEconomico !== 'undefined' && activePendingEconomico) {
            contenedorResultado.innerHTML = `<div class="alert alert-info">Modo 'Seguir agregando' activo en cami√≥n ${escapeHtml(activePendingEconomico)}. No se muestran sugerencias.</div>`;
            contenedorResultado.classList.remove('d-none');
            return;
        }

            // Filtrar las unidades que ya est√°n en pedidos Apartados
            const unidadesDisponibles = flota.filter(unidad => {
                // Verificar que la unidad tenga c√≥digo
                if (!unidad.codigo && !unidad.economico) {
                    console.warn('Unidad sin c√≥digo:', unidad);
                    return false;
                }

                // Verificar si la unidad est√° en pedidos apartados
                const estaApartada = window.pedidosApartados?.some(pedido => {
                    const pedidoEconomico = String(
                        pedido.Economico || 
                        pedido['Econ√≥mico'] || 
                        pedido.economico || 
                        ''
                    ).trim().toLowerCase();
                    const unidadEconomico = String(
                        unidad.economico || 
                        unidad.codigo || 
                        ''
                    ).trim().toLowerCase();
                    return pedidoEconomico === unidadEconomico;
                });

                if (estaApartada) {
                    console.log('Unidad excluida por estar apartada:', unidad.economico || unidad.codigo);
                    return false;
                }            // Normalizar el c√≥digo de la unidad (convertir a string y eliminar espacios)
            const codigoUnidad = String(unidad.codigo || unidad.economico).trim().toLowerCase();
            
            // Buscar si la unidad est√° en pedidos Apartados
            const yaEstaConfirmada = pedidosApartados.some(pedido => {
                // Normalizar el c√≥digo del pedido
                const pedidoEconomico = String(
                    pedido['Econ√≥mico'] || 
                    pedido.Economico || 
                    pedido.economico || 
                    pedido.econ√≥mico || 
                    pedido.codigo || 
                    ''
                ).trim().toLowerCase();
                
                const coincide = pedidoEconomico === codigoUnidad;
                if (coincide) {
                    console.log(`Unidad ${codigoUnidad} est√° en pedidos Apartados`);
                }
                return coincide;
            });
            
            if (!yaEstaConfirmada) {
                console.log('Unidad disponible:', codigoUnidad);
            }
            
            return !yaEstaConfirmada;
        });

        console.log('Unidades disponibles encontradas:', unidadesDisponibles.length);

        // Si no hay unidades disponibles o adecuadas, mostrar mensaje
        if (unidadesDisponibles.length === 0) {
            contenedorResultado.innerHTML = `
                <div class="alert alert-warning">
                    <i class="bi bi-exclamation-triangle"></i>
                    <h5>No hay unidades disponibles adecuadas</h5>
                    <p>Esto puede deberse a:</p>
                    <ul>
                        <li>Todas las unidades est√°n asignadas a otros pedidos</li>
                        <li>Las unidades disponibles no tienen suficiente capacidad para este pedido</li>
                        <li>El pedido requiere m√°s capacidad de la que tienen las unidades individuales</li>
                    </ul>
                    <p>Volumen necesario: ${volumenTotal.toFixed(2)} m¬≥</p>
                    <p>Peso necesario: ${pesoTotal.toFixed(2)} kg</p>
                </div>
            `;
            contenedorResultado.classList.remove('d-none');
            return;
        }

        // Funci√≥n auxiliar para distribuir carga de manera inteligente
        function distribuirCargaEnCamiones(volumenTotal, pesoTotal, camionesDisponibles) {
            if (!Array.isArray(camionesDisponibles)) {
                console.error('camionesDisponibles no es un array:', camionesDisponibles);
                return { distribucion: [], volumenRestante: volumenTotal, pesoRestante: pesoTotal };
            }

            // Filtrar camiones que ya est√°n en pedidosApartados
            camionesDisponibles = camionesDisponibles.filter(camion => {
                return !pedidosApartados.some(pedido => 
                    pedido.economico === camion.economico
                );
            });

            let distribucion = [];
            let volumenRestante = volumenTotal;
            let pesoRestante = pesoTotal;
            
            // Ordenamos los camiones priorizando unidades m√°s grandes y eficientes
            let camionesOrdenados = [...new Map(camionesDisponibles.map(item => [item.economico, item])).values()];
            
            // Ahora ordenamos los camiones √∫nicos
            camionesOrdenados.sort((a, b) => {
                // Si alguno puede llevar toda la carga, lo priorizamos
                const aLlevaTodo = a.volumenNum >= volumenTotal && a.capacidadCargaNum >= pesoTotal;
                const bLlevaTodo = b.volumenNum >= volumenTotal && b.capacidadCargaNum >= pesoTotal;
                
                if (aLlevaTodo !== bLlevaTodo) {
                    return aLlevaTodo ? -1 : 1;
                }
                
                // Calculamos el porcentaje que cada unidad puede llevar
                const capacidadVolumenA = Math.min(1, volumenTotal / a.volumenNum);
                const capacidadVolumenB = Math.min(1, volumenTotal / b.volumenNum);
                const capacidadPesoA = Math.min(1, pesoTotal / a.capacidadCargaNum);
                const capacidadPesoB = Math.min(1, pesoTotal / b.capacidadCargaNum);
                
                // Calculamos un puntaje basado en capacidad y eficiencia
                const puntajeA = Math.min(capacidadVolumenA, capacidadPesoA) * a.volumenNum;
                const puntajeB = Math.min(capacidadVolumenB, capacidadPesoB) * b.volumenNum;
                
                // Priorizamos unidades m√°s grandes
                return b.volumenNum - a.volumenNum;
            });
            
            while (volumenRestante > 0 || pesoRestante > 0) {
                let mejorCamion = null;
                let mejorEficiencia = 0;
                let mejorCombinacion = null;
                
                // Primera pasada: intentar encontrar un cami√≥n que pueda llevar toda o la mayor√≠a de la carga
                for (const camion of camionesOrdenados) {
                    const volumenPosible = Math.min(volumenRestante, camion.volumenNum);
                    const pesoPosible = Math.min(pesoRestante, camion.capacidadCargaNum);
                    
                    // Verificar si este cami√≥n puede llevar una parte significativa
                    const porcentajeVolumen = volumenPosible / volumenRestante;
                    const porcentajePeso = pesoPosible / pesoRestante;
                    const porcentajeTotal = Math.min(porcentajeVolumen, porcentajePeso);
                    
                    // Si puede llevar al menos el 70% de la carga restante, lo consideramos
                    if (porcentajeTotal >= 0.7) {
                        const eficienciaVolumen = volumenPosible / camion.volumenNum;
                        const eficienciaPeso = pesoPosible / camion.capacidadCargaNum;
                        const eficienciaPromedio = (eficienciaVolumen + eficienciaPeso) / 2;
                        
                        // Aceptamos si la eficiencia es mayor al 40% (m√°s permisivo)
                        if (eficienciaPromedio > 0.4) {
                            mejorCamion = {
                                ...camion,
                                volumenAsignado: volumenPosible,
                                pesoAsignado: pesoPosible,
                                eficiencia: eficienciaPromedio * 100
                            };
                            break;
                        }
                    }
                }
                
                // Si no encontramos un cami√≥n ideal, buscamos la mejor combinaci√≥n
                if (!mejorCamion) {
                    for (const camion of camionesOrdenados) {
                        const volumenPosible = Math.min(volumenRestante, camion.volumenNum);
                        const pesoPosible = Math.min(pesoRestante, camion.capacidadCargaNum);
                        const eficienciaVolumen = volumenPosible / camion.volumenNum;
                        const eficienciaPeso = pesoPosible / camion.capacidadCargaNum;
                        const eficienciaPromedio = (eficienciaVolumen + eficienciaPeso) / 2;
                        
                        // Si es m√°s eficiente que lo que ten√≠amos antes
                        if (eficienciaPromedio > mejorEficiencia) {
                            mejorEficiencia = eficienciaPromedio;
                            mejorCamion = {
                                ...camion,
                                volumenAsignado: volumenPosible,
                                pesoAsignado: pesoPosible,
                                eficiencia: eficienciaPromedio * 100,
                                esParcial: true // Marcamos que este cami√≥n llevar√° carga parcial
                            };
                        }
                    }
                }
                
                if (!mejorCamion) break;
                
                distribucion.push(mejorCamion);
                volumenRestante -= mejorCamion.volumenAsignado;
                pesoRestante -= mejorCamion.pesoAsignado;
            }
            
            // Calcular estad√≠sticas de la distribuci√≥n
            const estadisticas = {
                numUnidades: distribucion.length,
                eficienciaPromedio: distribucion.reduce((sum, c) => sum + c.eficiencia, 0) / distribucion.length,
                volumenTotalUtilizado: distribucion.reduce((sum, c) => sum + c.volumenAsignado, 0),
                pesoTotalUtilizado: distribucion.reduce((sum, c) => sum + c.pesoAsignado, 0)
            };

            return {
                distribucion,
                volumenRestante,
                pesoRestante,
                estadisticas
            };
        }

        if (!contenedorResultado || !contenedorDetalles) {
            console.error('No se encontraron los contenedores de resultado');
            return;
        }

        // Asegurarnos de que el contenedor de resultado est√© visible
        contenedorResultado.classList.remove('d-none');
        contenedorDetalles.innerHTML = '<div class="alert alert-info">Calculando sugerencias...</div>';

        if (llantasAgregadas.length === 0) {
            contenedorDetalles.innerHTML = `
                <div class="alert alert-info">
                    <h6><i class="bi bi-info-circle"></i> Agregue llantas para ver sugerencias de unidades</h6>
                    <p>Use el formulario superior para agregar llantas al c√°lculo.</p>
                </div>`;
            return;
        }

        // Mostrar el spinner mientras se calcula
        contenedorDetalles.innerHTML = `
            <div class="alert alert-info">
                <div class="d-flex align-items-center">
                    <div class="spinner-border spinner-border-sm me-2" role="status">
                        <span class="visually-hidden">Calculando...</span>
                    </div>
                    <span>Calculando la mejor distribuci√≥n de unidades...</span>
                </div>
            </div>`;

        // Calcular totales de todas las llantas agregadas
        const volumenTotal = llantasAgregadas.reduce((sum, llanta) => sum + llanta.volumen, 0);
        const pesoTotal = llantasAgregadas.reduce((sum, llanta) => sum + llanta.peso, 0);
        const cantidadTotalLlantas = llantasAgregadas.reduce((sum, llanta) => sum + llanta.cantidad, 0);

        // Procesar todos los camiones disponibles
        let camionesDisponibles = flota
            .filter(camion => {
                try {
                    // Primero verificar si est√° en pedidos Apartados
                    const codigoUnidad = String(camion.codigo || camion.economico).trim().toLowerCase();
                    const estaConfirmada = pedidosApartados.some(pedido => {
                        const pedidoEconomico = String(
                            pedido['Econ√≥mico'] || 
                            pedido.Economico || 
                            pedido.economico || 
                            pedido.econ√≥mico || 
                            pedido.codigo || 
                            ''
                        ).trim().toLowerCase();
                        return pedidoEconomico === codigoUnidad;
                    });

                    if (estaConfirmada) {
                        console.log('Unidad excluida por estar confirmada:', codigoUnidad);
                        return false;
                    }

                    // Verificar si la unidad tiene suficiente capacidad para el pedido
                    const volumenUnidad = parseFloat(camion.volumen || '0');
                    if (volumenUnidad < volumenTotal) {
                        console.log('Unidad excluida por capacidad insuficiente:', codigoUnidad, 
                            'Capacidad:', volumenUnidad.toFixed(2), 'm¬≥',
                            'Necesario:', volumenTotal.toFixed(2), 'm¬≥');
                        return false;
                    }

                    // Verificar que el cami√≥n tenga datos v√°lidos
                    if (!camion.volumen || !camion["capacidad de carga (kg)"]) {
                        console.log('Cami√≥n sin datos completos:', camion);
                        return false;
                    }
                    
                    // Convertir a n√∫meros y validar
                    const volumenCamion = parseFloat(camion.volumen);
                    const capacidadCarga = parseFloat(camion["capacidad de carga (kg)"]);
                    
                    // Verificar que los valores sean v√°lidos
                    if (isNaN(volumenCamion) || isNaN(capacidadCarga) || 
                        volumenCamion <= 0 || capacidadCarga <= 0) {
                        console.log('Cami√≥n con datos inv√°lidos:', camion);
                        return false;
                    }    
                    
                    // Guardar los valores num√©ricos en el objeto para uso posterior
                    camion.volumenNum = volumenCamion;
                    camion.capacidadCargaNum = capacidadCarga;
                    
                    // Verificar si el cami√≥n puede manejar al menos el 70% del pedido
                    const puedeVolumen = volumenCamion >= volumenTotal * 0.7;
                    const puedePeso = capacidadCarga >= pesoTotal * 0.7;
                    const esViable = puedeVolumen && puedePeso;
                    
                    if (esViable) {
                        console.log('Cami√≥n viable:', camion.economico, 
                            'Capacidad:', volumenCamion.toFixed(2), 'm¬≥,', 
                            capacidadCarga.toFixed(2), 'kg',
                            'Puede manejar:', 
                            (volumenCamion/volumenTotal*100).toFixed(1) + '% del volumen,',
                            (capacidadCarga/pesoTotal*100).toFixed(1) + '% del peso');
                    } else {
                        console.log('Cami√≥n descartado por capacidad insuficiente:', camion.economico);
                    }
                    
                    return esViable;
                } catch (error) {
                    console.error('Error al procesar cami√≥n:', camion, error);
                    return false;
                }
            })
            .map(camion => {
                // Calcular los porcentajes correctamente (volumen usado / capacidad total)
                const porcentajeVolumen = Math.min((volumenTotal / camion.volumenNum) * 100, 100);
                const porcentajePeso = Math.min((pesoTotal / camion.capacidadCargaNum) * 100, 100);
                const utilizacionPromedio = Math.min((porcentajeVolumen + porcentajePeso) / 2, 100);
                
                console.log(`Unidad ${camion.economico}: Vol ${porcentajeVolumen.toFixed(1)}%, Peso ${porcentajePeso.toFixed(1)}%, Promedio ${utilizacionPromedio.toFixed(1)}%`);
                
                return {
                    ...camion,
                    porcentajeVolumen,
                    porcentajePeso,
                    utilizacionPromedio
                };
            });

        // Calcular la distribuci√≥n √≥ptima de camiones usando solo unidades disponibles
        const distribucion = distribuirCargaEnCamiones(volumenTotal, pesoTotal, camionesDisponibles);

        if (distribucion.distribucion.length === 0) {
            // Ordenar unidades priorizando las m√°s grandes y eficientes
            let unidadesOrdenadas = [...unidadesDisponibles]
                .map(unidad => {
                    // Calcular capacidad y eficiencia potencial
                    const capacidadTotal = unidad.volumenNum + unidad.capacidadCargaNum;
                    const eficienciaPotencial = Math.min(
                        unidad.volumenNum / Math.max(volumenTotal / 2, 1), 
                        unidad.capacidadCargaNum / Math.max(pesoTotal / 2, 1)
                    );
                    // Penalizar unidades muy peque√±as
                    const penalizacionTama√±o = unidad.volumenNum < volumenTotal / 4 ? 0.5 : 1;
                    
                    return {
                        ...unidad,
                        capacidadTotal,
                        puntuacion: capacidadTotal * eficienciaPotencial * penalizacionTama√±o
                    };
                })
                .sort((a, b) => b.puntuacion - a.puntuacion);

            console.log('Iniciando distribuci√≥n con unidades √∫nicas:', 
                unidadesOrdenadas.map(u => u.economico).join(', '));
            
            // Obtener unidades confirmadas
            const unidadesConfirmadas = new Set(pedidosApartados.map(pedido => 
                String(pedido['Econ√≥mico'] || pedido.Economico || pedido.economico || pedido.c√≥digo || '').trim().toLowerCase()
            ));
            
            console.log('Unidades confirmadas antes de filtrar:', Array.from(unidadesConfirmadas));

            // Filtrar unidades que ya est√°n confirmadas
            const unidadesDisponiblesOriginales = unidadesOrdenadas.length;
            unidadesOrdenadas = unidadesOrdenadas.filter(unidad => {
                const codigoUnidad = String(unidad.economico || '').trim().toLowerCase();
                const estaConfirmada = unidadesConfirmadas.has(codigoUnidad);
                if (estaConfirmada) {
                    console.log(`Unidad ${codigoUnidad} excluida por estar confirmada`);
                }
                return !estaConfirmada;
            });
            
            console.log('Unidades filtradas:', {
                antes: unidadesDisponiblesOriginales,
                despues: unidadesOrdenadas.length,
                eliminadas: unidadesDisponiblesOriginales - unidadesOrdenadas.length
            });

            let distribucionMultiple = [];
            let volumenRestante = volumenTotal;
            let pesoRestante = pesoTotal;
            let llantasRestantes = cantidadTotalLlantas;
            
            // Ordenar unidades disponibles por capacidad de volumen (de mayor a menor)
            unidadesOrdenadas.sort((a, b) => {
                const volumenA = parseFloat(a.volumen || a.capacidadVolumen || '0');
                const volumenB = parseFloat(b.volumen || b.capacidadVolumen || '0');
                return volumenB - volumenA;  // Orden descendente
            });

            console.log('Unidades ordenadas por capacidad:', 
                unidadesOrdenadas.map(u => ({
                    economico: u.economico,
                    volumen: parseFloat(u.volumen || u.capacidadVolumen || '0').toFixed(2) + ' m¬≥'
                }))
            );
            
            // Constantes para c√°lculos
            const PESO_POR_LLANTA = 7.80; // kg por llanta
            console.log('Iniciando distribuci√≥n:', {
                volumenTotal: volumenTotal.toFixed(2) + ' m¬≥',
                pesoTotal: pesoTotal.toFixed(2) + ' kg',
                totalLlantas: cantidadTotalLlantas,
                pesoPorLlanta: PESO_POR_LLANTA + ' kg'
            });
            let unidadesUsadas = new Set(); // Para rastrear unidades ya utilizadas

            for (const unidad of unidadesOrdenadas) {
                // Verificar si la unidad ya fue usada
                if (unidadesUsadas.has(unidad.economico)) {
                    console.log('Unidad ya utilizada, saltando:', unidad.economico);
                    continue;
                }

                // Si ya no hay carga por distribuir, salimos del ciclo
                if (volumenRestante <= 0.01 && pesoRestante <= 0.01) {
                    console.log('No hay m√°s carga por distribuir');
                    break;
                }

                const volumenUnidad = parseFloat(unidad.volumen);
                const pesoUnidad = parseFloat(unidad["capacidad de carga (kg)"]);
                
                console.log('Evaluando unidad:', unidad.economico);
                console.log('Capacidad:', { volumen: volumenUnidad, peso: pesoUnidad });
                console.log('Restante:', { volumen: volumenRestante, peso: pesoRestante });

                // Calcular la capacidad disponible y necesaria
                const capacidadVolumenDisponible = volumenUnidad;
                const capacidadPesoDisponible = pesoUnidad;
                
                // Calcular cu√°nto puede llevar esta unidad
                let volumenAsignable, pesoAsignable;
                
                // Calcular el porcentaje que esta unidad podr√≠a llevar del total
                const porcentajeVolumenPosible = (volumenUnidad / volumenTotal) * 100;
                const porcentajePesoPosible = (pesoUnidad / pesoTotal) * 100;
                
                console.log('Porcentajes posibles:', {
                    volumen: porcentajeVolumenPosible.toFixed(1) + '%',
                    peso: porcentajePesoPosible.toFixed(1) + '%'
                });

                // Si es la primera unidad, intentar maximizar su uso
                if (distribucionMultiple.length === 0) {
                    // Asignar el m√°ximo posible a la primera unidad
                    volumenAsignable = Math.min(volumenRestante, volumenUnidad);
                    pesoAsignable = Math.min(pesoRestante, pesoUnidad);
                } else {
                    // Para unidades auxiliares, intentar aprovechar al m√°ximo su capacidad
                    // siempre que quede suficiente carga para justificar su uso
                    const cargaRestanteSignificativa = volumenRestante > volumenUnidad * 0.2 ||
                                                      pesoRestante > pesoUnidad * 0.2;
                    
                    if (cargaRestanteSignificativa) {
                        // Asignar tanto como sea posible a la unidad auxiliar
                        volumenAsignable = Math.min(volumenRestante, volumenUnidad);
                        pesoAsignable = Math.min(pesoRestante, pesoUnidad);
                        
                        console.log('Asignando carga significativa a unidad auxiliar:', {
                            volumen: volumenAsignable.toFixed(2) + ' m¬≥',
                            peso: pesoAsignable.toFixed(2) + ' kg'
                        });
                    } else {
                        // Si queda muy poca carga, asignar solo lo restante
                        volumenAsignable = volumenRestante;
                        pesoAsignable = pesoRestante;
                    }
                }

                // Calcular la eficiencia de uso de la unidad
                const eficienciaVolumen = (volumenAsignable / volumenUnidad) * 100;
                const eficienciaPeso = (pesoAsignable / pesoUnidad) * 100;
                const porcentajeCapacidad = Math.min(eficienciaVolumen, eficienciaPeso);

                console.log('An√°lisis de eficiencia:', {
                    volumen: eficienciaVolumen.toFixed(1) + '%',
                    peso: eficienciaPeso.toFixed(1) + '%',
                    total: porcentajeCapacidad.toFixed(1) + '%'
                });

                // Evaluaci√≥n m√°s flexible para cargas grandes
                const cargaTotal = volumenTotal;
                const cargaRestante = volumenRestante;
                const esUnidadPrincipal = distribucionMultiple.length === 0;
                
                // Calcular qu√© tan grande es la carga total y restante
                const esCargaGrande = volumenTotal > 50; // m√°s de 50m¬≥ se considera carga grande
                const porcentajeRestante = (volumenRestante / volumenTotal) * 100;
                
                console.log('An√°lisis de carga:', {
                    cargaTotal: volumenTotal.toFixed(2) + ' m¬≥',
                    cargaRestante: volumenRestante.toFixed(2) + ' m¬≥',
                    porcentajeRestante: porcentajeRestante.toFixed(1) + '%',
                    esCargaGrande
                });

                // Umbrales m√°s flexibles para cargas grandes
                let umbralMinimo;
                if (esUnidadPrincipal) {
                    umbralMinimo = 30; // M√°s permisivo con la primera unidad
                } else if (esCargaGrande) {
                    // Para cargas grandes, ser m√°s permisivo con unidades auxiliares
                    umbralMinimo = Math.min(
                        5, // m√≠nimo absoluto
                        Math.max(1, porcentajeRestante / 4) // m√°s permisivo cuanto m√°s carga queda
                    );
                } else {
                    // Para cargas normales
                    umbralMinimo = Math.min(
                        15, // m√≠nimo normal
                        Math.max(5, porcentajeRestante / 3));
                
                // Verificar nuevamente que la unidad no est√© confirmada
                const codigoUnidad = String(unidad.economico || '').trim().toLowerCase();
                if (unidadesConfirmadas.has(codigoUnidad)) {
                    console.log(`Saltando unidad ${codigoUnidad} - est√° confirmada`);
                    continue; // Saltar esta unidad
                }
                    
                }

                console.log('Evaluaci√≥n de umbral:', {
                    umbralMinimo: umbralMinimo.toFixed(1) + '%',
                    porcentajeCapacidad: porcentajeCapacidad.toFixed(1) + '%',
                    supera: porcentajeCapacidad > umbralMinimo ? 'S√≠' : 'No'
                });

                const deberiaUsarUnidad = porcentajeCapacidad > umbralMinimo || 
                                        (esCargaGrande && volumenRestante > volumenUnidad * 0.1);

                if (deberiaUsarUnidad) {
                    // Calcular llantas basado en proporci√≥n de volumen
                    const llantasAsignadas = Math.floor(llantasRestantes * (volumenAsignable / volumenRestante));
                    
                    // Calcular peso real basado en n√∫mero de llantas
                    const pesoRealAsignado = llantasAsignadas * PESO_POR_LLANTA;
                    
                    // Calcular eficiencias reales
                    const eficienciaVolumenReal = (volumenAsignable / volumenUnidad) * 100;
                    const eficienciaPesoReal = (pesoRealAsignado / pesoUnidad) * 100;
                    const eficienciaReal = (eficienciaVolumenReal + eficienciaPesoReal) / 2;
                    
                    console.log('Asignando a unidad:', {
                        economico: unidad.economico,
                        volumen: volumenAsignable.toFixed(2) + ' m¬≥',
                        peso: pesoRealAsignado.toFixed(2) + ' kg',
                        llantas: llantasAsignadas,
                        eficienciaVolumen: eficienciaVolumenReal.toFixed(1) + '%',
                        eficienciaPeso: eficienciaPesoReal.toFixed(1) + '%',
                        eficienciaTotal: eficienciaReal.toFixed(1) + '%'
                    });

                    distribucionMultiple.push({
                        ...unidad,
                        volumenAsignado: volumenAsignable,
                        pesoAsignado: pesoRealAsignado,
                        eficiencia: eficienciaReal,
                        llantasEstimadas: llantasAsignadas
                    });

                    // Marcar la unidad como usada
                    unidadesUsadas.add(unidad.economico);
                    
                    volumenRestante -= volumenAsignable;
                    pesoRestante -= pesoAsignable;
                    llantasRestantes -= llantasAsignadas;
                }
            }

            // Filtrar solo unidades con datos completos
            const unidadesValidas = distribucionMultiple.filter(unidad => 
                unidad.llantasEstimadas > 0 && 
                unidad.volumenAsignado > 0 && 
                unidad.pesoAsignado > 0 && 
                !isNaN(unidad.eficiencia) &&
                unidad.eficiencia > 0
            );

            if (unidadesValidas.length > 0) {
                // Distribuir las descripciones y detalles de llantas entre las unidades
                try {
                    // Crear copia mutable de llantasAgregadas con cantidad pendiente
                    let pendientes = llantasAgregadas.map(l => ({
                        descripcion: l.descripcion || l.Descripci√≥n || l.descripcionLlanta || '',
                        cantidadPendiente: parseInt(l.cantidad || l.Cantidad || 0),
                        linea: l.linea || l.Linea || ''
                    }));

                    for (const unidad of unidadesValidas) {
                        let asignar = parseInt(unidad.llantasEstimadas || 0);
                        const descripcionesArr = [];
                        const llantasArr = [];

                        for (const tipo of pendientes) {
                            if (asignar <= 0) break;
                            if (!tipo.cantidadPendiente || tipo.cantidadPendiente <= 0) continue;

                            const toma = Math.min(tipo.cantidadPendiente, asignar);
                            descripcionesArr.push(`${toma}x ${tipo.descripcion}`);
                            llantasArr.push({ cantidad: toma, descripcion: tipo.descripcion, linea: tipo.linea });
                            tipo.cantidadPendiente -= toma;
                            asignar -= toma;
                        }

                        unidad.descripciones = descripcionesArr.join('\n');
                        unidad.llantas = llantasArr;
                    }
                } catch (e) {
                    console.warn('No fue posible distribuir descripciones autom√°ticamente:', e);
                }

                // Mostrar sugerencia de m√∫ltiples unidades
                contenedorDetalles.innerHTML = `
                    <div class="alert alert-info">
                        <h5><i class="bi bi-info-circle"></i> Distribuci√≥n Sugerida del Pedido</h5>
                        <p>Este pedido requiere distribuci√≥n en ${unidadesValidas.length} unidades para √≥ptimo manejo:</p>
                        <div class="table-responsive">
                            <table class="table table-bordered">
                                <thead>
                                    <tr>
                                        <th>Unidad</th>
                                        <th>Econ√≥mico</th>
                                        <th>Llantas Est.</th>
                                        <th>Volumen</th>
                                        <th>Peso</th>
                                        <th>Eficiencia</th>
                                    </tr>
                                </thead>
                                <tbody>
                                        ${unidadesValidas.map((unidad, idx) => {
                                            // construir lista de candidatos desde la flota completa
                                            const flota = typeof obtenerUnidadesFlota === 'function' ? obtenerUnidadesFlota() : [];
                                            const candidatos = flota.filter(u => {
                                                const capVol = parseFloat(u.capacidadVolumen) || 0;
                                                const capPeso = parseFloat(u.capacidadPeso) || 0;
                                                return capVol >= (parseFloat(unidad.volumenAsignado) || 0) && capPeso >= (parseFloat(unidad.pesoAsignado) || 0);
                                            });
                                            // Asegurar inclusi√≥n de la unidad actual
                                            if (!candidatos.find(u => String(u.codigo) === String(unidad.economico))) {
                                                const encontrada = flota.find(u => String(u.codigo) === String(unidad.economico));
                                                if (encontrada) candidatos.unshift(encontrada);
                                                else candidatos.unshift({ codigo: unidad.economico || '', nombre: unidad.unidad || '' });
                                            }

                                            const opciones = candidatos.map(c => {
                                                const selected = String(c.codigo) === String(unidad.economico) ? 'selected' : '';
                                                const label = `${c.nombre || c.unidad || ''} (${c.codigo || c.economico || ''})`;
                                                return `<option value="${c.codigo || ''}" ${selected}>${label}</option>`;
                                            }).join('');

                                            return `
                                            <tr>
                                                <td>
                                                    <select class="form-select form-select-sm select-unidad-pedidos" data-idx="${idx}">
                                                        ${opciones}
                                                    </select>
                                                </td>
                                                <td class="econ-${idx}">${unidad.economico}</td>
                                                <td class="text-center">${unidad.llantasEstimadas}</td>
                                                <td>${unidad.volumenAsignado.toFixed(2)} m¬≥</td>
                                                <td>${unidad.pesoAsignado.toFixed(2)} kg</td>
                                                <td>${unidad.eficiencia.toFixed(1)}%</td>
                                            </tr>
                                        `}).join('')}
                                    </tbody>
                            </table>
                        </div>
                        <div class="d-flex justify-content-center mt-3">
                            <button class="btn btn-warning btn-lg" onclick="apartarDistribucionCompleta(this)" data-unidades='${JSON.stringify(unidadesValidas)}'>
                                <i class="bi bi-box-arrow-right"></i> Apartar Distribuci√≥n Completa
                            </button>
                        </div>
                        <div class="alert alert-warning mt-3">
                            <i class="bi bi-info-circle"></i> Al apartar la distribuci√≥n, se reservar√°n todas las unidades mostradas para este pedido.
                        </div>
                    </div>
                `;

                // Adjuntar manejadores a los selects para permitir cambiar la unidad sugerida
                setTimeout(() => {
                    try {
                        const selects = contenedorDetalles.querySelectorAll('.select-unidad-pedidos');
                        const boton = contenedorDetalles.querySelector('button[onclick^="apartarDistribucionCompleta"]');
                        selects.forEach(sel => {
                            sel.removeEventListener('change', sel._handler || (() => {}));
                            
                            // === HANDLER UNIFICADO CON CAPACIDAD INTELIGENTE ===
                            const handler = async function() {
                                const idx = parseInt(this.dataset.idx, 10);
                                const unidadAnterior = unidadesValidas[idx];
                                const nuevoEco = this.value;
                                const unidadesFlota = typeof obtenerUnidadesFlota === 'function' ? obtenerUnidadesFlota() : [];
                                
                                console.log(`\nüîÑ [CAMBIO UNIDAD] √çndice ${idx}: ${unidadAnterior?.economico || '?'} ‚Üí ${nuevoEco}`);
                                
                                // === OBTENER CAPACIDADES ===
                                const unidadNueva = unidadesFlota.find(u => String(u.codigo) === String(nuevoEco));
                                const capVolumeNueva = parseNumber(unidadNueva?.capacidadVolumen) || 0;
                                const capPesoNueva = parseNumber(unidadNueva?.capacidadPeso) || 0;
                                const capVolumenVieja = parseNumber(unidadAnterior?.capacidadVolumen) || 0;
                                const capPesoVieja = parseNumber(unidadAnterior?.capacidadPeso) || 0;
                                
                                console.log(`üì¶ Capacidades: Vieja ${capVolumenVieja}m¬≥/${capPesoVieja}kg ‚Üí Nueva ${capVolumeNueva}m¬≥/${capPesoNueva}kg`);
                                
                                // === PASO 1: LIMPIAR BLOQUEADOS PARA EVITAR DUPLICADOS ===
                                // En lugar de bloquear la unidad anterior, limpiar bloqueados viejos
                                // para que la recalculaci√≥n sea fresca sin duplicados.
                                if (typeof window.unidadesBloquedadas === 'undefined') window.unidadesBloquedadas = {};
                                
                                // Eliminar bloqueados para este y otros econ√≥micos que no est√©n en la distribuci√≥n
                                try {
                                    delete window.unidadesBloquedadas[unidadAnterior?.economico];
                                    console.log(`[üîì LIMPIEZA] Eliminado bloqueo previo de ${unidadAnterior?.economico}`);
                                } catch (e) { console.warn('Error limpiando bloqueos:', e); }
                                
                                console.log('[ESTADO] window.unidadesBloquedadas despu√©s de limpieza:', Object.keys(window.unidadesBloquedadas));
                                
                                // === PASO 2: ACTUALIZAR UNIDAD EN unidadesValidas ===
                                if (unidadesValidas[idx]) {
                                    unidadesValidas[idx].economico = nuevoEco;
                                    unidadesValidas[idx].unidad = unidadNueva?.nombre || unidadesValidas[idx].unidad;
                                    unidadesValidas[idx].capacidadVolumen = capVolumeNueva;
                                    unidadesValidas[idx].capacidadPeso = capPesoNueva;
                                    
                                    // Transferir llantas de la unidad anterior
                                    if (unidadAnterior?.llantas?.length > 0) {
                                        console.log(`üì§ [TRANSFERENCIA] Moviendo ${unidadAnterior.llantas.length} llantas a ${nuevoEco}`);
                                        unidadesValidas[idx].llantas = JSON.parse(JSON.stringify(unidadAnterior.llantas));
                                        unidadesValidas[idx].volumenAsignado = unidadAnterior.volumenAsignado || 0;
                                        unidadesValidas[idx].pesoAsignado = unidadAnterior.pesoAsignado || 0;
                                        unidadesValidas[idx].llantasEstimadas = unidadAnterior.llantasEstimadas || 0;
                                    }
                                }
                                
                                // === PASO 3: INTENTAR LLENAR EXTRA CAPACIDAD SI NUEVA > VIEJA ===
                                const capacidadExtra = Math.max(0, capVolumeNueva - capVolumenVieja);
                                console.log(`üíæ Capacidad extra disponible: ${capacidadExtra.toFixed(2)}m¬≥`);
                                
                                if (capacidadExtra > 0 && llantasAcumuladasEnBloque?.length > 0) {
                                    console.log('üéØ Intentando llenar capacidad extra con llantas disponibles...');
                                    
                                    let llantasDisponibles = llantasAcumuladasEnBloque.filter(ll => {
                                        // Obtener cantidad actual en bloqueadas
                                        let cantEnBloqueadas = 0;
                                        for (const bloqueada of distribucionBloqueada) {
                                            if (bloqueada.llantas?.length > 0) {
                                                const match = bloqueada.llantas.find(bl => 
                                                    (bl.descripcion || bl.Descripci√≥n) === (ll.descripcion || ll.Descripci√≥n)
                                                );
                                                if (match) cantEnBloqueadas += (match.cantidad || 0);
                                            }
                                        }
                                        // Obtener cantidad actualmente en unidadesValidas[idx]
                                        let cantEnActual = 0;
                                        if (unidadesValidas[idx]?.llantas?.length > 0) {
                                            const match = unidadesValidas[idx].llantas.find(u => 
                                                (u.descripcion || u.Descripci√≥n) === (ll.descripcion || ll.Descripci√≥n)
                                            );
                                            if (match) cantEnActual += (match.cantidad || 0);
                                        }
                                        // Retornar aquellas que tienen disponibles (total > bloqueadas + actuales)
                                        const totalCant = parseInt(ll.Cantidad || ll.cantidad || ll.CantidadLL || 1);
                                        return totalCant > (cantEnBloqueadas + cantEnActual);
                                    });
                                    
                                    console.log(`üìã Llantas disponibles para extra capacidad: ${llantasDisponibles.length} tipos`);
                                    
                                    let volumenUsado = 0;
                                    let pesoUsado = 0;
                                    let llantasAgregadas = 0;
                                    
                                    // Agregar lo que quepa
                                    for (const llanta of llantasDisponibles) {
                                        if (volumenUsado >= capacidadExtra) break;
                                        
                                        const volUnit = parseNumber(llanta.volumenUnitario || llanta.Volumen || llanta['Volumen (m3)'] || 0) || 0;
                                        const pesoUnit = parseNumber(llanta.pesoUnitario || llanta.Peso || llanta['Peso (kg)'] || 0) || 0;
                                        const totalCant = parseInt(llanta.Cantidad || llanta.cantidad || 1);
                                        
                                        // Calcular cu√°ntas caben
                                        let cantEnActual = 0;
                                        if (unidadesValidas[idx]?.llantas?.length > 0) {
                                            const match = unidadesValidas[idx].llantas.find(u => 
                                                (u.descripcion || u.Descripci√≥n) === (llanta.descripcion || llanta.Descripci√≥n)
                                            );
                                            if (match) cantEnActual = match.cantidad || 0;
                                        }
                                        
                                        let cantEnBloqueadas = 0;
                                        for (const bloqueada of distribucionBloqueada) {
                                            if (bloqueada.llantas?.length > 0) {
                                                const match = bloqueada.llantas.find(bl => 
                                                    (bl.descripcion || bl.Descripci√≥n) === (llanta.descripcion || llanta.Descripci√≥n)
                                                );
                                                if (match) cantEnBloqueadas += (match.cantidad || 0);
                                            }
                                        }
                                        
                                        const cantDisponible = totalCant - cantEnActual - cantEnBloqueadas;
                                        if (cantDisponible <= 0) continue;
                                        
                                        const maxPorVolumen = volUnit > 0 ? Math.floor((capacidadExtra - volumenUsado) / volUnit) : cantDisponible;
                                        const maxPorPeso = pesoUnit > 0 ? Math.floor((capPesoNueva - unidadesValidas[idx].pesoAsignado - pesoUsado) / pesoUnit) : cantDisponible;
                                        const cantAgregar = Math.min(cantDisponible, maxPorVolumen, maxPorPeso);
                                        
                                        if (cantAgregar > 0) {
                                            // Buscar si ya est√° en la lista de esta unidad
                                            let encontrada = false;
                                            if (unidadesValidas[idx]?.llantas?.length > 0) {
                                                for (const ll of unidadesValidas[idx].llantas) {
                                                    if ((ll.descripcion || ll.Descripci√≥n) === (llanta.descripcion || llanta.Descripci√≥n)) {
                                                        ll.cantidad = (ll.cantidad || 0) + cantAgregar;
                                                        encontrada = true;
                                                        break;
                                                    }
                                                }
                                            }
                                            
                                            if (!encontrada) {
                                                if (!unidadesValidas[idx].llantas) unidadesValidas[idx].llantas = [];
                                                unidadesValidas[idx].llantas.push({
                                                    cantidad: cantAgregar,
                                                    descripcion: llanta.descripcion || llanta.Descripci√≥n || '',
                                                    linea: llanta.linea || llanta.Linea || ''
                                                });
                                            }
                                            
                                            volumenUsado += cantAgregar * volUnit;
                                            pesoUsado += cantAgregar * pesoUnit;
                                            llantasAgregadas += cantAgregar;
                                            
                                            console.log(`  ‚úÖ Agregadas ${cantAgregar}x ${llanta.descripcion || llanta.Descripci√≥n}`);
                                        }
                                    }
                                    
                                    // Actualizar totales de la unidad
                                    unidadesValidas[idx].volumenAsignado = (unidadesValidas[idx].volumenAsignado || 0) + volumenUsado;
                                    unidadesValidas[idx].pesoAsignado = (unidadesValidas[idx].pesoAsignado || 0) + pesoUsado;
                                    unidadesValidas[idx].llantasEstimadas = (unidadesValidas[idx].llantasEstimadas || 0) + llantasAgregadas;
                                    
                                    console.log(`üìä Agregadas ${llantasAgregadas} llantas (${volumenUsado.toFixed(2)}m¬≥, ${pesoUsado.toFixed(2)}kg)`);
                                }
                                
                                // === PASO 4: ACTUALIZAR UI ===
                                const cel = contenedorDetalles.querySelector('.econ-' + idx);
                                if (cel) cel.textContent = nuevoEco;
                                if (boton) boton.setAttribute('data-unidades', JSON.stringify(unidadesValidas));

                                // Asegurar que la secci√≥n de Distribuci√≥n Sugerida permanezca desplegada
                                try {
                                    const acordeon = document.getElementById('collapseDistribucionMultiple');
                                    if (acordeon && !acordeon.classList.contains('show')) acordeon.classList.add('show');
                                } catch (e) { /* ignorar */ }
                                
                                // === VALIDACI√ìN: ASEGURAR QUE NO HAY LLANTAS PERDIDAS ===
                                const validacion = validarConteoLlantas(llantasAcumuladasEnBloque || [], unidadesValidas, distribucionBloqueada);
                                if (!validacion.valido) {
                                    console.error(`üö® ALERTA: ${validacion.mensaje} (total: ${validacion.totalOriginal}, en unidades: ${validacion.totalEnUnidades}, bloqueadas: ${validacion.totalEnBloqueadas})`);
                                } else {
                                    console.log(`‚úÖ ${validacion.mensaje}`);
                                }
                                
                                console.log('‚úÖ [RESULTADO] unidadesValidas actualizado:', unidadesValidas[idx]);
                            };
                            
                            sel._handler = handler;
                            sel.addEventListener('change', handler);
                        });
                    } catch (e) { console.warn('Error adjuntando handlers selects distribuci√≥n:', e); }
                }, 50);

                return;
            }

            // Si no se pudo encontrar una distribuci√≥n, mostrar mensaje de error
            contenedorDetalles.innerHTML = `
                <div class="alert alert-warning">
                    <h5><i class="bi bi-exclamation-triangle"></i> No hay suficientes unidades disponibles</h5>
                    <p>La carga total es demasiado grande para las unidades disponibles:</p>
                    <ul>
                        <li>Volumen total: ${volumenTotal.toFixed(2)} m¬≥</li>
                        <li>Peso total: ${pesoTotal.toFixed(2)} kg</li>
                        <li>Cantidad de llantas: ${cantidadTotalLlantas}</li>
                    </ul>
                </div>
            `;
            return;
        }

        // Preparar la visualizaci√≥n de resultados
        console.log('Camiones en distribuci√≥n:', distribucion.distribucion.length);
        console.log('Volumen total:', volumenTotal, 'm¬≥');
        console.log('Peso total:', pesoTotal, 'kg');

        let html = `
            <div class="alert alert-primary mb-3">
                <h5>Resumen de Carga Total:</h5>
                <ul>
                    ${llantasAgregadas.map(llanta => 
                        `<li>${llanta.cantidad} llantas ${llanta.descripcion}</li>`
                    ).join('')}
                    <li><strong>Volumen total de carga:</strong> ${volumenTotal.toFixed(2)} m¬≥</li>
                    <li><strong>Peso total de carga:</strong> ${pesoTotal.toFixed(2)} kg</li>
                    <li><strong>Total de llantas:</strong> ${cantidadTotalLlantas}</li>
                </ul>
            </div>
                <div class="table-responsive">
                    <table class="table table-hover">
                        <thead class="table-primary">
                            <tr>
                                <th>Unidad</th>
                                <th>Econ√≥mico</th>
                                <th>Capacidad Volumen</th>
                                <th>Capacidad Peso</th>
                                <th>Uso Volumen</th>
                                <th>Uso Peso</th>
                                <th>Eficiencia</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody>`;

            // Ordenar camiones por eficiencia (del m√°s eficiente al menos eficiente)
            const camionesViables = camionesDisponibles.sort((a, b) => b.utilizacionPromedio - a.utilizacionPromedio);

            // Agregar clase para resaltar el mejor cami√≥n
            camionesViables.forEach((camion, index) => {
                const rowClass = index === 0 ? 'table-success' : '';
                html += `
                    <tr class="${rowClass}">
                        <td>${camion.unidad || 'Sin nombre'}</td>
                        <td>${camion.economico}</td>
                        <td>${parseFloat(camion.volumen).toFixed(2)} m¬≥</td>
                        <td>${parseFloat(camion["capacidad de carga (kg)"]).toFixed(0)} kg</td>
                        <td>
                            <div class="progress" style="height: 20px;">
                                <div class="progress-bar bg-info" 
                                     role="progressbar" 
                                     style="width: ${camion.porcentajeVolumen}%;"
                                     title="${camion.porcentajeVolumen.toFixed(1)}%">
                                    ${camion.porcentajeVolumen.toFixed(1)}%
                                </div>
                            </div>
                        </td>
                        <td>
                            <div class="progress" style="height: 20px;">
                                <div class="progress-bar bg-warning" 
                                     role="progressbar" 
                                     style="width: ${camion.porcentajePeso}%;"
                                     title="${camion.porcentajePeso.toFixed(1)}%">
                                    ${camion.porcentajePeso.toFixed(1)}%
                                </div>
                            </div>
                        </td>
                        <td>
                            <div class="progress" style="height: 20px;">
                                <div class="progress-bar bg-success" 
                                     role="progressbar" 
                                     style="width: ${camion.utilizacionPromedio}%;"
                                     title="${camion.utilizacionPromedio.toFixed(1)}%">
                                    ${camion.utilizacionPromedio.toFixed(1)}%
                                </div>
                            </div>
                        </td>
                        <td>
                            <button class="btn btn-sm btn-warning" onclick="apartarUnidadConDetalles('${camion.economico}', llantasAgregadas, ${volumenTotal}, ${pesoTotal})">
                                <i class="bi bi-box-arrow-right"></i> Apartar
                            </button>
                        </td>
                    </tr>`;
            });

            html += `
                        </tbody>
                    </table>
                </div>
                
                <div class="alert alert-info mt-3">
                    <h6><i class="bi bi-info-circle"></i> Informaci√≥n:</h6>
                    <ul>
                        <li>La fila resaltada en verde indica la unidad m√°s eficiente</li>
                        <li>La eficiencia se calcula considerando el uso balanceado de volumen y peso</li>
                        <li>Todas las unidades mostradas pueden transportar la carga de forma segura</li>
                    </ul>
                </div>`;

            // Actualizar el contenido
            contenedorDetalles.innerHTML = html;

            // Si hay m√°s opciones viables, mostrarlas
            if (distribucion.distribucion.length > 1) {
                html += `
                    <div class="alert alert-info mt-3">
                        <h6>Resumen de distribuci√≥n:</h6>
                        <div class="table-responsive">
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Unidad</th>
                                        <th>Eficiencia</th>
                                        <th>Volumen</th>
                                        <th>Peso</th>
                                    </tr>
                                </thead>
                                <tbody>`;
                
                // Mostrar resumen de todas las unidades asignadas
                distribucion.distribucion.forEach(camion => {
                    html += `
                        <tr>
                            <td>${camion.unidad || camion.economico}</td>
                            <td>${camion.eficiencia.toFixed(1)}%</td>
                            <td>${(camion.volumenAsignado/camion.volumenNum*100).toFixed(1)}%</td>
                            <td>${(camion.pesoAsignado/camion.capacidadCargaNum*100).toFixed(1)}%</td>
                        </tr>`;
                });

                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>`;
            }

            detallesDiv.innerHTML = html;
        
            contenedorDetalles.innerHTML = `
                <div class="alert alert-warning">
                    <h6><i class="bi bi-exclamation-triangle"></i> No se encontr√≥ un cami√≥n adecuado para la carga especificada.</h6>
                    
                    <div class="card mt-3">
                        <div class="card-header bg-warning">
                            <h6 class="mb-0">Detalles de la Carga</h6>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-6">
                                    <h6>Llantas:</h6>
                                    <ul>
                                        ${llantasAgregadas.map(llanta => 
                                            `<li>${llanta.cantidad} llantas tipo ${llanta.tipoTexto}</li>`
                                        ).join('')}
                                    </ul>
                                </div>
                                <div class="col-md-6">
                                    <h6>Totales:</h6>
                                    <ul>
                                        <li><strong>Volumen requerido:</strong> ${volumenTotal.toFixed(2)} m¬≥</li>
                                        <li><strong>Peso requerido:</strong> ${pesoTotal.toFixed(2)} kg</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="card mt-3">
                        <div class="card-header bg-info text-white">
                            <h6 class="mb-0">An√°lisis y Sugerencias</h6>
                        </div>
                        <div class="card-body">
                            <div class="table-responsive">
                                <table class="table table-sm">
                                    <thead>
                                        <tr>
                                            <th>Problema</th>
                                            <th>Sugerencia</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Exceso de volumen o peso</td>
                                            <td>Dividir la carga en m√∫ltiples unidades m√°s peque√±as</td>
                                        </tr>
                                        <tr>
                                            <td>Capacidad insuficiente</td>
                                            <td>Verificar disponibilidad de unidades m√°s grandes</td>
                                        </tr>
                                        <tr>
                                            <td>Datos incorrectos</td>
                                            <td>Revisar si las cantidades ingresadas son correctas</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>`;
        }
    

    function limpiarFormularioFlota() {
        document.getElementById('agregarEconomico').value = '';
        document.getElementById('agregarUnidad').value = '';
        document.getElementById('agregarAsignado').value = '';
        document.getElementById('agregarModelo').value = '';
        document.getElementById('agregarPlacas').value = '';
        document.getElementById('agregarUbicacion').value = '';
        document.getElementById('agregarCarga').value = '';
        document.getElementById('agregarVolumenCamion').value = '';
    }

    // ---------- Pedidos (igual que antes) ----------
    function buscarUnidadesPedido() {
        const input = document.getElementById('inputPedidoNumEconomico');
        const dropdown = document.getElementById('autocompleteUnidadesPedido');
        const term = input.value.trim().toLowerCase();
        
        if (!term || !Array.isArray(flota) || flota.length === 0) {
            dropdown.style.display = 'none';
            dropdown.innerHTML = '';
            return;
        }
        
        const matches = flota.filter(unit => {
            const eco = (unit.economico || unit.numeroEconomico || '').toString().toLowerCase();
            const unidad = (unit.unidad || '').toString().toLowerCase();
            return eco.includes(term) || unidad.includes(term);
        }).slice(0, 10);
        
        if (matches.length === 0) {
            dropdown.style.display = 'none';
            dropdown.innerHTML = '';
            return;
        }
        
        dropdown.innerHTML = matches.map(unit => {
            const eco = unit.economico || unit.numeroEconomico || '-';
            const nombre = unit.unidad || '-';
            const modelo = unit.modelo || '-';
            return `<div onclick="seleccionarUnidadPedido('${eco}')" style="padding: 10px; border-bottom: 1px solid #eee; cursor: pointer; hover: background: #f5f5f5;">
                <strong>${eco}</strong> - ${nombre} (${modelo})
            </div>`;
        }).join('');
        
        dropdown.style.display = 'block';
    }
    
    function seleccionarUnidadPedido(economico) {
        document.getElementById('inputPedidoNumEconomico').value = economico;
        document.getElementById('autocompleteUnidadesPedido').style.display = 'none';
        llenarDatosCamionPedido();
    }
    
    function llenarDatosCamionPedido() {
        const numEco = document.getElementById('inputPedidoNumEconomico').value.trim();
        const div = document.getElementById('datosCamionPedido');
        pedidoCamion = flota.find(c => c.economico.toString() === numEco);
        if (pedidoCamion) {
          // Asegurar que el n√∫mero econ√≥mico se guarde correctamente en todas las propiedades necesarias
          pedidoCamion.numeroEconomico = numEco;
          pedidoCamion.economico = numEco; // Asegurarnos que economico tambi√©n tenga el valor
          const responsable = pedidoCamion.asignado || pedidoCamion.encargado || '-';
          div.innerText = `Cami√≥n: ${pedidoCamion.unidad}, Num. Econ√≥mico: ${numEco}, Asignado: ${responsable}, Modelo: ${pedidoCamion.modelo}, Capacidad carga: ${pedidoCamion["capacidad de carga (kg)"] || '-'} kg, Cap. volumen: ${pedidoCamion["volumen"] || '-'} m¬≥`;
            renderPedidosActuales();
            actualizarGraficas();
        } else {
            div.innerText = 'Cami√≥n no encontrado.';
            pedidosEnCurso = [];
            renderPedidosActuales();
            actualizarGraficas();
        }
    }
    function autoCompletarLlantaPedidoPorCodigo() {
        const codigo = document.getElementById('pedidoCodigoLlanta').value.trim();
        
        // Si est√° vac√≠o, limpiar datos
        if (!codigo) {
            document.getElementById('pedidoDescripcionLlantaInput').value = '';
            document.getElementById('pedidoLineaLlanta').innerText = '';
            document.getElementById('pedidoPesoLlanta').innerText = '0';
            document.getElementById('pedidoVolumenLlanta').innerText = '0';
            document.getElementById('pedidoValorUnitarioLlanta').innerText = '0';
            ocultarDropdownCodigo();
            return;
        }
        
        // Buscar coincidencias parciales (case-insensitive)
        const codigoLower = codigo.toLowerCase();
        const coincidencias = INVENTARIO.filter(item => 
            item.clave.toString().toLowerCase().includes(codigoLower)
        ).slice(0, 8); // Limitar a 8 resultados
        
        // Si hay coincidencias, mostrar dropdown
        if (coincidencias.length > 0) {
            mostrarDropdownCodigo(coincidencias);
            
            // Si hay coincidencia exacta, auto-rellenar
            const llantaExacta = coincidencias.find(item => 
                item.clave.toString().toLowerCase() === codigoLower
            );
            if (llantaExacta) {
                rellenarDatosLlantaPedido(llantaExacta);
            }
        } else {
            ocultarDropdownCodigo();
            // Limpiar datos si no hay coincidencias
            document.getElementById('pedidoDescripcionLlantaInput').value = '';
            document.getElementById('pedidoLineaLlanta').innerText = '';
            document.getElementById('pedidoPesoLlanta').innerText = '0';
            document.getElementById('pedidoVolumenLlanta').innerText = '0';
            document.getElementById('pedidoValorUnitarioLlanta').innerText = '0';
        }
    }

    function autoCompletarLlantaPedidoPorDescripcion() {
        const descripcion = document.getElementById('pedidoDescripcionLlantaInput').value.trim();
        
        // Si est√° vac√≠o, limpiar datos
        if (!descripcion) {
            document.getElementById('pedidoCodigoLlanta').value = '';
            document.getElementById('pedidoLineaLlanta').innerText = '';
            document.getElementById('pedidoPesoLlanta').innerText = '0';
            document.getElementById('pedidoVolumenLlanta').innerText = '0';
            document.getElementById('pedidoValorUnitarioLlanta').innerText = '0';
            ocultarDropdownDescripcion();
            return;
        }
        
        // Buscar coincidencias parciales (case-insensitive)
        const descripcionLower = descripcion.toLowerCase();
        const coincidencias = INVENTARIO.filter(item => 
            (item.descripcion || '').toLowerCase().includes(descripcionLower)
        ).slice(0, 8); // Limitar a 8 resultados
        
        // Si hay coincidencias, mostrar dropdown
        if (coincidencias.length > 0) {
            mostrarDropdownDescripcion(coincidencias);
            
            // Si hay coincidencia exacta, auto-rellenar
            const llantaExacta = coincidencias.find(item => 
                (item.descripcion || '').toLowerCase() === descripcionLower
            );
            if (llantaExacta) {
                rellenarDatosLlantaPedido(llantaExacta);
            }
        } else {
            ocultarDropdownDescripcion();
            // Limpiar datos si no hay coincidencias
            document.getElementById('pedidoCodigoLlanta').value = '';
            document.getElementById('pedidoLineaLlanta').innerText = '';
            document.getElementById('pedidoPesoLlanta').innerText = '0';
            document.getElementById('pedidoVolumenLlanta').innerText = '0';
            document.getElementById('pedidoValorUnitarioLlanta').innerText = '0';
        }
    }

    // Funci√≥n auxiliar para rellenar datos de llanta en el formulario pedido
    function rellenarDatosLlantaPedido(llanta) {
        document.getElementById('pedidoCodigoLlanta').value = llanta.clave;
        document.getElementById('pedidoDescripcionLlantaInput').value = llanta.descripcion || '';
        document.getElementById('pedidoLineaLlanta').innerText = llanta.linea || '';
        document.getElementById('pedidoCantidadLlanta').value = 1;
        document.getElementById('pedidoPesoLlanta').innerText = Number(llanta.peso || 0).toLocaleString('es-MX', {minimumFractionDigits: 2, maximumFractionDigits: 2});
        document.getElementById('pedidoVolumenLlanta').innerText = Number(llanta.volumen || 0).toLocaleString('es-MX', {minimumFractionDigits: 4, maximumFractionDigits: 4});
        document.getElementById('pedidoValorUnitarioLlanta').innerText = Number(llanta.valor || 0).toLocaleString('es-MX', {minimumFractionDigits: 2, maximumFractionDigits: 2});
        ocultarDropdownCodigo();
        ocultarDropdownDescripcion();
    }

    // Funciones para mostrar/ocultar dropdowns
    function mostrarDropdownCodigo(coincidencias) {
        let dropdownDiv = document.getElementById('dropdownAutocompleteCodigo');
        if (!dropdownDiv) {
            dropdownDiv = document.createElement('div');
            dropdownDiv.id = 'dropdownAutocompleteCodigo';
            dropdownDiv.style.cssText = `
                position: absolute;
                background: white;
                border: 1px solid #ddd;
                border-radius: 4px;
                max-height: 200px;
                overflow-y: auto;
                z-index: 1000;
                min-width: 250px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            `;
            const inputCodigo = document.getElementById('pedidoCodigoLlanta');
            inputCodigo.parentElement.style.position = 'relative';
            inputCodigo.parentElement.appendChild(dropdownDiv);
        }

        dropdownDiv.innerHTML = coincidencias.map(item => {
            const safeClave = String(item.clave || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            return `
            <div onclick="seleccionarLlantaPorCodigo('${safeClave}')" style="
                padding: 8px 12px;
                cursor: pointer;
                border-bottom: 1px solid #eee;
                font-size: 12px;
            " onmouseover="this.style.backgroundColor='#f0f0f0'" onmouseout="this.style.backgroundColor='white'">
                <strong>${item.clave}</strong> ‚Äî ${item.descripcion}
            </div>
        `}).join('');
        
        dropdownDiv.style.display = 'block';
    }

    function mostrarDropdownDescripcion(coincidencias) {
        let dropdownDiv = document.getElementById('dropdownAutocompleteDescripcion');
        if (!dropdownDiv) {
            dropdownDiv = document.createElement('div');
            dropdownDiv.id = 'dropdownAutocompleteDescripcion';
            dropdownDiv.style.cssText = `
                position: absolute;
                background: white;
                border: 1px solid #ddd;
                border-radius: 4px;
                max-height: 200px;
                overflow-y: auto;
                z-index: 1000;
                min-width: 300px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            `;
            const inputDesc = document.getElementById('pedidoDescripcionLlantaInput');
            inputDesc.parentElement.style.position = 'relative';
            inputDesc.parentElement.appendChild(dropdownDiv);
        }

        dropdownDiv.innerHTML = coincidencias.map(item => {
            const safeDesc = String(item.descripcion || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            const safeClave = String(item.clave || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            return `
            <div onclick="seleccionarLlantaPorDescripcion('${safeDesc}')" style="
                padding: 8px 12px;
                cursor: pointer;
                border-bottom: 1px solid #eee;
                font-size: 12px;
            " onmouseover="this.style.backgroundColor='#f0f0f0'" onmouseout="this.style.backgroundColor='white'">
                <strong>${item.clave}</strong> ‚Äî ${item.descripcion}
            </div>
        `}).join('');
        
        dropdownDiv.style.display = 'block';
    }

    function ocultarDropdownCodigo() {
        const dropdown = document.getElementById('dropdownAutocompleteCodigo');
        if (dropdown) dropdown.style.display = 'none';
    }

    function ocultarDropdownDescripcion() {
        const dropdown = document.getElementById('dropdownAutocompleteDescripcion');
        if (dropdown) dropdown.style.display = 'none';
    }

    function seleccionarLlantaPorCodigo(clave) {
        const claveStr = String(clave || '').trim();
        const llanta = INVENTARIO.find(item => String(item.clave || '').toString() === claveStr);
        if (llanta) {
            rellenarDatosLlantaPedido(llanta);
            document.getElementById('pedidoCodigoLlanta').value = llanta.clave;
        }
    }

    function seleccionarLlantaPorDescripcion(descripcion) {
        const descStr = String(descripcion || '').trim();
        // Buscar coincidencia exacta luego por normalizaci√≥n y finalmente por inclusi√≥n
        let llanta = INVENTARIO.find(item => String(item.descripcion || '').trim() === descStr);
        if (!llanta) {
            const descLower = descStr.toLowerCase();
            llanta = INVENTARIO.find(item => String(item.descripcion || '').toLowerCase().trim() === descLower) ||
                     INVENTARIO.find(item => (item.descripcion || '').toLowerCase().includes(descLower));
        }
        if (llanta) {
            rellenarDatosLlantaPedido(llanta);
            document.getElementById('pedidoDescripcionLlantaInput').value = llanta.descripcion || descStr;
        }
    }
    function calcularTotalesPedido() {
    const cantidad = Number(document.getElementById('pedidoCantidadLlanta').value);
    const codigo = document.getElementById('pedidoCodigoLlanta').value.trim();
    const llanta = INVENTARIO.find(item => item.clave.toString() === codigo);
    
    if (llanta && cantidad > 0) {
        // Calcular totales
        document.getElementById('pedidoPesoLlanta').innerText = 
            (safeNum(llanta.peso) * cantidad).toLocaleString('es-MX', {minimumFractionDigits: 2, maximumFractionDigits: 2});
        document.getElementById('pedidoVolumenLlanta').innerText = 
            (safeNum(llanta.volumen) * cantidad).toLocaleString('es-MX', {minimumFractionDigits: 4, maximumFractionDigits: 4});
        document.getElementById('pedidoValorUnitarioLlanta').innerText = 
            (safeNum(llanta.valor) * cantidad).toLocaleString('es-MX', {minimumFractionDigits: 2, maximumFractionDigits: 2});

        // Verificar capacidad preventivamente
        if (pedidoCamion) {
            const volumenTotal = safeNum(llanta.volumen) * cantidad;
            const pesoTotal = safeNum(llanta.peso) * cantidad;
            
            // Calcular totales actuales del pedido
            const pedidoActualVolumen = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.volumen), 0);
            const pedidoActualPeso = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.peso), 0);
            
            // Calcular nuevos totales incluyendo la llanta actual
            const nuevoVolumenTotal = pedidoActualVolumen + volumenTotal;
            const nuevoPesoTotal = pedidoActualPeso + pesoTotal;
            
            // Obtener capacidades del cami√≥n
            const capacidadVolumen = safeNum(pedidoCamion.volumen);
            const capacidadPeso = safeNum(pedidoCamion["capacidad de carga (kg)"]) || safeNum(pedidoCamion.carga);
            
            // Calcular porcentajes
            const porcentajeVolumen = (nuevoVolumenTotal / capacidadVolumen) * 100;
            const porcentajePeso = (nuevoPesoTotal / capacidadPeso) * 100;
            
            // Mostrar advertencia si supera el 95%
            if (porcentajeVolumen > 95 || porcentajePeso > 95) {
                mostrarAlertaCapacidad(
                    capacidadVolumen - nuevoVolumenTotal,
                    capacidadPeso - nuevoPesoTotal,
                    porcentajeVolumen,
                    porcentajePeso
                );
            }
        }
    }
}
async function agregarPedido() {
    if (!pedidoCamion) {
        alert("Ingrese un n√∫mero econ√≥mico v√°lido de cami√≥n primero.");
        return;
    }

    const codigo = document.getElementById('pedidoCodigoLlanta').value.trim();
    const cantidad = Number(document.getElementById('pedidoCantidadLlanta').value);
    
    if (cantidad <= 0) {
        alert("La cantidad debe ser mayor a 0.");
        return;
    }

    let llanta = INVENTARIO.find(item => item.clave.toString() === codigo);
    if (!llanta) {
        // Intenta buscar por descripci√≥n si la b√∫squeda por c√≥digo falla
        const desc = document.getElementById('pedidoDescripcionLlantaInput').value.trim();
        if (desc) {
            llanta = INVENTARIO.find(item => (item.descripcion || '').toLowerCase().includes(desc.toLowerCase()));
        }
        if (!llanta) {
            // Si a√∫n no existe en INVENTARIO, crear una entrada temporal calculada
            const descripcionTemp = document.getElementById('pedidoDescripcionLlantaInput').value.trim() || codigo;
            let volumenTemp = Number(await calcularVolumenLlanta(descripcionTemp)) || 0;
            let pesoTemp = Number(await calcularPesoLlanta(descripcionTemp)) || 0;
            
            // Aplicar defaults si c√°lculo devolvi√≥ 0
            if (!volumenTemp || volumenTemp === 0) volumenTemp = 0.030;
            if (!pesoTemp || pesoTemp === 0) pesoTemp = 10;
            
            llanta = {
                clave: codigo,
                descripcion: descripcionTemp,
                linea: determinarTipoLlanta(descripcionTemp),
                peso: pesoTemp,
                volumen: volumenTemp,
                valor: 0
            };
            console.warn(`[TEMPORAL] Creado item temporal para c√≥digo ${codigo}: vol=${volumenTemp}m¬≥, peso=${pesoTemp}kg`);
            // Asegurar que el item temporal tenga valores unitarios v√°lidos
            llanta = await ensurePesoVolumen(llanta);
        }
    }

    // Calcular volumen y peso adicional
    const volumenAdicional = safeNum(llanta.volumen) * cantidad;
    const pesoAdicional = safeNum(llanta.peso) * cantidad;
    
    // Calcular totales actuales
    const totalVolumenActual = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.volumen), 0);
    const totalPesoActual = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.peso), 0);
    
    // Calcular nuevos totales
    const nuevoVolumenTotal = totalVolumenActual + volumenAdicional;
    const nuevoPesoTotal = totalPesoActual + pesoAdicional;
    
    // Obtener capacidades del cami√≥n
    const capacidadVolumen = safeNum(pedidoCamion.volumen);
    const capacidadPeso = safeNum(pedidoCamion["capacidad de carga (kg)"]) || safeNum(pedidoCamion.carga);
    
    // Calcular porcentajes
    const porcentajeVolumen = (nuevoVolumenTotal / capacidadVolumen) * 100;
    const porcentajePeso = (nuevoPesoTotal / capacidadPeso) * 100;

    // Agregar al pedido
    const pedidoExistente = pedidosEnCurso.find(p => p.clave === llanta.clave);
    // Asegurar valores unitarios v√°lidos antes de actualizar/insertar
    let unidad = {
        descripcion: llanta.descripcion,
        volumen: Number(safeNum(getField(llanta,'volumen'))) || Number(safeNum(llanta.volumen)) || 0,
        peso: Number(safeNum(getField(llanta,'peso'))) || Number(safeNum(llanta.peso)) || 0
    };
    unidad = await ensurePesoVolumen(unidad);

    if (pedidoExistente) {
        pedidoExistente.cantidad += cantidad;
        pedidoExistente.peso = unidad.peso * pedidoExistente.cantidad;
        pedidoExistente.volumen = unidad.volumen * pedidoExistente.cantidad;
        pedidoExistente.valor = safeNum(getField(llanta,'valor')) * pedidoExistente.cantidad;
    } else {
        pedidosEnCurso.push({
            clave: llanta.clave,
            descripcion: llanta.descripcion,
            linea: llanta.linea || '',
            cantidad: cantidad,
            peso: unidad.peso * cantidad,
            volumen: unidad.volumen * cantidad,
            valor: safeNum(getField(llanta,'valor')) * cantidad
        });
    }

    // Mostrar alerta de resumen inmediatamente
    mostrarAlertaCapacidad(
        capacidadVolumen - nuevoVolumenTotal,
        capacidadPeso - nuevoPesoTotal,
        porcentajeVolumen,
        porcentajePeso
    );

    renderPedidosActuales();
    actualizarGraficas();
    resetPedidoInputs();
}
// Modificar la funci√≥n reservarPedidoActual()
// Reemplazar o agregar esta funci√≥n
async function reservarPedidoActual(idx) {
    const pedido = pedidosEnCurso[idx];
    if (!pedido) return;

    try {
        // Buscar primero si el producto pertenece a alg√∫n bloque existente
        const bloqueExistente = bloquestraspasos.find(bloque => 
            bloque.datos.some(p => 
                p.C√≥digo === pedido.clave && 
                p.Descripci√≥n === pedido.descripcion
            )
        );
   
        let nombreReserva;
        if (bloqueExistente) {
            // Si pertenece a un bloque, usar el nombre del bloque
            nombreReserva = `${bloqueExistente.nombre}_1`;
        } else {
            // Si no pertenece a ning√∫n bloque, usar el nombre del folio o factura
            const facturaRelacionada = traspasosParaGuardar.find(f => 
                f.C√≥digo === pedido.clave && 
                f.Descripci√≥n === pedido.descripcion
            );
            nombreReserva = facturaRelacionada ? 
                           `${facturaRelacionada.Folio}_1` : 
                           `${pedido.descripcion.split(' ')[0]}_1`;
        }

        // Preparar datos para la reserva
        const registroReserva = {
            nombre: nombreReserva,
            "C√≥digo": pedido.clave,
            "Descripci√≥n": pedido.descripcion,
            "L√≠nea": pedido.linea,
            "Cantidad": pedido.cantidad,
            "Volumen Total": pedido.volumen,
            "Peso Total": pedido.peso,
            "Valor Total ($)": pedido.valor   
        };
    
        // Guardar en la hoja de reservados
        const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=reservados', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ data: registroReserva })
        });

        if (!res.ok) throw new Error('Error al guardar reserva');

        // Eliminar del pedido en curso
        pedidosEnCurso.splice(idx, 1);
        renderPedidosActuales();
        actualizarGraficas();
        
        alert('Pedido reservado exitosamente como: ' + nombreReserva);

    } catch (error) {
        console.error('Error al reservar:', error);
        alert('Error al reservar el pedido: ' + error.message);
    }
}
function quitarPedido(idx) {
    if (confirm('¬øSeguro que desea quitar esta llanta del pedido?')) {
        pedidosEnCurso.splice(idx, 1);
        renderPedidosActuales();
        actualizarGraficas();
    }
}
   function editarPedido(idx) {
    const pedido = pedidosEnCurso[idx];
    const nuevaCantidad = parseInt(prompt(`Editar cantidad para ${pedido.descripcion}:`, pedido.cantidad));
    if (isNaN(nuevaCantidad) || nuevaCantidad <= 0) return;

    // Buscar la llanta en el INVENTARIO para obtener los valores unitarios
    const llanta = INVENTARIO.find(item => item.clave.toString() === pedido.clave);
    if (!llanta) return;

    // Actualizar los valores del pedido
    pedido.cantidad = nuevaCantidad;
    pedido.peso = safeNum(getField(llanta,'peso')) * nuevaCantidad;
    pedido.volumen = safeNum(getField(llanta,'volumen')) * nuevaCantidad;
    pedido.valor = safeNum(getField(llanta,'valor')) * nuevaCantidad;

    renderPedidosActuales();
    actualizarGraficas();
}
   function renderPedidosActuales() {
       const tbody = document.querySelector('#tablaPedidosActuales tbody');
       if (!tbody) {
           console.error('No se encontr√≥ la tabla de pedidos actuales');
           return;
       }
    
       tbody.innerHTML = '';

       // Renderizar filas de pedidos
       pedidosEnCurso.forEach((pedido, idx) => {
           const tr = document.createElement('tr');
           tr.innerHTML = `
               <td>${pedido.clave || '-'}</td>
               <td>${pedido.descripcion || '-'}</td>
               <td>${pedido.linea || '-'}</td> 
               <td>${pedido.cantidad || 0}</td>
               <td>${(pedido.volumen || pedido.volumen === 0) ? 
                   safeNum(pedido.volumen).toLocaleString('es-MX', 
                   { minimumFractionDigits: 3, maximumFractionDigits: 3 }) : '-'}</td>
               <td>${(pedido.peso || pedido.peso === 0) ? 
                   safeNum(pedido.peso).toLocaleString('es-MX', 
                   { minimumFractionDigits: 3, maximumFractionDigits: 3 }) : '-'}</td>
               <td>${(pedido.valor || pedido.valor === 0) ? 
                   ('$' + safeNum(pedido.valor).toLocaleString('es-MX', 
                   { minimumFractionDigits: 2, maximumFractionDigits: 2 })) : '-'}</td>
              <td>
                  <button onclick="editarPedido(${idx})" class="btn btn-sm btn-primary">Editar</button>
                  <button onclick="quitarPedido(${idx})" class="btn btn-sm btn-danger">Quitar</button>
                  <button onclick="reservarPedidoActual(${idx})" class="btn btn-sm btn-success">Reservar</button>
              </td>
           `;
           tbody.appendChild(tr);
       });

       // Calcular y mostrar totales (centralizado)
       const totales = calcularTotalesPedidos();
       // Actualizar gr√°ficas y verificar capacidad
       actualizarGraficas();
       verificarCapacidad(totales.totalVolumen, totales.totalPeso);
   }
   // ...existing code...
// Despu√©s de renderPedidosActuales() y antes de actualizarGraficas()
function resetPedidoInputs() {
    document.getElementById('pedidoCodigoLlanta').value = '';
    document.getElementById('pedidoDescripcionLlantaInput').value = '';
    document.getElementById('pedidoCantidadLlanta').value = '1';
    document.getElementById('pedidoPesoLlanta').innerText = '0';
    document.getElementById('pedidoVolumenLlanta').innerText = '0';
    document.getElementById('pedidoValorUnitarioLlanta').innerText = '0';
}
// Helper centralizado para limpiar TODO el estado residual
function clearEverything(options = {}) {
    console.log('üßπ [CLEAR EVERYTHING] Iniciando limpieza global...');

    // Arrays/globales conocidos
    try { if (typeof pedidosEnCurso !== 'undefined') pedidosEnCurso = []; } catch(e){}
    try { if (typeof llantasAgregadas !== 'undefined') llantasAgregadas = []; } catch(e){}
    try { if (typeof llantasAcumuladasEnBloque !== 'undefined') llantasAcumuladasEnBloque = []; } catch(e){}
    try { if (typeof distribucionBloqueada !== 'undefined') distribucionBloqueada = []; } catch(e){}
    try { if (typeof traspasosParaGuardar !== 'undefined') traspasosParaGuardar = []; } catch(e){}
    try { if (typeof archivosEscaneados !== 'undefined') archivosEscaneados = []; } catch(e){}
    try { if (typeof bloquesPedidosAgregados !== 'undefined') bloquesPedidosAgregados.clear(); } catch(e){}

    // Window-scoped props
    try { if (typeof window.unidadesBloquedadas !== 'undefined') window.unidadesBloquedadas = {}; } catch(e){}
    try { if (typeof window.llantasCalculadoraTmp !== 'undefined') window.llantasCalculadoraTmp = []; } catch(e){}

    // Timers/intervals que podr√≠an repoblar datos
    try { if (typeof autoUpdateInterval !== 'undefined') { clearInterval(autoUpdateInterval); console.log('Cleared autoUpdateInterval'); } } catch(e){}
    try { if (typeof intervaloActualizacionEscaneos !== 'undefined') { clearInterval(intervaloActualizacionEscaneos); console.log('Cleared intervaloActualizacionEscaneos'); } } catch(e){}

    // localStorage: limpiar claves conocidas y patrones
    try {
        const keys = Object.keys(localStorage);
        keys.forEach(k => {
            const lower = k.toLowerCase();
            if (
                lower.includes('pedido') || lower.includes('llant') || lower.includes('carga') ||
                lower.includes('calc') || lower.includes('bloque') || lower.includes('busqueda') ||
                lower.includes('distribucion') || lower.startsWith('pdf_') || lower.startsWith('cache_') ||
                lower.includes('suger') || lower.includes('reservad')
            ) {
                localStorage.removeItem(k);
                console.log('Removed localStorage key:', k);
            }
        });
    } catch (e) { console.warn('clearEverything: error limpiando localStorage', e); }

    // DOM: elementos comunes a limpiar (tablas, autocompletes, resultados)
    try { const t1 = document.getElementById('tablaPedidos'); if (t1) t1.innerHTML = ''; } catch(e){}
    try { const t2 = document.getElementById('tablaLlantasAgregadas'); if (t2 && t2.querySelector) { const tb = t2.querySelector('tbody'); if (tb) tb.innerHTML = ''; } } catch(e){}
    try { const t3 = document.getElementById('tablaLlantasSeleccionadas'); if (t3 && t3.getElementsByTagName) { const tb = t3.getElementsByTagName('tbody')[0]; if (tb) tb.innerHTML = ''; } } catch(e){}
    try { const autoC = document.getElementById('autocompleteCodigoResultados'); if (autoC) { autoC.innerHTML=''; autoC.style.display='none'; } } catch(e){}
    try { const autoD = document.getElementById('autocompleteDescripcionResultados'); if (autoD) { autoD.innerHTML=''; autoD.style.display='none'; } } catch(e){}
    try { const res = document.getElementById('resultadoBusquedaLlanta'); if (res) res.innerHTML = ''; } catch(e){}
    try { const total = document.getElementById('totalLlantas'); if (total) { total.style.display='none'; total.innerHTML=''; } } catch(e){}

    // Forzar render/update en UIs conocidas
    try { if (typeof renderPedidosActuales === 'function') renderPedidosActuales(); } catch(e){}
    try { if (typeof actualizarGraficas === 'function') actualizarGraficas(); } catch(e){}

    console.log('‚úÖ [CLEAR EVERYTHING] Limpieza global completada');
}
function limpiarPedidosActuales() {
    if (confirm('¬øSeguro que deseas limpiar todos los pedidos actuales del cami√≥n?')) {
        clearEverything();
        // Re-apply any pedidos-specific UI resets
        try { resetPedidoInputs(); } catch (e) {}
        try { const folioPedido = document.getElementById('folioPedido'); if (folioPedido) folioPedido.value = ''; } catch (e) {}
        try { const totalesPedidoElement = document.getElementById('totalesPedido'); if (totalesPedidoElement) totalesPedidoElement.innerText = 'Total cantidad: 0 | Total volumen: 0 m¬≥ | Total peso: 0 kg | Total valor: $0'; } catch (e) {}
        try { if (typeof chartVolumen !== 'undefined' && chartVolumen) { chartVolumen.data.datasets[0].data = [0,100]; chartVolumen.update(); } } catch(e){}
        try { if (typeof chartCarga !== 'undefined' && chartCarga) { chartCarga.data.datasets[0].data = [0,100]; chartCarga.update(); } } catch(e){}
        console.log('‚úÖ [LIMPIAR PEDIDOS] Limpieza completada y delegado a clearEverything');
    }
}
// Agregar despu√©s de las funciones existentes
function toggleVerificacionRapida() {
    const panel = document.getElementById('verificacionRapidaPanel');
    const boton = document.querySelector('button[onclick="toggleVerificacionRapida()"]');
    
    if (panel.style.display === 'none') {
        panel.style.display = 'block';
        boton.innerHTML = '<i class="bi bi-calculator"></i> Ocultar Calculadora R√°pida';
        boton.classList.replace('btn-info', 'btn-secondary');
    } else {
        panel.style.display = 'none';
        boton.innerHTML = '<i class="bi bi-calculator"></i> Mostrar Calculadora R√°pida';
        boton.classList.replace('btn-secondary', 'btn-info');
    }
}

// Calcula totales del pedido de forma centralizada y actualiza la UI
function calcularTotalesPedidos() {
    let totalCantidad = 0, totalVolumen = 0, totalPeso = 0, totalValor = 0;
    pedidosEnCurso.forEach(p => {
        totalCantidad += Number(safeNum(p.cantidad) || 0);
        totalVolumen += Number(safeNum(p.volumen) || 0);
        totalPeso += Number(safeNum(p.peso) || 0);
        totalValor += Number(safeNum(p.valor) || 0);
    });

    const totalesPedidoElement = document.getElementById('totalesPedido');
    if (totalesPedidoElement) {
        totalesPedidoElement.innerText = `Total cantidad: ${totalCantidad.toLocaleString('es-MX')} | Total volumen: ${totalVolumen.toLocaleString('es-MX', { minimumFractionDigits: 3, maximumFractionDigits: 3 })} m¬≥ | Total peso: ${totalPeso.toLocaleString('es-MX', { minimumFractionDigits: 3, maximumFractionDigits: 3 })} kg | Total valor: $${totalValor.toLocaleString('es-MX', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        // tambi√©n guardamos los valores num√©ricos en dataset para uso program√°tico
        totalesPedidoElement.dataset.cantidad = String(totalCantidad);
        totalesPedidoElement.dataset.volumen = String(totalVolumen);
        totalesPedidoElement.dataset.peso = String(totalPeso);
        totalesPedidoElement.dataset.valor = String(totalValor);
    }

    // Log de verificaci√≥n si hay discrepancias (avisos para depuraci√≥n)
    pedidosEnCurso.forEach(p => {
        if ((!p.volumen || Number(safeNum(p.volumen)) === 0) && Number(safeNum(p.cantidad)) > 0) {
            console.warn('Pedido item sin volumen:', p.clave || p.descripcion, p);
        }
        if ((!p.peso || Number(safeNum(p.peso)) === 0) && Number(safeNum(p.cantidad)) > 0) {
            console.warn('Pedido item sin peso:', p.clave || p.descripcion, p);
        }
    });

    return { totalCantidad, totalVolumen, totalPeso, totalValor };
}
// Helper: asegura que un objeto de llanta tenga valores unitarios de peso y volumen
async function ensurePesoVolumen(item) {
    if (!item) return item;
    // Intentar leer valores existentes
    let volumen = Number(safeNum(item.volumen)) || 0;
    let peso = Number(safeNum(item.peso)) || 0;
    const desc = (item.descripcion || item.Descripci√≥n || item.Descripcion || '').toString();

    // Si falta volumen/peso intentar calcular por descripci√≥n
    if ((!volumen || volumen === 0) && desc) {
        try {
            volumen = Number(await calcularVolumenLlanta(desc)) || 0;
        } catch (e) {
            volumen = 0;
        }
    }
    if ((!peso || peso === 0) && desc) {
        try {
            peso = Number(await calcularPesoLlanta(desc)) || 0;
        } catch (e) {
            peso = 0;
        }
    }

    // Aplicar defaults si siguen en 0
    if (!volumen || volumen === 0) volumen = 0.030; // m¬≥ por unidad por defecto
    if (!peso || peso === 0) peso = 10; // kg por unidad por defecto

    item.volumen = Number(volumen);
    item.peso = Number(peso);
    return item;
}
// Agregar despu√©s de las funciones existentes
function verificacionRapida() {
    if (!pedidoCamion) {
        alert('Primero selecciona un cami√≥n');
        return;
    }

    // Panel de entrada m√∫ltiple
    const panelHTML = `
        <div class="card mb-3">
            <div class="card-body" id="combinacionesPanel">
                <div class="row mb-2 combinacion-row">
                    <div class="col-md-3">
                        <label>Cantidad</label>
                        <input type="number" class="form-control cantidad-llanta" value="1" min="1">
                    </div>
                    <div class="col-md-3">
                        <label>Tipo de Llanta</label>
                       <select class="form-control tipo-llanta">
                           <option value="AUTO">Auto particular</option>
                           <option value="SUV_CAMIONETA">SUVs y camionetas</option>
                           <option value="COMERCIAL_LIGERO">Veh√≠culo comercial ligero y camiones peque√±os</option>
                           <option value="PESADO">Camiones pesados y tractocamiones</option>
                           <option value="AGRICOLA_MINERO">Agr√≠cola y minero</option>
                           <option value="CAMARAS">C√°maras</option>
                       </select>
                    </div>
                    <div class="col-md-2 d-flex align-items-end">
                        <button class="btn btn-danger btn-sm" onclick="eliminarCombinacion(this)">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div class="card-footer">
                <button class="btn btn-success" onclick="agregarCombinacion()">
                    <i class="bi bi-plus-circle"></i> Agregar combinaci√≥n
                </button>
                <button class="btn btn-primary" onclick="calcularCombinaciones()">
                    <i class="bi bi-calculator"></i> Calcular capacidad
                </button>
                <button class="btn btn-danger" onclick="limpiarCalculadoraRapida()">
                    <i class="bi bi-trash"></i> Limpiar todo
                </button>
            </div>
        </div>
    `;
    
    const panelActual = document.getElementById('verificacionRapidaPanel');
    panelActual.innerHTML = panelHTML;
}

function agregarCombinacion() {
    const nuevaFila = `
        <div class="row mb-2 combinacion-row">
            <div class="col-md-3">
                <label>Cantidad</label>
                <input type="number" class="form-control cantidad-llanta" value="1" min="1">
            </div>
            <div class="col-md-3">
                <label>Tipo de Llanta</label>
                <select class="form-control tipo-llanta">
                    <option value="AUTO">Auto particular</option>
                    <option value="SUV_gCAMIONETA">SUVs y camionetas</option>
                    <option value="COMERCIAL_LIGERO">Veh√≠culo comercial ligero y camiones peque√±os</option>
                    <option value="PESADO">Camiones pesados y tractocamiones</option>
                    <option value="AGRICOLA_MINERO">Agr√≠cola y minero</option>
                    <option value="CAMARAS">C√°maras</option>
                </select>
            </div>
            <div class="col-md-2 d-flex align-items-end">
                <button class="btn btn-danger btn-sm" onclick="eliminarCombinacion(this)">
                    <i class="bi bi-trash"></i>
                </button>
            </div>
        </div>
    `;
    document.getElementById('combinacionesPanel').insertAdjacentHTML('beforeend', nuevaFila);
}

function eliminarCombinacion(boton) {
    boton.closest('.combinacion-row').remove();
}
function calcularCombinaciones() {
    if (!pedidoCamion) {
        alert('Selecciona un cami√≥n primero');
        return;
    }

    // Valores promedio por tipo
    const valoresPromedio = {
        'AUTO': {
           volumen: 0.030,  // 30 litros = 0.030 m¬≥
           peso: 7         // 7 kg promedio
       },
       'SUV_CAMIONETA': { 
           volumen: 0.045,  // 45 litros = 0.045 m¬≥
           peso: 12.5      // 12.5 kg promedio 
       },
      'COMERCIAL_LIGERO': { 
           volumen: 0.120,  // 120 litros = 0.120 m¬≥     
           peso: 25        // 25 kg promedio
       },
      'PESADO': { 
           volumen: 0.270,  // 279 litros = 0.279 m¬≥
           peso: 40       // 50 kg promedio
       },
      'AGRICOLA_MINERO': { 
           volumen: 1.1,  // 1100 litros = 1.1 m¬≥
           peso: 110        // 110 kg promedio
       },
      'CAMARAS': {
           volumen: 0.010,  // 10 litros = 0.010 m¬≥
           peso: 2         // 2 kg promedio
       }
   };

    let volumenTotal = 0;
    let pesoTotal = 0;
    const detalles = [];

    document.querySelectorAll('.combinacion-row').forEach(row => {
        const cantidad = parseInt(row.querySelector('.cantidad-llanta').value) || 0;
        const tipo = row.querySelector('.tipo-llanta').value;
        
        if (cantidad > 0) {
            const volumenParcial = cantidad * valoresPromedio[tipo].volumen;
            const pesoParcial = cantidad * valoresPromedio[tipo].peso;
            
            volumenTotal += volumenParcial;
            pesoTotal += pesoParcial;
            
            detalles.push({
                tipo,
                cantidad,
                volumen: volumenParcial,
                peso: pesoParcial
            });
        }
    });

    // Calcular capacidades disponibles
    const volumenActual = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.volumen), 0);
    const pesoActual = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.peso), 0);
    const capacidadVolumen = safeNum(pedidoCamion.volumen);
    const capacidadPeso = safeNum(pedidoCamion["capacidad de carga (kg)"]) || safeNum(pedidoCamion.carga);
    const volumenDisponible = capacidadVolumen - volumenActual;
    const pesoDisponible = capacidadPeso - pesoActual;


    const volumenMaximo = volumenDisponible 
    const pesoMaximo = pesoDisponible

    // Generar reporte detallado
    // En la funci√≥n calcularCombinaciones()

    const mensaje = `
        <div class="alert ${volumenTotal <= volumenDisponible && pesoTotal <= pesoDisponible ? 'alert-success' : 'alert-warning'} mt-3">
            <h5>${volumenTotal <= volumenDisponible && pesoTotal <= pesoDisponible ? '‚úÖ El pedido si cabe en la unidad' : '‚ö†Ô∏è El pedido excede la capacidad'}</h5>
            <hr>
            <h6>Desglose por tipo:</h6>
            <ul>
               ${detalles.map(d => `
                   <li>${d.cantidad} llantas tipo ${d.tipo}:
                       <ul>
                           <li>Volumen: ${d.volumen.toFixed(2)} m¬≥</li>
                           <li>Peso: ${d.peso.toFixed(2)} kg</li>
                       </ul>
                   </li>
               `).join('')}
           </ul>
           <hr>  
           <p><b>Totales requeridos:</b></p>
            
           <!-- Barra de progreso para Volumen -->
           <div class="mb-3">
               <label>Ocupaci√≥n de volumen:</label>
               <div class="progress">
                   <div class="progress-bar ${volumenTotal > volumenDisponible ? 'bg-danger' : volumenTotal > volumenDisponible * 0.9 ? 'bg-warning' : 'bg-success'}" 
                        role="progressbar" 
                        style="width: ${Math.min((volumenTotal/volumenDisponible) * 100, 100)}%;" 
                        aria-valuenow="${Math.min((volumenTotal/volumenDisponible) * 100, 100)}" 
                        aria-valuemin="0" 
                        aria-valuemax="100">
                       ${((volumenTotal/volumenDisponible) * 100).toFixed(1)}%
                   </div>
               </div>
               <small>Volumen total: ${volumenTotal.toFixed(2)} m¬≥ de ${volumenDisponible.toFixed(2)} m¬≥ disponibles</small>
           </div>

           <!-- Barra de progreso para Peso -->
           <div class="mb-3">
               <label>Ocupaci√≥n de peso:</label>
               <div class="progress">
                   <div class="progress-bar ${pesoTotal > pesoDisponible ? 'bg-danger' : pesoTotal > pesoDisponible * 0.9 ? 'bg-warning' : 'bg-success'}" 
                        role="progressbar" 
                        style="width: ${Math.min((pesoTotal/pesoDisponible) * 100, 100)}%;" 
                        aria-valuenow="${Math.min((pesoTotal/pesoDisponible) * 100, 100)}" 
                        aria-valuemin="0" 
                        aria-valuemax="100">
                       ${((pesoTotal/pesoDisponible) * 100).toFixed(1)}%
                  </div>
              </div>
              <small>Peso total: ${pesoTotal.toFixed(2)} kg de ${pesoDisponible.toFixed(2)} kg disponibles</small>
          </div>

          ${volumenTotal > volumenDisponible || pesoTotal > pesoDisponible ? `
              <div class="alert alert-danger">
                  <p><b>Exceso:</b></p>
                  ${volumenTotal > volumenDisponible ? `<li>Volumen excedido por ${(volumenTotal - volumenDisponible).toFixed(2)} m¬≥</li>` : ''}
                  ${pesoTotal > pesoDisponible ? `<li>Peso excedido por ${(pesoTotal - pesoDisponible).toFixed(2)} kg</li>` : ''}
              </div>
          ` : ''}
      </div>
  `;

    const resultadoDiv = document.createElement('div');
    resultadoDiv.innerHTML = mensaje;
    
    const panelVerificacion = document.getElementById('verificacionRapidaPanel');
    const resultadoExistente = panelVerificacion.querySelector('.alert');
    if (resultadoExistente) {
        resultadoExistente.remove();    
    }              
    panelVerificacion.appendChild(resultadoDiv);
}

// --- C√°lculo r√°pido: funciones del panel 'calculo-rapido' ---
const VALORES_PROMEDIO_CALC_RAPIDA = {
    'AUTO': { volumen: 0.040, peso: 10 },
    'SUV_CAMIONETA': { volumen: 0.065, peso: 20 },
    'COMERCIAL_LIGERO': { volumen: 0.120, peso: 25 },
    'PESADO': { volumen: 0.270, peso: 120 },
    'AGRICOLA_MINERO': { volumen: 2.1, peso: 110 },
    'CAMARAS': { volumen: 0.010, peso: 2 }
};

let combinacionesCalcRapida = [];

function addCombinationCalcRapida() {
    const tipo = document.getElementById('calcRapidaTipo').value;
    const cantidad = parseInt(document.getElementById('calcRapidaCantidad').value) || 0;
    if (cantidad <= 0) return alert('Ingrese una cantidad v√°lida');

    const promedio = VALORES_PROMEDIO_CALC_RAPIDA[tipo] || { volumen: 0.03, peso: 10 };
    combinacionesCalcRapida.push({ tipo, cantidad, volumenUnit: promedio.volumen, pesoUnit: promedio.peso });
    renderCombinacionesCalcRapida();
}

function renderCombinacionesCalcRapida() {
    const cont = document.getElementById('combinacionesCalcRapidaList');
    const tot = document.getElementById('totalesCalcRapida');
    cont.innerHTML = '';
    let volumenTotal = 0, pesoTotal = 0, cantidadTotal = 0;

    combinacionesCalcRapida.forEach((c, i) => {
        const vol = c.cantidad * c.volumenUnit;
        const p = c.cantidad * c.pesoUnit;
        volumenTotal += vol;
        pesoTotal += p;
        cantidadTotal += c.cantidad;
        const div = document.createElement('div');
        div.className = 'd-flex justify-content-between align-items-center mb-1';
        div.innerHTML = `<div>${c.cantidad} √ó ${c.tipo} &nbsp;&nbsp; (vol ${vol.toFixed(3)} m¬≥, peso ${p.toFixed(1)} kg)</div><div><button class="btn btn-sm btn-danger" onclick="combinacionesCalcRapida.splice(${i},1); renderCombinacionesCalcRapida()">Eliminar</button></div>`;
        cont.appendChild(div);
    });

    tot.innerText = `Totales: ${cantidadTotal} llantas | Volumen: ${volumenTotal.toFixed(3)} m¬≥ | Peso: ${pesoTotal.toFixed(1)} kg`;
    if (combinacionesCalcRapida.length === 0) {
        document.getElementById('resultadoCalcRapida').innerHTML = '';
    }
}

function limpiarCalcRapida() {
    combinacionesCalcRapida = [];
    renderCombinacionesCalcRapida();
    document.getElementById('resultadoCalcRapida').innerHTML = '';
}

async function calcularSugerenciaCalcRapida() {
    if (combinacionesCalcRapida.length === 0) {
        const el = document.getElementById('resultadoCalcRapida');
        if (el) el.innerHTML = '<div class="alert alert-info">Agrega al menos una combinaci√≥n</div>';
        return;
    }

    // Si se est√° agregando en modo 'Seguir agregando', no mostrar sugerencias
    if (typeof activePendingEconomico !== 'undefined' && activePendingEconomico) {
        const el = document.getElementById('resultadoCalcRapida');
        if (el) el.innerHTML = `<div class="alert alert-info">Modo 'Seguir agregando' activo en cami√≥n ${escapeHtml(activePendingEconomico)}. Las llantas se agregar√°n al cami√≥n seleccionado.</div>`;
        return;
    }

    // Totales a asignar
    let volumenTotal = 0, pesoTotal = 0;
    combinacionesCalcRapida.forEach(c => { volumenTotal += c.cantidad * c.volumenUnit; pesoTotal += c.cantidad * c.pesoUnit; });

    let volumenRestante = volumenTotal;
    let pesoRestante = pesoTotal;

    const unidadesDisponibles = await obtenerUnidadesDisponibles();
    if (!unidadesDisponibles || unidadesDisponibles.length === 0) return document.getElementById('resultadoCalcRapida').innerHTML = '<div class="alert alert-danger">No hay unidades disponibles en la flota</div>';

    // Aplicar filtro por ubicaci√≥n si el usuario seleccion√≥ uno en el panel de C√°lculo R√°pido
    const filtroUb = (document.getElementById('calcRapidaFiltroUbicacion') && document.getElementById('calcRapidaFiltroUbicacion').value) ? document.getElementById('calcRapidaFiltroUbicacion').value : 'Todos';
    // Copia y filtrar por ubicaci√≥n
    let unidades = unidadesDisponibles.slice();
    if (filtroUb && filtroUb !== 'Todos') {
        unidades = unidades.filter(u => ((u.ubicacion || '').trim()) === filtroUb);
    }

    // Excluir unidades ya apartadas y ajustar capacidades restando reservas existentes
    function getReservedTotalsForUnit(economico) {
        const key = (economico || '').toString().trim().toLowerCase();
        let vol = 0, pes = 0;
        (pedidosApartados || []).forEach(p => {
            const e = (p['Econ√≥mico'] || p.Economico || p.economico || '').toString().trim().toLowerCase();
            if (e === key) {
                vol += parseFloat(p.Volumen) || 0;
                pes += parseFloat(p.Peso) || 0;
            }
        });
        return { vol, pes };
    }

    function getRemainingCapacityForUnit(unidad) {
        const reserved = getReservedTotalsForUnit(unidad.economico || unidad.codigo || '');
        return { remainingVol: (unidad.capacidadVolumen || 0) - reserved.vol, remainingPeso: (unidad.capacidadPeso || 0) - reserved.pes };
    }

    // Filtrar unidades que ya est√°n dentro de Pedidos Apartados y que no tengan capacidad restante
    unidades = unidades.filter(u => {
        if (estaUnidadApartada(u.economico || u.codigo)) return false;
        const rem = getRemainingCapacityForUnit(u);
        return (rem.remainingVol > 0.0005 && rem.remainingPeso > 0.1);
    });

    // Reemplazar capacidades por las capacidades restantes para el proceso de asignaci√≥n
    unidades = unidades.map(u => {
        const rem = getRemainingCapacityForUnit(u);
        return { ...u, capacidadVolumen: Math.max(0, rem.remainingVol), capacidadPeso: Math.max(0, rem.remainingPeso) };
    });

    // ===== NUEVA L√ìGICA: PRIORITIZAR UNIDADES QUE PUEDEN LLEVAR TODA LA CARGA =====
    // Si existe al menos una unidad que pueda cargar TODO (vol + peso), mostrar esas opciones
    // ordenadas por mejor aprovechamiento (mayor % de uso promedio) y evitar dividir en varias unidades.
    const unidadesCompletas = unidades.filter(u => (u.capacidadVolumen || 0) >= volumenTotal && (u.capacidadPeso || 0) >= pesoTotal);
    if (unidadesCompletas.length > 0) {
        // Calcular puntuaci√≥n por aprovechamiento y ordenar descendente
        unidadesCompletas.forEach(u => {
            const usoVol = u.capacidadVolumen > 0 ? (volumenTotal / u.capacidadVolumen) * 100 : 0;
            const usoPes = u.capacidadPeso > 0 ? (pesoTotal / u.capacidadPeso) * 100 : 0;
            u._aprovechamiento = ((usoVol + usoPes) / 2) || 0;
        });
        unidadesCompletas.sort((a, b) => b._aprovechamiento - a._aprovechamiento);

        // Construir HTML que muestre las unidades capaces de llevar todo
        let html = `<div class="mb-2"><b>Volumen requerido:</b> ${volumenTotal.toFixed(3)} m¬≥ | <b>Peso requerido:</b> ${pesoTotal.toFixed(1)} kg</div>`;
        html += '<div class="alert alert-success">A continuaci√≥n se muestran las unidades m√°s √≥ptimas para llevar el pedido.</div>';
        html += '<table class="table table-sm"><thead><tr><th>Unidad</th><th>Economico</th><th>Uso estimado Vol.</th><th>Uso estimado Peso</th><th>Uso promedio</th><th>Acci√≥n</th></tr></thead><tbody>';

        unidadesCompletas.forEach(u => {
            const usoVol = u.capacidadVolumen > 0 ? Math.min(100, (volumenTotal / u.capacidadVolumen) * 100) : 0;
            const usoPes = u.capacidadPeso > 0 ? Math.min(100, (pesoTotal / u.capacidadPeso) * 100) : 0;
            const avg = ((usoVol + usoPes) / 2) || 0;
            html += `
                <tr>
                    <td>${u.nombre || u.unidad || 'Sin nombre'}</td>
                    <td>${u.economico || u.codigo || ''}</td>
                    <td>${usoVol.toFixed(1)}%</td>
                    <td>${usoPes.toFixed(1)}%</td>
                    <td>${avg.toFixed(1)}%</td>
                    <td><button class="btn btn-sm btn-success" onclick="apartarUnidadCalcRapida('${(u.economico||u.codigo||'').toString().replace(/'/g, "\\'")}', ${Math.min(volumenTotal, u.capacidadVolumen).toFixed(3)}, ${Math.min(pesoTotal, u.capacidadPeso).toFixed(1)})"><i class="bi bi-box-arrow-right"></i> Apartar</button></td>
                </tr>
            `;
        });

        html += '</tbody></table>';

        // Tambi√©n mostrar otras unidades ordenadas por potencial de utilidad (mejor primero)
        const otras = unidadesDisponibles.filter(u => !unidadesCompletas.some(uc => String(uc.economico||uc.codigo) === String(u.economico||u.codigo))).map(u => {
            const potencialUsoVol = u.capacidadVolumen > 0 ? Math.min(100, (volumenTotal / u.capacidadVolumen) * 100) : 0;
            const potencialUsoPes = u.capacidadPeso > 0 ? Math.min(100, (pesoTotal / u.capacidadPeso) * 100) : 0;
            return { u, puntuacion: ((potencialUsoVol + potencialUsoPes) / 2) || 0 };
        }).filter(x => {
            // Excluir unidades que no tienen capacidad restante
            if (estaUnidadApartada(x.u.economico || x.u.codigo)) return false;
            const reserved = (function(u2){
                const key2 = (u2.economico || u2.codigo || '').toString().trim().toLowerCase();
                let vol = 0, pes = 0;
                (pedidosApartados || []).forEach(p => {
                    const e = (p['Econ√≥mico'] || p.Economico || p.economico || '').toString().trim().toLowerCase();
                    if (e === key2) { vol += parseFloat(p.Volumen) || 0; pes += parseFloat(p.Peso) || 0; }
                });
                return { remainingVol: (u2.capacidadVolumen || 0) - vol, remainingPeso: (u2.capacidadPeso || 0) - pes };
            })(x.u);
            return reserved.remainingVol > 0.0005 && reserved.remainingPeso > 0.1;
        });

        otras.sort((a,b) => b.puntuacion - a.puntuacion);
        if (otras.length > 0) {
            html += '<hr><h6>Otras unidades ordenadas por potencial</h6><div class="row">';
            otras.forEach(item => {
                const u = item.u;
                const potencialUsoVol = u.capacidadVolumen > 0 ? Math.min(100, (volumenTotal / u.capacidadVolumen) * 100) : 0;
                const potencialUsoPes = u.capacidadPeso > 0 ? Math.min(100, (pesoTotal / u.capacidadPeso) * 100) : 0;
                const avgPot = ((potencialUsoVol + potencialUsoPes) / 2) || 0;
                html += `
                    <div class="col-md-6 mb-2">
                        <div class="d-flex justify-content-between align-items-center mb-1">
                            <div><strong>${u.nombre || u.unidad || 'Sin nombre'}</strong> ‚Äî ${u.economico || u.codigo || ''}</div>
                            <div><button class="btn btn-sm btn-success" onclick="apartarUnidadCalcRapida('${(u.economico||u.codigo||'').toString().replace(/'/g, "\\'")}', ${Math.min(volumenTotal, u.capacidadVolumen).toFixed(3)}, ${Math.min(pesoTotal, u.capacidadPeso).toFixed(1)})"><i class="bi bi-box-arrow-right"></i> Apartar</button></div>
                        </div>
                        <div class="d-flex gap-2 align-items-center">
                            <div style="flex:1">
                                <small>Vol.: ${potencialUsoVol.toFixed(1)}%</small>
                                <div class="progress" style="height:8px;"><div class="progress-bar ${potencialUsoVol > 90 ? 'bg-danger' : potencialUsoVol > 75 ? 'bg-warning' : 'bg-success'}" style="width:${potencialUsoVol}%;"></div></div>
                            </div>
                            <div style="flex:1">
                                <small>Peso: ${potencialUsoPes.toFixed(1)}%</small>
                                <div class="progress" style="height:8px;"><div class="progress-bar ${potencialUsoPes > 90 ? 'bg-danger' : potencialUsoPes > 75 ? 'bg-warning' : 'bg-success'}" style="width:${potencialUsoPes}%;"></div></div>
                            </div>
                            <div style="width:56px;text-align:center;font-weight:bold">${avgPot.toFixed(0)}%</div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
        }

        document.getElementById('resultadoCalcRapida').innerHTML = html;
        return; // No dividir en m√∫ltiples unidades cuando hay al menos una que puede llevar todo
    }

    // ===== CASO: NO HAY UNIDADES QUE LLEVEN TODO, proceder con distribuci√≥n m√∫ltiple =====
    const distribucion = [];

    while ((volumenRestante > 0.0005 && pesoRestante > 0.1) && unidades.length > 0) {
        unidades.sort((a,b) => {
            const eA = Math.min(volumenRestante / a.capacidadVolumen, pesoRestante / a.capacidadPeso);
            const eB = Math.min(volumenRestante / b.capacidadVolumen, pesoRestante / b.capacidadPeso);
            return Math.abs(1 - eA) - Math.abs(1 - eB);
        });

        const unidad = unidades.shift();
        if (!unidad || unidad.capacidadVolumen <= 0 || unidad.capacidadPeso <= 0) continue;

        const volumenAsignable = Math.min(volumenRestante, unidad.capacidadVolumen);
        const pesoAsignable = Math.min(pesoRestante, unidad.capacidadPeso);
        const proporcionCarga = Math.min(volumenAsignable / volumenRestante, pesoAsignable / pesoRestante);
        const volumenAsignado = volumenRestante * proporcionCarga;
        const pesoAsignado = pesoRestante * proporcionCarga;

        distribucion.push({ unidad, volumenAsignado, pesoAsignado, eficienciaVolumen: (volumenAsignado / unidad.capacidadVolumen) * 100, eficienciaPeso: (pesoAsignado / unidad.capacidadPeso) * 100 });

        volumenRestante -= volumenAsignado;
        pesoRestante -= pesoAsignado;
    }

    // Mostrar resultado con barras de uso por unidad
    let html = '';
    if (distribucion.length === 0) {
        html = '<div class="alert alert-warning">No se pudo asignar carga con las unidades disponibles</div>';
    } else {
        html = `<div class="mb-2"><b>Volumen requerido:</b> ${volumenTotal.toFixed(3)} m¬≥ | <b>Peso requerido:</b> ${pesoTotal.toFixed(1)} kg</div>`;
        html += '<table class="table table-sm"><thead><tr><th>Unidad</th><th>Economico</th><th>Volumen asignado</th><th>Peso asignado</th><th>Uso Vol.</th><th>Uso Pes.</th><th>Eficiencia</th><th>Acciones</th></tr></thead><tbody>'; 
        distribucion.forEach((d, idx) => {
            const usoVol = d.unidad.capacidadVolumen > 0 ? (d.volumenAsignado / d.unidad.capacidadVolumen) * 100 : 0;
            const usoPes = d.unidad.capacidadPeso > 0 ? (d.pesoAsignado / d.unidad.capacidadPeso) * 100 : 0;
            const eficiencia = ((usoVol + usoPes) / 2) || 0;
            html += `
                <tr>
                    <td>${d.unidad.nombre || d.unidad.unidad || 'Sin nombre'}</td>
                    <td>${d.unidad.economico || d.unidad.codigo || ''}</td>
                    <td>${d.volumenAsignado.toFixed(3)} m¬≥</td>
                    <td>${d.pesoAsignado.toFixed(1)} kg</td>
                    <td style="min-width:120px;">
                        <div class="progress" style="height:8px;">
                            <div class="progress-bar ${usoVol > 90 ? 'bg-danger' : usoVol > 75 ? 'bg-warning' : 'bg-success'}" role="progressbar" style="width: ${Math.min(usoVol,100)}%;" aria-valuenow="${Math.min(usoVol,100)}" aria-valuemin="0" aria-valuemax="100"></div>
                        </div>
                        <small>${usoVol.toFixed(1)}% del vol.</small>
                    </td>
                    <td style="min-width:120px;">
                        <div class="progress" style="height:8px;">
                            <div class="progress-bar ${usoPes > 90 ? 'bg-danger' : usoPes > 75 ? 'bg-warning' : 'bg-success'}" role="progressbar" style="width: ${Math.min(usoPes,100)}%;" aria-valuenow="${Math.min(usoPes,100)}" aria-valuemin="0" aria-valuemax="100"></div>
                        </div>
                        <small>${usoPes.toFixed(1)}% del peso</small>
                    </td>
                    <td>${eficiencia.toFixed(1)}%</td>
                    <td style="width:120px;">
                        <button class="btn btn-sm btn-success" onclick="apartarUnidadCalcRapida('${(d.unidad.economico||d.unidad.codigo||'').toString().replace(/'/g, "\\'")}', ${Number(d.volumenAsignado.toFixed(3))}, ${Number(d.pesoAsignado.toFixed(1))})">
                            <i class="bi bi-box-arrow-right"></i> Apartar
                        </button>
                    </td>
                </tr>
            `;
        });
        html += '</tbody></table>';

        // Mostrar otras unidades disponibles que no fueron usadas en la distribuci√≥n
        const usadas = distribucion.map(d => (d.unidad.economico || d.unidad.codigo || '').toString());
        // Excluir unidades apartadas y las que no tengan capacidad restante (basado en reservas)
        const otras = unidadesDisponibles.filter(u => {
            const key = (u.economico || u.codigo || '').toString();
            if (usadas.includes(key)) return false;
            if (estaUnidadApartada(u.economico || u.codigo)) return false;
            const rem = (function(u2){
                const key2 = (u2.economico || u2.codigo || '').toString().trim().toLowerCase();
                let vol = 0, pes = 0;
                (pedidosApartados || []).forEach(p => {
                    const e = (p['Econ√≥mico'] || p.Economico || p.economico || '').toString().trim().toLowerCase();
                    if (e === key2) { vol += parseFloat(p.Volumen) || 0; pes += parseFloat(p.Peso) || 0; }
                });
                return { remainingVol: (u2.capacidadVolumen || 0) - vol, remainingPeso: (u2.capacidadPeso || 0) - pes };
            })(u);
            return rem.remainingVol > 0.0005 && rem.remainingPeso > 0.1;
        });

        // Ordenar 'otras' por potencial de utilidad (mejor primero)
        otras.sort((a,b) => {
            const potA = ((volumenTotal / (a.capacidadVolumen || 1)) * 100 + (pesoTotal / (a.capacidadPeso || 1)) * 100) / 2;
            const potB = ((volumenTotal / (b.capacidadVolumen || 1)) * 100 + (pesoTotal / (b.capacidadPeso || 1)) * 100) / 2;
            return potB - potA;
        });

        if (otras.length > 0) {
            html += '<hr><h6>Otras unidades disponibles (potencial)</h6><div class="row">';
            otras.forEach(u => {
                const potencialUsoVol = u.capacidadVolumen > 0 ? Math.min(100, (volumenTotal / u.capacidadVolumen) * 100) : 0;
                const potencialUsoPes = u.capacidadPeso > 0 ? Math.min(100, (pesoTotal / u.capacidadPeso) * 100) : 0;
                const avgPot = ((potencialUsoVol + potencialUsoPes) / 2) || 0;
                html += `
                    <div class="col-md-6 mb-2">
                        <div class="d-flex justify-content-between align-items-center mb-1">
                            <div><strong>${u.nombre || u.unidad || 'Sin nombre'}</strong> ‚Äî ${u.economico || u.codigo || ''}</div>
                            <div><button class="btn btn-sm btn-success" onclick="apartarUnidadCalcRapida('${(u.economico||u.codigo||'').toString().replace(/'/g, "\\'")}', ${Math.min(volumenTotal, u.capacidadVolumen).toFixed(3)}, ${Math.min(pesoTotal, u.capacidadPeso).toFixed(1)})"><i class="bi bi-box-arrow-right"></i> Apartar</button></div>
                        </div>
                        <div class="d-flex gap-2 align-items-center">
                            <div style="flex:1">
                                <small>Vol.: ${potencialUsoVol.toFixed(1)}%</small>
                                <div class="progress" style="height:8px;"><div class="progress-bar ${potencialUsoVol > 90 ? 'bg-danger' : potencialUsoVol > 75 ? 'bg-warning' : 'bg-success'}" style="width:${potencialUsoVol}%;"></div></div>
                            </div>
                            <div style="flex:1">
                                <small>Peso: ${potencialUsoPes.toFixed(1)}%</small>
                                <div class="progress" style="height:8px;"><div class="progress-bar ${potencialUsoPes > 90 ? 'bg-danger' : potencialUsoPes > 75 ? 'bg-warning' : 'bg-success'}" style="width:${potencialUsoPes}%;"></div></div>
                            </div>
                            <div style="width:56px;text-align:center;font-weight:bold">${avgPot.toFixed(0)}%</div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
        }

        if (volumenRestante > 0.001 || pesoRestante > 0.5) {
            html += `<div class="alert alert-danger mt-2">Quedan ${volumenRestante.toFixed(3)} m¬≥ y ${pesoRestante.toFixed(1)} kg sin asignar</div>`;
        }
    }

    document.getElementById('resultadoCalcRapida').innerHTML = html;
}

function renderCalculoRapido() {
    // Reset visual state al entrar
    renderCombinacionesCalcRapida();
    document.getElementById('resultadoCalcRapida').innerHTML = '';
    // Reconstruir una lista compacta de unidades pendientes si existen pendingAsignaciones
    try {
        unidadesPendientes = [];
        Object.keys(pendingAsignaciones || {}).forEach(eco => {
            const arr = pendingAsignaciones[eco] || [];
            if (!arr || arr.length === 0) return;
            const unidadNombre = arr[0].Unidad || '';
            const cliente = arr[0].Nombre || '';
            const fecha = arr[0].Fecha || '';
            let totalVol = 0, totalPeso = 0, totalLlantas = 0;
            const descSet = new Set();
            arr.forEach(it => {
                totalVol += safeNum(it.Volumen || it.volumen || 0);
                totalPeso += safeNum(it.Peso || it.peso || 0);
                totalLlantas += parseInt(it.Llantas || it.llantas || 0) || 0;
                if (it.Descripcion) descSet.add(String(it.Descripcion));
            });
            unidadesPendientes.push({
                Fecha: fecha,
                Unidad: unidadNombre,
                'Econ√≥mico': eco,
                Cliente: cliente,
                Nombre: cliente,
                Llantas: totalLlantas.toString(),
                Descripcion: Array.from(descSet).join('; '),
                Volumen: Number(totalVol || 0).toFixed(3),
                Peso: Number(totalPeso || 0).toFixed(1)
            });
        });
    } catch(e) { console.warn('No se pudo reconstruir unidadesPendientes al entrar en CalcRapida', e); }

    try { renderUnidadesPendientes(); } catch(e) { console.warn('No se pudo renderizar unidades pendientes en CalcRapida', e); }
}

// Variables globales adicionales

// Funci√≥n principal de procesamiento
// Fallback: parsear texto plano tipo tabla para l√≠neas "CANTIDAD  C√ìDIGO  DESCRIPCI√ìN"
function parseProductsFromPlainText(text) {
    try {
        // Normalizar saltos y obtener l√≠neas
        let rawLines = text.replace(/\r/g, '\n').split(/\n+/).map(l => l.replace(/\u00A0/g,' ').trim());
        // Filtrar l√≠neas vac√≠as
        rawLines = rawLines.filter(Boolean);

        // Unir l√≠neas de continuaci√≥n: si una l√≠nea NO empieza con un n√∫mero (cantidad),
        // se considera continuaci√≥n de la l√≠nea anterior y se concatena.
        const lines = [];
        for (const ln of rawLines) {
            if (/^\s*\d+[\d\.,]*\s+/.test(ln)) {
                lines.push(ln);
            } else {
                // Continuaci√≥n: unir con la previa si existe
                if (lines.length > 0) {
                    lines[lines.length - 1] = (lines[lines.length - 1] + ' ' + ln).trim();
                } else {
                    // Si no hay previa, agregar la l√≠nea suelta
                    lines.push(ln);
                }
            }
        }
        const products = [];

        // Regex mejorada: cantidad (entero o decimal, comas/puntos), luego c√≥digo (letras/n√∫meros/./-/\/:()), luego descripci√≥n (resto)
        const rowRegexes = [
            /^(\d+[\d\.,]*)\s+([A-Z0-9\-\./\\()]{2,})\s+(.+)$/i,
            // Caso alterno: columna c√≥digo puede estar entre par√©ntesis despu√©s de cantidad
            /^(\d+[\d\.,]*)\s+(.{3,20})\s+([A-Z0-9\-\./\\()]{2,})\s+(.+)$/i
        ];

        for (let line of lines) {
            // Normalizar m√∫ltiples espacios y tabs
            line = line.replace(/\t+/g, ' ').replace(/\s{2,}/g, ' ');

            let matched = false;
            for (const rx of rowRegexes) {
                const m = line.match(rx);
                if (m) {
                    // Si la regex devuelve 3 grupos: cantidad,codigo,descr
                    if (m.length >= 4) {
                        // Detectar qu√© grupo es cu√°l seg√∫n la regex usada
                        if (rx === rowRegexes[0]) {
                            products.push({ cantidad: m[1], codigo: m[2], descripcion: m[3] });
                        } else {
                            // Rx alterna (cantidad, col1, codigo, descripcion)
                            products.push({ cantidad: m[1], codigo: m[3], descripcion: m[4] });
                        }
                        matched = true;
                        break;
                    }
                }
            }
             // Intentar extraer con heur√≠stica: n√∫mero al inicio + √∫ltima columna larga como descripci√≥n
            if (!matched) {
                const heur = line.match(/^(\d+[\d\.,]*)\s+(.+)$/);
                if (heur) {
                    const rest = heur[2];
                    // intentar dividir rest en c√≥digo + descripci√≥n por la primera secuencia alfanum√©rica corta
                    const parts = rest.split(/\s+/);
                    if (parts.length >= 2) {
                        const possibleCode = parts[0];
                        const possibleDesc = parts.slice(1).join(' ');
                        if (possibleCode.length >= 2 && possibleDesc.length > 3) {
                            products.push({ cantidad: heur[1], codigo: possibleCode, descripcion: possibleDesc });
                        }
                    }
                }
            }
        }

        return products;
    } catch (e) {
        console.warn('parseProductsFromPlainText error', e);
        return [];
    }
}

// Utilidad para evitar inyecci√≥n en el log (ubicada en el scope de <script>)
function escapeHtml(str) {
    if (!str) return '';
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

// Intento robusto: reconstruir filas basadas en posiciones X/Y devueltas por PDF.js
function parseProductsFromPdfjsItems(items) {
    try {
        if (!items || items.length === 0) return [];

        // Mapear items a {x,y,text}
        const mapped = items.map(it => ({
            text: (it.str || '').trim(),
            x: (it.transform && it.transform[4]) ? Math.round(it.transform[4]) : 0,
            y: (it.transform && it.transform[5]) ? Math.round(it.transform[5]) : 0
        })).filter(i => i.text);

        if (mapped.length === 0) return [];

        // Agrupar por l√≠nea seg√∫n Y (tolerancia de 2 px)
        const linesMap = new Map();
        for (const it of mapped) {
            // redondear Y a m√∫ltiplos de 3 para agrupar l√≠neas cercanas
            const yKey = Math.round(it.y / 3) * 3;
            if (!linesMap.has(yKey)) linesMap.set(yKey, []);
            linesMap.get(yKey).push(it);
        }

        // Obtener todos los X para clustering
        const allXs = Array.from(new Set(mapped.map(m => m.x))).sort((a,b) => a - b);

        // Funcion simple para dividir X en hasta 3 clusters por los gaps mayores
        function clusterXPositions(xs, maxClusters = 3) {
            if (xs.length === 0) return [];
            if (xs.length <= maxClusters) return xs.map(x => ({ min: x - 1, max: x + 1 }));
            // calcular diferencias
            const diffs = [];
            for (let i = 1; i < xs.length; i++) diffs.push({ idx: i, gap: xs[i] - xs[i-1] });
            // elegir los (maxClusters-1) mayores saltos
            diffs.sort((a,b) => b.gap - a.gap);
            const splitIdxs = diffs.slice(0, maxClusters - 1).map(d => d.idx).sort((a,b) => a - b);
            const clusters = [];
            let start = 0;
            for (const si of splitIdxs) {
                const clusterXs = xs.slice(start, si);
                clusters.push({ min: clusterXs[0] - 2, max: clusterXs[clusterXs.length - 1] + 2 });
                start = si;
            }
            const lastXs = xs.slice(start);
            if (lastXs.length) clusters.push({ min: lastXs[0] - 2, max: lastXs[lastXs.length - 1] + 2 });
            return clusters;
        }

        const clusters = clusterXPositions(allXs, 3);
        if (!clusters || clusters.length === 0) return [];

        // Para cada linea, asignar textos a clusters por X y reconstruir columnas
        const products = [];
        const sortedYKeys = Array.from(linesMap.keys()).sort((a,b) => b - a).reverse();
        for (const yKey of sortedYKeys) {
            const rowItems = linesMap.get(yKey).sort((a,b) => a.x - b.x);
            const cols = clusters.map(() => []);
            for (const it of rowItems) {
                // encontrar cluster que contiene la x
                let assigned = false;
                for (let ci = 0; ci < clusters.length; ci++) {
                    const r = clusters[ci];
                    if (it.x >= r.min && it.x <= r.max) {
                        cols[ci].push(it.text);
                        assigned = true;
                        break;
                    }
                }
                if (!assigned) {
                    // asignar al cluster m√°s cercana por distancia
                    let best = 0; let bestDist = Infinity;
                    for (let ci = 0; ci < clusters.length; ci++) {
                        const mid = (clusters[ci].min + clusters[ci].max) / 2;
                        const d = Math.abs(it.x - mid);
                        if (d < bestDist) { best = ci; bestDist = d; }
                    }
                    cols[best].push(it.text);
                }
            }

            // construir strings por columna
            const colStrs = cols.map(ca => ca.join(' ').replace(/\s+/g, ' ').trim());
            // heuristica: columna0=cantidad numerica, columna1=codigo corto alfanum, columna2=descripcion larga
            const c0 = colStrs[0] || '';
            const c1 = colStrs[1] || '';
            const c2 = colStrs[2] || '';

            const cantidadMatch = c0.match(/\d+[\d\.,]*/);
            const codigoCandidate = c1 || (c0 && !cantidadMatch ? c0 : '');
            const descripcionCandidate = c2 || (c1 && c1.length > 6 ? c1 : '');

            if (cantidadMatch && codigoCandidate && descripcionCandidate) {
                const cantidad = cantidadMatch[0].replace(/,/g, '.');
                products.push({ cantidad, codigo: codigoCandidate.trim(), descripcion: descripcionCandidate.trim() });
            }
        }

        return products;
    } catch (e) {
        console.warn('parseProductsFromPdfjsItems error', e);
        return [];
    }
}


async function processFiles() {
    const files = document.getElementById('fileInput').files;
    if (!files.length) return alert("Selecciona al menos un PDF");
    
    const logDiv = document.getElementById("log");
    logDiv.innerHTML = "";
    logDiv.style.display = "block";

    try {
        for (const file of files) {
            const isImage = file.type && file.type.startsWith('image/');
            const isPDF = file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf');
            // Usar una clave de cach√© distinta para im√°genes
            const cacheKey = `${isImage ? 'img' : 'pdf'}_${file.name}_${file.lastModified}`;
            const cachedData = getCache(cacheKey);
            
            if (cachedData) {
                escaneosActuales.push(...cachedData);
                logDiv.innerHTML += `
                    <div class="alert alert-info">
                        <h6>Archivo: ${file.name}</h6>
                        <p>‚úì Usando datos en cach√© (${cachedData.length} productos)</p>
                    </div>`;
                continue;
            }

            logDiv.innerHTML += `<p>Procesando: ${file.name}...</p>`;
            
            try {
                // Valores por defecto
                let fecha = null;
                let productosParsed = [];

                if (isImage) {
                    // Manejo de im√°genes (escaneos en formato imagen)
                    try {
                        const resImg = await extractDataFromImage(file, logDiv);
                        fecha = resImg.fecha || null;
                        productosParsed = resImg.productos || [];
                    } catch (imgErr) {
                        console.warn('Error al procesar imagen:', imgErr);
                    }
                } else {
                    // Mantener todo el flujo existente para PDFs (texto -> parse por posiciones -> fallback OCR)
                    const { fecha: fechaPdf, productos } = await extractDataFromPDF(file);
                    fecha = fechaPdf;
                    productosParsed = productos || [];

                    // Si no se extrajeron productos, intentar fallback: extraer texto con pdfjs y parsear l√≠neas tipo tabla
                    if (!productosParsed || productosParsed.length === 0) {
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                            let fullText = '';
                            const itemsAll = [];
                            for (let p = 1; p <= pdf.numPages; p++) {
                                const page = await pdf.getPage(p);
                                const content = await page.getTextContent();
                                fullText += content.items.map(i => i.str).join(' ') + '\n';
                                // almacenar items para parsing por posiciones
                                if (Array.isArray(content.items)) {
                                    itemsAll.push(...content.items);
                                }
                            }

                            // Intentar parsear usando posiciones X/Y (m√°s robusto para PDFs digitales)
                            try {
                                const byPos = parseProductsFromPdfjsItems(itemsAll);
                                if (byPos && byPos.length > 0) {
                                    productosParsed = byPos;
                                }
                            } catch (e) {
                                console.warn('parse by positions failed', e);
                            }

                            // Si no hubo √©xito por posiciones, intentar parse simple por l√≠neas
                            if (!productosParsed || productosParsed.length === 0) {
                                const fallback = parseProductsFromPlainText(fullText);
                                if (fallback && fallback.length > 0) {
                                    productosParsed = fallback;
                                }
                            }
                            // Mostrar texto bruto extra√≠do para depuraci√≥n (colapsable en el log)
                            try {
                                const dbgId = 'dbg_raw_' + Math.random().toString(36).slice(2,9);
                                logDiv.innerHTML += `
                                    <details id="${dbgId}" style="margin:6px 0;">
                                        <summary>Ver texto RAW extra√≠do (fallback)</summary>
                                        <pre style="max-height:200px;overflow:auto;background:#f8f9fa;padding:8px;border:1px solid #eee">${escapeHtml(fullText)}</pre>
                                    </details>`;
                            } catch(e) { console.warn('No se pudo insertar texto RAW en log', e); }
                            } catch (fbErr) {
                            console.warn('Fallback de texto fall√≥:', fbErr);
                        }

                        // Si a√∫n no se extrajeron productos, intentar OCR con Tesseract (m√°s lento pero robusto)
                        if ((!productosParsed || productosParsed.length === 0) && window.Tesseract) {
                            try {
                                let ocrText = '';
                                const arrayBuffer2 = await file.arrayBuffer();
                                const pdf2 = await pdfjsLib.getDocument({ data: arrayBuffer2 }).promise;
                                for (let pageNumOcr = 1; pageNumOcr <= pdf2.numPages; pageNumOcr++) {
                                    const pageO = await pdf2.getPage(pageNumOcr);
                                    const viewport = pageO.getViewport({ scale: 2 });
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    canvas.width = Math.floor(viewport.width);
                                    canvas.height = Math.floor(viewport.height);
                                    await pageO.render({ canvasContext: ctx, viewport }).promise;

                                    // Ejecutar OCR sobre el canvas
                                    const { data: { text } } = await Tesseract.recognize(canvas, 'spa', {
                                        logger: m => {
                                            try {
                                                // Mostrar progreso leve en el log
                                                const prog = Math.round((m.progress || 0) * 100);
                                                logDiv.innerHTML += `<div style="font-size:12px;color:#666">OCR p√°gina ${pageNumOcr}/${pdf2.numPages}: ${prog}% ‚Äî ${escapeHtml(m.status || '')}</div>`;
                                            } catch (e) {}
                                        }
                                    });
                                    ocrText += `\n--- P√°gina ${pageNumOcr} ---\n` + (text || '');
                                }

                                // Parsear l√≠neas del OCR buscando las 3 columnas
                                const ocrLines = ocrText.split(/\n+/).map(l => l.trim()).filter(Boolean);
                                const ocrRegex = /^(\d+[\d\.,]*)\s+(\S{2,})\s+(.+)$/;
                                const ocrProducts = ocrLines.map(line => {
                                    const m = line.match(ocrRegex);
                                    if (m) {
                                        return { cantidad: m[1], codigo: m[2], descripcion: m[3] };
                                    }
                                    return null;
                                }).filter(Boolean);

                                if (ocrProducts.length > 0) {
                                    productosParsed = ocrProducts;
                                    // Mostrar texto OCR para depuraci√≥n
                                    try {
                                        const dbgIdO = 'dbg_ocr_' + Math.random().toString(36).slice(2,9);
                                        logDiv.innerHTML += `\n<details id="${dbgIdO}" style="margin:6px 0;"><summary>Ver texto OCR completo</summary><pre style="max-height:240px;overflow:auto;background:#fff;padding:8px;border:1px solid #eee">${escapeHtml(ocrText)}</pre></details>`;
                                    } catch(e) { console.warn('No se pudo insertar texto OCR en log', e); }
                                }
                            } catch (ocrErr) {
                                console.warn('OCR fallback fall√≥:', ocrErr);
                            }
                        }
                    }
                }

                const fileRows = productosParsed
                    .map(producto => {
                        try {
                            // Asegurarse que los valores sean strings antes de usar replace
                            const cantidadStr = String(producto.cantidad || '0');
                            const cantidadClean = cantidadStr.replace(/,/g, '.').replace(/[^\d.]/g, '');
                            const cantidad = parseFloat(cantidadClean) || 0;
                            const codigo = String(producto.codigo || '')
                                .toUpperCase()
                                .replace(/[^A-Z0-9\-\.\/()]/g, '')
                                .trim();
                            let descripcion = String(producto.descripcion || '')
                                .replace(/\s+/g, ' ')
                                .replace(/[^\w\s\-\/().\"\u00C0-\u017F]/g, '')
                                .trim()
                                .toUpperCase();

                            if (!codigo || !descripcion) return null;

                            const validaciones = {
                                codigo: /^[A-Z0-9\-\.\/()]{2,}$/i.test(codigo),
                                cantidad: !isNaN(cantidad) && cantidad > 0,
                                descripcion: descripcion.length >= 5
                            };

                            if (Object.values(validaciones).every(v => v)) {
                                return {
                                    Archivo: file.name,
                                    Fecha: fecha,
                                    Cantidad: cantidad,
                                    Codigo: codigo,
                                    Descripcion: descripcion,
                                    TipoLlanta: determinarTipoLlanta(descripcion)
                                };
                            }
                            return null;
                        } catch (err) {
                            console.warn('Error procesando producto:', err);
                            return null;
                        }
                    })
                    .filter(Boolean); // Elimina los valores null

                if (fileRows.length > 0) {
                    setCache(cacheKey, fileRows);
                    escaneosActuales.push(...fileRows);
                    
                    const stats = {
                        total: fileRows.length,
                        cantidadValida: fileRows.filter(r => !isNaN(r.Cantidad)).length,
                        codigoValido: fileRows.filter(r => r.Codigo).length,
                        descripcionCompleta: fileRows.filter(r => r.Descripcion.length > 5).length
                    };

                    const alertDiv = document.createElement('div');
                    alertDiv.className = 'alert alert-success';
                    alertDiv.innerHTML = `
                        <h6>Archivo: ${file.name}</h6>
                        <p>‚úì ${stats.total} productos extra√≠dos correctamente</p>
                        <div class="stats-detail">
                            <small>
                                ‚Ä¢ Productos con cantidad v√°lida: ${stats.cantidadValida}<br>
                                ‚Ä¢ Productos con c√≥digo v√°lido: ${stats.codigoValido}<br>
                                ‚Ä¢ Productos con descripci√≥n completa: ${stats.descripcionCompleta}
                            </small>
                        </div>`;
                    logDiv.appendChild(alertDiv);
                    
                    setTimeout(() => { alertDiv.remove(); }, 5000);
                } else {
                    const alertDiv = document.createElement('div');
                    alertDiv.className = 'alert alert-warning';
                    alertDiv.innerHTML = `
                        <h6>Archivo: ${file.name}</h6>
                        <p>‚ö†Ô∏è No se pudieron extraer productos v√°lidos</p>`;
                    logDiv.appendChild(alertDiv);
                    
                    setTimeout(() => { alertDiv.remove(); }, 5000);
                }

            } catch (fileError) {
                console.error(`Error procesando archivo ${file.name}:`, fileError);
                const alertDiv = document.createElement('div');
                alertDiv.className = 'alert alert-danger';
                alertDiv.innerHTML = `
                    <h6>Error en archivo: ${file.name}</h6>
                    <p>${fileError.message}</p>`;
                logDiv.appendChild(alertDiv);
                
                setTimeout(() => { alertDiv.remove(); }, 5000);
            }
        }

        if (escaneosActuales.length > 0) {
            mostrarEscaneosPendientes();
        }
        
    } catch (error) {
        console.error('Error general:', error);
        logDiv.innerHTML += `
            <div class="alert alert-danger">
                <h6>Error en el procesamiento</h6>
                <p>${error.message}</p>z
                <small>Revisa la consola para m√°s detalles</small>
            </div>`;
    }
}
// Funci√≥n auxiliar para generar resumen final
function generarResumenFinal(escaneos) {
    const stats = escaneos.reduce((acc, item) => {
        acc.totalProductos++;
        acc.totalCantidad += item.Cantidad;
        acc.tiposLlanta[item.TipoLlanta] = (acc.tiposLlanta[item.TipoLlanta] || 0) + 1;
        return acc;
    }, { totalProductos: 0, totalCantidad: 0, tiposLlanta: {} });

    return `
        <div class="alert alert-info mt-3">
            <h5>Resumen Final</h5>
            <p>Total de productos procesados: ${stats.totalProductos}</p>
            <p>Cantidad total de llantas: ${stats.totalCantidad}</p>
            <h6>Distribuci√≥n por tipo:</h6>
            <ul>
                ${Object.entries(stats.tiposLlanta)
                    .map(([tipo, cant]) => `<li>${tipo}: ${cant} productos</li>`)
                    .join('')}
            </ul>
        </div>`;
}

// Funci√≥n auxiliar para preprocesar im√°genes
async function preprocessImage(imageData) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    
    // Aplicar filtros para mejorar la legibilidad (b√°sico)
    ctx.filter = 'contrast(1.15) brightness(1.05) grayscale(1)';
    ctx.drawImage(imageData, 0, 0);
    
    return canvas;
}

// Cargador de im√°genes desde Blob/URL
function loadImageFromBlob(blob) {
    return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = (e) => { URL.revokeObjectURL(url); reject(e); };
        img.src = url;
    });
}

// Evaluar calidad simple de un canvas: nitidez (high-frequency energy) y contraste
function assessCanvasQuality(canvas) {
    const ctx = canvas.getContext('2d');
    // Muestrear una versi√≥n reducida para ser r√°pido
    const w = Math.max(100, Math.min(800, canvas.width));
    const h = Math.max(100, Math.min(800, canvas.height));
    const tmp = document.createElement('canvas');
    tmp.width = w; tmp.height = h;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(canvas, 0, 0, w, h);
    const imgd = tctx.getImageData(0, 0, w, h);
    const data = imgd.data;

    let sum = 0, sumSq = 0, count = 0;
    let min = 255, max = 0;

    // Variaci√≥n (contraste) y energ√≠a de alta frecuencia simple
    for (let y = 1; y < h-1; y += 4) {
        for (let x = 1; x < w-1; x += 4) {
            const i = (y * w + x) * 4;
            const r = data[i], g = data[i+1], b = data[i+2];
            const lum = 0.2126*r + 0.7152*g + 0.0722*b;
            min = Math.min(min, lum);
            max = Math.max(max, lum);
            sum += lum;
            sumSq += lum*lum;
            // High frequency approximation: diff with right+down pixels
            const iR = (y * w + (x+1)) * 4;
            const iD = ((y+1) * w + x) * 4;
            const lumR = 0.2126*data[iR] + 0.7152*data[iR+1] + 0.0722*data[iR+2];
            const lumD = 0.2126*data[iD] + 0.7152*data[iD+1] + 0.0722*data[iD+2];
            const hf = Math.abs(lum - lumR) + Math.abs(lum - lumD);
            count++;
        }
    }

    const mean = sum / Math.max(1, ( (Math.floor((h-2)/4)) * (Math.floor((w-2)/4)) ));
    const variance = (sumSq / Math.max(1, count)) - (mean*mean);
    const contrast = (max - min) / 255; // 0..1
    return { sharpness: Math.max(0, Math.sqrt(variance)), contrast, width: canvas.width, height: canvas.height };
}

// Aplicar realce simple: contraste lineal y kernel sharpen 3x3
function enhanceCanvas(srcCanvas, opts = { contrast: 0.15, brightness: 0, sharpen: true }) {
    const w = srcCanvas.width, h = srcCanvas.height;
    const dst = document.createElement('canvas');
    dst.width = w; dst.height = h;
    const sctx = srcCanvas.getContext('2d');
    const dctx = dst.getContext('2d');
    const imgd = sctx.getImageData(0, 0, w, h);
    const data = imgd.data;

    // Ajuste de contraste/brightness (simple)
    const contrast = opts.contrast || 0;
    const brightness = opts.brightness || 0;
    const factor = (259 * (contrast * 255 + 255)) / (255 * (259 - contrast * 255));

    for (let i = 0; i < data.length; i += 4) {
        for (let c = 0; c < 3; c++) {
            let v = data[i + c];
            // contraste
            v = factor * (v - 128) + 128;
            // brightness
            v = v + brightness * 255;
            data[i + c] = Math.max(0, Math.min(255, Math.round(v)));
        }
    }

    // Pegar ajustes intermedios
    sctx.putImageData(imgd, 0, 0);

    if (opts.sharpen) {
        // Kernel 3x3 sharpen
        const kernel = [0,-1,0, -1,5,-1, 0,-1,0];
        const k = 3;
        const half = Math.floor(k/2);
        const src = sctx.getImageData(0, 0, w, h);
        const out = dctx.createImageData(w, h);
        const s = src.data;
        const o = out.data;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                for (let c = 0; c < 3; c++) {
                    let acc = 0;
                    for (let ky = -half; ky <= half; ky++) {
                        for (let kx = -half; kx <= half; kx++) {
                            const ix = Math.min(w-1, Math.max(0, x + kx));
                            const iy = Math.min(h-1, Math.max(0, y + ky));
                            const idx = (iy * w + ix) * 4 + c;
                            const kval = kernel[(ky+half)*k + (kx+half)];
                            acc += s[idx] * kval;
                        }
                    }
                    const outIdx = (y * w + x) * 4 + c;
                    o[outIdx] = Math.max(0, Math.min(255, acc));
                }
                const alphaIdx = (y * w + x) * 4 + 3;
                o[alphaIdx] = s[alphaIdx];
            }
        }
        dctx.putImageData(out, 0, 0);
        return dst;
    } else {
        // Si no se aplica sharpen, devolver el canvas con ajustes
        return srcCanvas;
    }
}

// Ejecutar Tesseract sobre un canvas, reusando el logger al div de log
async function performTesseractOCR(canvas, logDiv, label = '') {
    if (!window.Tesseract) throw new Error('Tesseract no est√° cargado');
    let ocrText = '';
    try {
        const { data: { text } } = await Tesseract.recognize(canvas, 'spa', {
            logger: m => {
                try {
                    const prog = Math.round((m.progress || 0) * 100);
                    if (logDiv) logDiv.innerHTML += `<div style="font-size:12px;color:#666">OCR ${label}: ${prog}% ‚Äî ${escapeHtml(m.status || '')}</div>`;
                } catch (e) {}
            }
        });
        ocrText = text || '';
    } catch (e) {
        console.warn('performTesseractOCR failed', e);
        throw e;
    }
    return ocrText;
}

// Extraer datos de una imagen (m√∫ltiples pases, mejora si hace falta, parseo)
async function extractDataFromImage(file, logDiv) {
    // Cargar imagen
    const blob = new Blob([await file.arrayBuffer()], { type: file.type || 'image/png' });
    const img = await loadImageFromBlob(blob);

    // Crear canvas escalado si la resoluci√≥n es baja
    const maxDim = 2000; // objetivo para OCR
    let scale = Math.max(1, Math.min(3, maxDim / Math.max(img.width, img.height)));
    const canvas = document.createElement('canvas');
    canvas.width = Math.floor(img.width * scale);
    canvas.height = Math.floor(img.height * scale);
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    // Evaluar calidad
    const quality = assessCanvasQuality(canvas);
    if (logDiv) logDiv.innerHTML += `<div style="font-size:12px;color:#666">Evaluaci√≥n imagen: sharp=${quality.sharpness.toFixed(2)}, contrast=${quality.contrast.toFixed(2)}, res=${quality.width}x${quality.height}</div>`;

    // Intento 1: OCR directo
    let ocrText = '';
    try {
        ocrText = await performTesseractOCR(canvas, logDiv, 'imagen (directa)');
    } catch (e) {
        console.warn('OCR directa fall√≥:', e);
    }

    // Parseo b√°sico de OCR
    let parsed = [];
    if (ocrText) {
        const ocrLines = ocrText.split(/\n+/).map(l => l.trim()).filter(Boolean);
        const ocrRegex = /^(\d+[\d\.,]*)\s+(\S{2,})\s+(.+)$/;
        const ocrProducts = ocrLines.map(line => {
            const m = line.match(ocrRegex);
            if (m) return { cantidad: m[1], codigo: m[2], descripcion: m[3] };
            return null;
        }).filter(Boolean);
        if (ocrProducts.length > 0) parsed = ocrProducts;
    }

    // Si no hubo resultados, intentar realce y segundo pase OCR
    if ((!parsed || parsed.length === 0) && (quality.sharpness < 15 || quality.contrast < 0.18)) {
        if (logDiv) logDiv.innerHTML += `<div style="font-size:12px;color:#b35">Baja calidad detectada ‚Äî aplicando realce y re-OCR</div>`;
        const enhanced = enhanceCanvas(canvas, { contrast: 0.18, brightness: 0, sharpen: true });
        try {
            const ocrText2 = await performTesseractOCR(enhanced, logDiv, 'imagen (enhanced)');
            const ocrLines2 = ocrText2.split(/\n+/).map(l => l.trim()).filter(Boolean);
            const ocrRegex = /^(\d+[\d\.,]*)\s+(\S{2,})\s+(.+)$/;
            const ocrProducts2 = ocrLines2.map(line => {
                const m = line.match(ocrRegex);
                if (m) return { cantidad: m[1], codigo: m[2], descripcion: m[3] };
                return null;
            }).filter(Boolean);
            if (ocrProducts2.length > 0) parsed = ocrProducts2;
            // mostrar texto OCR mejorado
            try {
                const dbgIdO = 'dbg_ocr_img_' + Math.random().toString(36).slice(2,9);
                logDiv.innerHTML += `\n<details id="${dbgIdO}" style="margin:6px 0;"><summary>Ver texto OCR imagen</summary><pre style="max-height:240px;overflow:auto;background:#fff;padding:8px;border:1px solid #eee">${escapeHtml(ocrText + '\n---\n' + (ocrText2 || ''))}</pre></details>`;
            } catch(e) { console.warn('No se pudo insertar texto OCR imagen en log', e); }
        } catch (e) {
            console.warn('OCR en imagen mejorada fall√≥:', e);
        }
    }

    // Como √∫ltimo recurso, intentar parse simple de todo el texto con parseProductsFromPlainText
    if ((!parsed || parsed.length === 0) && ocrText) {
        const fallback = parseProductsFromPlainText(ocrText);
        if (fallback && fallback.length > 0) parsed = fallback;
    }

    return { fecha: null, productos: parsed };
}

// Funci√≥n para mostrar los escaneos pendientes
function mostrarEscaneosPendientes() {
    const div = document.getElementById('extractedData');
    if (escaneosActuales.length === 0) {
        div.innerHTML = '<p class="alert alert-warning">No hay datos para mostrar.</p>';
        return;
    }

    let html = `
        <div class="card mb-4">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Escaneos Pendientes (${escaneosActuales.length} productos)</h5>
                <div>
                    <input type="text" class="form-control" id="nombreBloqueEspecial" 
                           placeholder="Nombre del bloque">
                    <button class="btn btn-success mt-2" onclick="guardarBloqueEspecial()">
                        Guardar como Bloque
                    </button>
                </div>
            </div>
            <div class="card-body">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Archivo</th>
                            <th>Fecha</th>
                            <th>Cantidad</th>
                            <th>C√≥digo</th>
                            <th>Descripci√≥n</th>
                            <th>Acciones</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${escaneosActuales.map((row, idx) => `
                            <tr>
                                <td>${row.Archivo}</td>
                                <td>${row.Fecha}</td>
                                <td>${row.Cantidad}</td>
                                <td>${row.Codigo}</td>
                                <td>${row.Descripcion}</td>
                                <td>
                                    <button class="btn btn-danger btn-sm" 
                                            onclick="eliminarEscaneoPendiente(${idx})">
                                        Eliminar
                                    </button>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        </div>
    `;

    div.innerHTML = html;
}

// Funci√≥n para guardar el bloque
async function guardarBloqueEspecial() {
    const nombreBloque = document.getElementById('nombreBloqueEspecial').value.trim();
    if (!nombreBloque) {
        alert('Por favor, ingrese un nombre para el bloque');
        return;
    }

    // Cambiar esta validaci√≥n para usar escaneosActuales
    if (escaneosActuales.length === 0) {
        alert('No hay datos para guardar en el bloque');
        return;
    }

    try {
        // Preparar datos para guardar usando escaneosActuales
        const datosBloque = escaneosActuales.map(item => ({
            Nombre: nombreBloque,
            Archivo: item.Archivo,
            Fecha: item.Fecha,
            Cantidad: item.Cantidad,
            C√≥digo: item.Codigo,
            Descripci√≥n: sanitizeFacturaDesc(item.Descripcion)
        }));

        // Guardar en SheetDB
        const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=FACTURAS', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ data: datosBloque })
        });

        if (!response.ok) throw new Error('Error al guardar en SheetDB');

        alert('Bloque guardado exitosamente');
        escaneosActuales = []; // Limpiar escaneos actuales
        document.getElementById('fileInput').value = ''; // Limpiar input file
        document.getElementById('nombreBloqueEspecial').value = ''; // Limpiar nombre
        mostrarEscaneosPendientes();
        cargarEscaneosGuardados(); // Actualizar lista de bloques guardados

    } catch (error) {
        console.error('Error:', error);
        alert('Error al guardar el bloque: ' + error.message);
    }
}

// Funci√≥n para eliminar un escaneo pendiente
function eliminarEscaneoPendiente(idx) {
    escaneosActuales.splice(idx, 1);
    mostrarEscaneosPendientes();
}

// Funci√≥n de extracci√≥n mejorada
async function extractDataFromPDF(file) {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

    let fullText = "";
    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const textContent = await page.getTextContent();
        fullText += textContent.items.map(item => item.str).join(" ") + "\n";
    }

    // Extraer fecha
    const fechaRegex = /FECHA DE EXPEDICI√ìN\s*([\d]{4}-[\d]{2}-[\d]{2})/i;
    let fechaMatch = fullText.match(fechaRegex);
    let fecha = fechaMatch ? fechaMatch[1] : new Date().toISOString().split('T')[0];

    // Extraer productos
    const productoRegex = /(\d+)\s*(pz|PZ|un|UN|UN\.|u[nN]\.?)\s+([A-Z0-9\-]+)\s+([A-Z0-9\s.\-\/]+)/g;
    const productos = [];
    let match;
    while ((match = productoRegex.exec(fullText)) !== null) {
        const cantidad = parseInt(match[1]);
        const codigo = match[3].trim();
        const descripcion = sanitizeFacturaDesc(match[4].trim().replace(/\s+/g, " "));
        productos.push({ cantidad, codigo, descripcion });
    }

    return { fecha, productos };
}

// Funci√≥n para calcular el volumen de una llanta basado en su descripci√≥n
async function calcularVolumenLlanta(descripcion) {
    const desc = descripcion.toUpperCase();
    let volumen = 0;

    // Patrones para diferentes tipos de llantas
    const patrones = [
        // 1. Llantas de auto/camioneta (ej: 195/65 R15, 205/55 R16)
        {
            regex: /^(\d{3})[\s\/](\d{2})[\s\/]?R(\d{2})/i,
            calc: (m, desc = '') => {
                // Nuevo m√©todo: usar f√≥rmula de anillo (√°rea anular √ó ancho)
                // Ancho en mm, perfil en %, rin en pulgadas
                const ancho_mm = Number(m[1]);
                const perfil_ratio = Number(m[2]) / 100;
                const rin_in = Number(m[3]);

                const ancho_m = ancho_mm / 1000; // metros
                const altura_perfil_m = ancho_mm * perfil_ratio / 1000; // metros (por lado)
                const D_rin_m = rin_in * 0.0254; // di√°metro del rin en metros
                const D_ext_m = D_rin_m + 2 * altura_perfil_m; // di√°metro exterior aproximado

                // √Årea del anillo (m¬≤): œÄ*(D_ext^2 - D_rin^2)/4
                const area_anillo = Math.PI * (Math.pow(D_ext_m, 2) - Math.pow(D_rin_m, 2)) / 4;

                let factor = 1.0;
                // Ajustes por tipo (mantener compatibilidad con heur√≠sticas previas)
                const d = desc.toUpperCase();
                if (d.includes('SUV') || d.includes('CAMIONETA')) factor *= 1.2;
                if (d.includes('AT') || d.includes('ALL TERRAIN')) factor *= 1.15;
                if (d.includes('MT') || d.includes('MUD TERRAIN')) factor *= 1.25;
                if (d.includes('SPORT') || d.includes('RACING')) factor *= 1.1;

                // Volumen (m¬≥) = √°rea_anillo * ancho (m) * factor
                return area_anillo * ancho_m * factor;
            }
        },
        
        // 2. Llantas de cami√≥n (ej: 11R22.5, 295/80 R22.5)
        {
            regex: /^(?:(\d{2,3})R|(\d{3})\/(\d{2})R)(\d{2}\.?\d*)/i,
            calc: (m, desc = '') => {
                let ancho, perfil;
                if (m[1]) { // formato XXR
                    ancho = Number(m[1]) * 25.4 / 1000; // pulgadas a metros
                    perfil = ancho * 0.8; // perfil est√°ndar para cami√≥n
                } else { // formato XXX/YY
                    ancho = Number(m[2]) / 1000;
                    perfil = Number(m[3]) / 100 * ancho;
                }
                const rin = Number(m[4]) * 0.0254;
                let factor = 1.3; // factor base para cami√≥n
                
                // Ajustes por uso
                if (desc.includes('TRACCION')) factor *= 1.2;
                if (desc.includes('DIRECCION')) factor *= 1.1;
                if (desc.includes('MIXTA')) factor *= 1.15;
                
                return Math.PI * Math.pow((rin + perfil)/2, 2) * ancho * factor;
            }
        },
        
        // 3. Llantas convencionales (ej: 10.00-20, 11.00-22)
        {
            regex: /^(\d+\.\d+)-(\d{2})/i,
            calc: (m, desc = '') => {
                const ancho = Number(m[1]) * 25.4 / 1000; // pulgadas a metros
                const rin = Number(m[2]) * 0.0254;
                let factor = desc.includes('CONVENCIONAL') ? 1.2 : 1.0;
                return Math.PI * Math.pow((rin + ancho)/2, 2) * ancho * factor;
            }
        },
        
        // 4. Llantas agr√≠colas/industriales (ej: 12.5/80-18, 10-16.5)
        {
            regex: /^(\d+(?:\.\d+)?)-(\d+\.?\d*)\s*(IND|AG)?/i,
            calc: (m, desc = '') => {
                const ancho = Number(m[1]) * 25.4 / 1000;
                const rin = Number(m[2]) * 0.0254;
                let factor = 1.0;
                
                if (desc.includes('MINERIA') || desc.includes('MINING')) factor = 1.6;
                else if (desc.includes('AG') || desc.includes('AGRICOLA')) factor = 1.4;
                else if (desc.includes('IND') || desc.includes('INDUSTRIAL')) factor = 1.2;
                
                if (desc.includes('L5') || desc.includes('ROCK')) factor *= 1.3;
                if (desc.includes('REFORZADA') || desc.includes('REINFORCED')) factor *= 1.1;
                
                return Math.PI * Math.pow((rin + ancho)/2, 2) * ancho * factor;
            }
        },
        
        // 5. Llantas todo terreno (ej: 33X12.50 R20, 35X12.50 R17)
        {
            regex: /^(\d{2,3})[Xx](\d{2}\.?\d*)[\s-]?R(\d{2})/i,
            calc: (m, desc = '') => {
                const altura = Number(m[1]) * 25.4 / 1000;
                const ancho = Number(m[2]) * 25.4 / 1000;
                const rin = Number(m[3]) * 0.0254;
                let factor = 1.3; // base para todo terreno
                
                if (desc.includes('MT') || desc.includes('MUD TERRAIN')) factor *= 1.25;
                if (desc.includes('AT') || desc.includes('ALL TERRAIN')) factor *= 1.15;
                if (desc.includes('HEAVY DUTY') || desc.includes('HD')) factor *= 1.2;
                
                return Math.PI * Math.pow((rin + (altura - rin)/2)/2, 2) * ancho * factor;
            }
        }
    ];

    // Buscar patr√≥n coincidente y calcular volumen
    for (const patron of patrones) {
        const match = desc.match(patron.regex);
        if (match) {
            volumen = patron.calc(match);
            break;
        }
    }

    // Devolver valor num√©rico con 4 decimales
    return Number((volumen || 0).toFixed(4));
}

// Funci√≥n para calcular el peso estimado de una llanta a partir de la descripci√≥n
async function calcularPesoLlanta(descripcion) {
    const desc = (descripcion || '').toUpperCase();
    // Reutilizar la l√≥gica y patrones de calcularPesosINVENTARIO pero devolviendo el peso para un solo producto
    let peso = 0;

    const patrones = [
        {
            regex: /^(\d{3})[\s\/]?(\d{2})[\s\/]?R(\d{2})/i,
            calc: (m, d = '') => {
                const ancho = Number(m[1]);
                const perfil = Number(m[2]);
                const rin = Number(m[3]);
                const base = (ancho * perfil/100 * rin/25.4) * 0.2;
                let factor = 1.0;
                if (d.includes('SUV') || d.includes('CAMIONETA')) factor *= 1.2;
                if (d.includes('PERFOR')) factor *= 1.1;
                if (d.includes('EFFICIENT')) factor *= 0.95;
                if (d.includes('AT') || d.includes('ALL TERRAIN')) factor *= 1.15;
                if (d.includes('MT') || d.includes('MUD TERRAIN')) factor *= 1.25;
                if (d.includes('SPORT') || d.includes('RACING')) factor *= 1.1;
                return base * factor;
            }
        },
        {
            regex: /^(\d{2})R(\d{2}\.\d*)/i,
            calc: (m) => {
                const ancho = Number(m[1]) * 25.4;
                const rin = Number(m[2]);
                const base = (ancho * 0.8 * rin/25.4) * 0.45;
                return base;
            }
        },
        {
            regex: /^(\d+\.\d+)-(\d{2})/i,
            calc: (m, d = '') => {
                const ancho = Number(m[1]) * 25.4;
                const rin = Number(m[2]);
                const base = (ancho * rin/25.4) * 0.4;
                return base * (d.includes('CONVENCIONAL') ? 1.2 : 1);
            }
        },
        {
            regex: /^(\d{2,3})[Xx](\d{2}\.\d*)[\s-]?R(\d{2})/i,
            calc: (m, d = '') => {
                const ancho = Number(m[1]);
                const perfil = Number(m[2]);
                const rin = Number(m[3]);
                const base = (ancho * perfil/100 * rin/25.4) * 0.3;
                let factor = 1.3;
                if (d.includes('MT') || d.includes('MUD TERRAIN')) factor *= 1.25;
                if (d.includes('AT') || d.includes('ALL TERRAIN')) factor *= 1.15;
                if (d.includes('HEAVY DUTY') || d.includes('HD')) factor *= 1.2;
                if (d.includes('REFORZADA') || d.includes('REINFORCED')) factor *= 1.1;
                return base * factor;
            }
        },
        {
            regex: /^(\d+(?:\.\d+)?)-(\d+\.?\d*)\s*(IND|AG)?/i,
            calc: (m, d = '') => {
                const ancho = Number(m[1]) * 25.4;
                const rin = Number(m[2]);
                const base = ancho * rin/25.4 * 0.6;
                let factorBase = 1.2;
                if (d.includes('MINERIA') || d.includes('MINING')) factorBase = 1.6;
                else if (d.includes('AG') || d.includes('AGRICOLA') || d.includes('FARM')) factorBase = 1.4;
                return base * factorBase;
            }
        }
    ];

    // Aplicar patrones
    for (const patron of patrones) {
        const m = desc.match(patron.regex);
        if (m) {
            peso = patron.calc(m, desc);
            break;
        }
    }

    // Aplicar factores adicionales simples (coincidentes con calcularPesosINVENTARIO)
    const factoresAjuste = {
        'XL': 1.15, 'RF': 1.20, 'PR': 1.10, 'SKS': 1.30, 'L5': 1.40,
        'SOLID': 2.0, 'HT': 1.05, 'AT': 1.15, 'MT': 1.25, 'TRACCION': 1.2,
        'DIRECCION': 1.1, 'COMERCIAL': 1.3
    };

    for (const clave of Object.keys(factoresAjuste)) {
        if (desc.includes(clave)) peso *= factoresAjuste[clave];
    }

    // Redondear a 2 decimales
    peso = Math.round((peso || 0) * 100) / 100;
    return peso;
}

// Funci√≥n para agregar productos nuevos al INVENTARIO
async function agregarProductosNuevosAlINVENTARIO(productos) {
    try {
        const datosParaGuardar = [];
        for (const p of productos) {
            const desc = (p.Descripcion || p.Descripcion || '').toString().trim();
            // Calcular volumen y peso autom√°ticamente
            let volumenCalc = 0;
            let pesoCalc = '';
            try {
                volumenCalc = await calcularVolumenLlanta(desc);
            } catch (e) {
                console.warn('No se pudo calcular volumen para:', desc, e);
                volumenCalc = 0;
            }
            try {
                pesoCalc = await calcularPesoLlanta(desc);
            } catch (e) {
                console.warn('No se pudo calcular peso para:', desc, e);
                pesoCalc = '';
            }

            datosParaGuardar.push({
                clave: p.Codigo,
                descripcion: p.Descripcion,
                linea: determinarTipoLlanta(p.Descripcion),
                peso: pesoCalc,
                volumen: volumenCalc,
                valor: ''
            });
        }

        const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ data: datosParaGuardar })
        });

        if (!response.ok) throw new Error('Error al agregar productos al INVENTARIO');

        alert(`Se agregaron ${productos.length} productos nuevos al INVENTARIO`);
        await fetchINVENTARIO(); // Actualizar el INVENTARIO local

    } catch (error) {
        console.error('Error:', error);
        alert('Error al agregar productos al INVENTARIO: ' + error.message);
    }
}

// Funci√≥n para cargar autom√°ticamente los escaneos cuando se activa la pesta√±a
function inicializarPestanaEscaneos() {
    // Buscar todos los elementos que cambian a la pesta√±a de escaneos
    document.querySelectorAll('[data-tab="escaneos-traspasos"]').forEach(tab => {
        tab.addEventListener('click', () => {
            console.log('Pesta√±a de escaneos activada - cargando datos...');
            cargarEscaneosGuardados();
        });
    });
}

// Setup autom√°tico de c√°lculo de peso/volumen en modal INVENTARIO
function setupInventoryAutoCalc() {
    const descInput = document.getElementById('agregarDescripcion');
    const volInput = document.getElementById('agregarVolumen');
    const pesoInput = document.getElementById('agregarPeso');
    if (!descInput) return;
    let timer = null;
    const infoDiv = document.getElementById('agregarCalcInfo');
    const defaultInfoText = infoDiv ? infoDiv.textContent : '';
    const compute = async () => {
        const desc = descInput.value.trim();
        if (!desc) return;
        if (infoDiv) infoDiv.textContent = 'Calculando...';
        // Volumen
        if (volInput && (!volInput.value || volInput.dataset.auto === 'true')) {
            try {
                const v = Number(await calcularVolumenLlanta(desc)) || 0;
                volInput.value = Number(v).toFixed(4);
                volInput.dataset.auto = 'true';
            } catch (e) { console.warn('calcularVolumenLlanta error', e); }
        }
        // Peso
        if (pesoInput && (!pesoInput.value || pesoInput.dataset.auto === 'true')) {
            try {
                const p = Number(await calcularPesoLlanta(desc)) || 0;
                pesoInput.value = Number(p).toFixed(2);
                pesoInput.dataset.auto = 'true';
            } catch (e) { console.warn('calcularPesoLlanta error', e); }
        }
        if (infoDiv) infoDiv.textContent = defaultInfoText || 'Valores calculados autom√°ticamente (aprox.) al escribir la descripci√≥n. Puedes editar manualmente.';
    };

    descInput.addEventListener('input', () => { clearTimeout(timer); timer = setTimeout(compute, 350); });
    descInput.addEventListener('focus', () => { clearTimeout(timer); timer = setTimeout(compute, 250); });
    if (volInput) volInput.addEventListener('input', () => volInput.dataset.auto = 'false');
    if (pesoInput) pesoInput.addEventListener('input', () => pesoInput.dataset.auto = 'false');

    // Si la descripci√≥n ya viene prellenada (editar o abrir modal con valor), calcular una vez
    if (descInput.value && descInput.value.trim()) {
        setTimeout(compute, 200);
    }
}

// Llamar a la funci√≥n de inicializaci√≥n cuando el documento est√© listo
document.addEventListener('DOMContentLoaded', () => {
    inicializarPestanaEscaneos();
    setupInventoryAutoCalc();
    // Cargar los datos inicialmente si estamos en la pesta√±a de escaneos
    if (document.querySelector('[data-tab="escaneos-traspasos"].active')) {
        cargarEscaneosGuardados();
    }
});

// Variable para controlar el intervalo de actualizaci√≥n
let intervaloActualizacionEscaneos = null;

// Funci√≥n para iniciar la actualizaci√≥n autom√°tica
function iniciarActualizacionAutomatica() {
    // Detener cualquier intervalo existente
    if (intervaloActualizacionEscaneos) {
        clearInterval(intervaloActualizacionEscaneos);
    }

    // Crear nuevo intervalo que actualiza cada 30 segundos
    intervaloActualizacionEscaneos = setInterval(() => {
        if (document.querySelector('[data-tab="escaneos-traspasos"].active')) {
            console.log('Actualizando autom√°ticamente los escaneos...');
            cargarEscaneosGuardados(true);
        }
    }, 30000);
}

async function cargarEscaneosGuardados(filtro = '', silencioso = false) {
    try {
        if (!silencioso) {
            console.log('Iniciando carga de escaneos guardados...');
        }
        
        const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=FACTURAS');
        if (!response.ok) throw new Error('Error al cargar escaneos');
        
        const datos = filterMeaningfulRows(await response.json());
        if (!silencioso) {
            console.log('Datos de escaneos cargados:', datos);
        }
        
        // Agrupar por nombre de escaneo
        const escaneosAgrupados = datos.reduce((grupos, item) => {
            if (!grupos[item.Nombre]) {
                grupos[item.Nombre] = [];
            }
            grupos[item.Nombre].push(item);
            return grupos;
        }, {});

        // Filtrar por b√∫squeda si hay filtro
        const nombresEscaneos = Object.keys(escaneosAgrupados)
            .filter(nombre => nombre.toLowerCase().includes(filtro.toLowerCase()));

        // Mostrar resultados
        const contenedorEscaneos = document.getElementById('escaneosGuardados');
        if (!contenedorEscaneos) {
            console.error('No se encontr√≥ el contenedor de escaneos guardados');
            return;
        }

        contenedorEscaneos.innerHTML = nombresEscaneos.length === 0 ? 
            '<div class="alert alert-info">No se encontraron escaneos guardados</div>' :
            nombresEscaneos.map(nombre => `
                <div class="card mb-3">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">${nombre}</h5>
                        <button class="btn btn-danger btn-sm" onclick="eliminarEscaneo('${nombre}')">
                            Eliminar
                        </button>
                    </div>
                    <div class="card-body">
                        <details>
                            <summary>Ver ${escaneosAgrupados[nombre].length} art√≠culo(s)</summary>
                            <ul class="list-group list-group-flush mt-2">
                                ${escaneosAgrupados[nombre].map(item => {
                                    const descRaw = item['Descripci√≥n'] || item.Descripcion || item.Descrip || '';
                                    const descSan = sanitizeFacturaDesc(descRaw);
                                    const codigo = item['C√≥digo'] || item.Codigo || item.CODIGO || '';
                                    const archivo = item.Archivo || '';
                                    const fecha = item.Fecha || '';
                                    return `
                                    <li class="list-group-item">
                                        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
                                            <div><strong>C√≥digo:</strong> ${codigo}</div>
                                            <div><strong>cantidad:</strong> ${item.Cantidad || item.cantidad || ''}</div>
                                        </div>
                                        <div style="margin-top:6px;"><strong>Descripci√≥n:</strong> ${descSan || ''}</div>
                                    </li>
                                `}).join('')}
                            </ul>
                        </details>
                    </div>
                </div>
            `).join('');

    } catch (error) {
        console.error('Error:', error);
        document.getElementById('escaneosGuardados').innerHTML = 
            '<div class="alert alert-danger">Error al cargar escaneos guardados</div>';
    }
}
async function eliminarEscaneo(nombre) {
    if (!confirm(`¬øEst√° seguro de eliminar el escaneo "${nombre}"?`)) return;

    try {
        console.log(`Iniciando eliminaci√≥n de escaneo: ${nombre}`);
        const baseUrl = 'https://sheetdb.io/api/v1/gdn5wqo960cey';
        const response = await fetch(`${baseUrl}/Nombre/${encodeURIComponent(nombre)}?sheet=FACTURAS`, {
            method: 'DELETE'
        });

        if (!response.ok) {
            const errorText = await response.text().catch(() => 'Sin detalles');
            throw new Error(`Error HTTP ${response.status}: ${errorText}`);
        }

        console.log(`‚úÖ Escaneo eliminado exitosamente: ${nombre}`);
        alert('Escaneo eliminado exitosamente');
        cargarEscaneosGuardados();
    } catch (error) {
        console.error('Error al eliminar escaneo:', error.message);
        alert('Error al eliminar el escaneo: ' + error.message);
    }
}
// Funci√≥n para mostrar resultados en tabla
function renderTable() {
    const div = document.getElementById('extractedData');
    if (extractedData.length === 0) {
        div.innerHTML = '<p class="alert alert-warning">No se encontraron datos para mostrar.</p>';
        return;
    }

    div.innerHTML = `
        <table class="table table-striped mt-3">
            <thead>
                <tr>
                    <th>Archivo</th>
                    <th>Fecha</th>
                    <th>Cantidad</th>
                    <th>C√≥digo</th>
                    <th>Descripci√≥n</th>
                </tr>
            </thead>
            <tbody>
                ${extractedData.map(row => `
                    <tr>
                        <td>${row.Archivo}</td>
                        <td>${row.Fecha}</td>
                        <td>${row.Cantidad}</td>
                        <td>${row.Codigo}</td>
                        <td>${row.Descripcion}</td>
                    </tr>
                `).join('')}
            </tbody>
        </table>
    `;
}

function mostrarBloquesGuardadosEspeciales() {
    const container = document.getElementById('bloquesGuardadosEspeciales');
    
    fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=FACTURAS')
        .then(response => response.json())
        .then(datos => {
            datos = filterMeaningfulRows(datos);
            // Agrupar por nombre de bloque
            const bloques = datos.reduce((acc, item) => {
                if (!acc[item.Nombre]) {
                    acc[item.Nombre] = [];
                }
                acc[item.Nombre].push(item);
                return acc;
            }, {});

            let html = Object.entries(bloques).map(([nombre, items]) => `
                <div class="card mb-3">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">${nombre}</h6>
                        <button class="btn btn-danger btn-sm" 
                                onclick="eliminarBloqueEspecial('${nombre}')">
                            Eliminar Bloque
                        </button>
                    </div>
                    <div class="card-body">
                        <table class="table table-sm">
                            <thead>
                                <tr>
                                    <th>Archivo</th>
                                    <th>Fecha</th>
                                    <th>Cantidad</th>
                                    <th>C√≥digo</th>
                                    <th>Descripci√≥n</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${items.map(item => `
                                    <tr>
                                        <td>${item.Archivo}</td>
                                        <td>${item.Fecha}</td>
                                        <td>${item.Cantidad}</td>
                                        <td>${item.C√≥digo}</td>
                                        <td>${item.Descripci√≥n}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `).join('');

            container.innerHTML = html || '<div class="alert alert-info">No hay bloques guardados</div>';
        })
        .catch(error => {
            console.error('Error:', error);
            container.innerHTML = '<div class="alert alert-danger">Error al cargar bloques guardados</div>';
        });
}

async function eliminarBloqueEspecial(nombre) {
    if (!confirm(`¬øEst√° seguro de eliminar el bloque "${nombre}"?`)) return;

    try {
        const response = await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey/Nombre/${encodeURIComponent(nombre)}?sheet=FACTURAS`, {
            method: 'DELETE'
        });

        if (!response.ok) throw new Error('Error al eliminar');

        alert('Bloque eliminado exitosamente');
        mostrarEscaneosPendientes();
    } catch (error) {
        console.error('Error:', error);
        alert('Error al eliminar el bloque: ' + error.message);
    }
}

function eliminarEscaneoPendiente(idx) {
    extractedData.splice(idx, 1);
    mostrarEscaneosPendientes();
}
// Agregar despu√©s de la funci√≥n renderTable()
// Funci√≥n principal para guardar escaneo
function guardarEscaneoEspecial() {
    if (extractedData.length === 0) {
        alert('No hay datos para guardar');
        return;
    }

    // Limpiar cualquier modal existente
    limpiarModales();


    // Primero, limpiar cualquier modal existente
    document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
    document.body.classList.remove('modal-open');
    document.body.style.removeProperty('overflow');
    document.body.style.removeProperty('padding-right');

    const modalHTML = `
        <div class="modal" id="modalNombreEscaneo" tabindex="-1" role="dialog">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Guardar Escaneo</h5>
                        <button type="button" class="btn-close" onclick="cerrarModalEscaneo()" aria-label="Close"></button>
                    </div>   
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="nombreEscaneo">Nombre del escaneo:</label>
                            <input type="text" class="form-control" id="nombreEscaneo" required>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" onclick="cerrarModalEscaneo()">Cancelar</button>
                        <button type="button" class="btn btn-primary" onclick="confirmarGuardadoEscaneo()">Guardar</button>
                    </div>
                </div>
            </div>
        </div>
    `;
     
    // Remover modal anterior si existe
    const modalAnterior = document.getElementById('modalNombreEscaneo');
    if (modalAnterior) {
        modalAnterior.remove();
    }

    // Agregar el nuevo modal
    document.body.insertAdjacentHTML('beforeend', modalHTML);

    // Mostrar el modal de manera manual
    const modalElement = document.getElementById('modalNombreEscaneo');
    modalElement.style.display = 'block';
    modalElement.classList.add('show');
    modalElement.style.backgroundColor = 'rgba(0,0,0,0.5)';

    // Enfocar el input
    document.getElementById('nombreEscaneo').focus();
}

// Funci√≥n para cerrar el modal
function cerrarModalEscaneo() {
    const modalElement = document.getElementById('modalNombreEscaneo');
    if (modalElement) {
        modalElement.style.display = 'none';
        modalElement.classList.remove('show');
        modalElement.remove();
        
        // Limpiar backdrop y clases del body
        document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
        document.body.classList.remove('modal-open');
        document.body.style.removeProperty('overflow');
        document.body.style.removeProperty('padding-right');
    }
}

// Funci√≥n para confirmar el guardado
async function confirmarGuardadoEscaneo() {
    const nombreEscaneo = document.getElementById('nombreEscaneo').value.trim();
    if (!nombreEscaneo) {
        alert('Por favor ingresa un nombre para el escaneo');
        return;
    }

    try {
        // Obtener la fecha actual en formato YYYY-MM-DD
        const fechaActual = new Date().toISOString().split('T')[0]; // Formato YYYY-MM-DD

        // Preparar datos para guardar con los nombres exactos de las columnas
        const datosParaGuardar = extractedData.map(item => ({
            Nombre: nombreEscaneo,
            Archivo: item.Archivo || '',
            Fecha: fechaActual,
            Cantidad: item.Cantidad || '',
            C√≥digo: item.Codigo || '',     // Notar la tilde en 'C√≥digo'
            Descripci√≥n: item.Descripcion || ''  // Notar la tilde en 'Descripci√≥n'
        }));

        const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=FACTURAS', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ data: datosParaGuardar })
        });

        if (!response.ok) throw new Error('Error al guardar en SheetDB');

        // Cerrar el modal
        cerrarModalEscaneo();

        // Limpiar datos y UI
        alert('Escaneo guardado exitosamente');
        extractedData = [];
        document.getElementById('extractedData').innerHTML = '';
        document.getElementById('fileInput').value = '';
        
        // Actualizar lista de escaneos
        await cargarEscaneosGuardados();

    } catch (error) {
        console.error('Error:', error);
        alert('Error al guardar el escaneo: ' + error.message);
    }
}

function cerrarModalEscaneo() {
    const modalElement = document.getElementById('modalNombreEscaneo');
    if (modalElement) {
        const modal = bootstrap.Modal.getInstance(modalElement);
        if (modal) {
            modal.hide();
        }
        setTimeout(() => {
            modalElement.remove();
            limpiarModales();
        }, 300);
    }
}

// Funci√≥n para eliminar escaneo
async function eliminarEscaneo(nombre) {
    if (!confirm(`¬øEst√°s seguro de que deseas eliminar el escaneo "${nombre}"?`)) return;

    try {
        console.log(`Intentando eliminar escaneo: ${nombre}`);
        const baseUrl = 'https://sheetdb.io/api/v1/gdn5wqo960cey';
        const response = await fetch(`${baseUrl}/Nombre/${encodeURIComponent(nombre)}?sheet=FACTURAS`, {
            method: 'DELETE'
        });

        if (!response.ok) {
            const errorText = await response.text().catch(() => 'Sin detalles');
            throw new Error(`Error HTTP ${response.status}: ${errorText}`);
        }

        console.log(`‚úÖ Escaneo eliminado exitosamente: ${nombre}`);
        alert('Escaneo eliminado exitosamente');
        cargarEscaneosGuardados();

    } catch (error) {
        console.error('Error al eliminar escaneo:', error.message);
        alert('Error al eliminar el escaneo: ' + error.message);
    }
}
// Agregar despu√©s de la funci√≥n calcularCombinaciones()
function limpiarCalculadoraRapida() {
    const panelHTML = `
        <div class="card mb-3">
            <div class="card-body" id="combinacionesPanel">
                <div class="row mb-2 combinacion-row">
                    <div class="col-md-3">
                        <label>Cantidad</label>
                        <input type="number" class="form-control cantidad-llanta" value="1" min="1">
                    </div>
                    <div class="col-md-3">
                        <label>Tipo de Llanta</label>
                        <select class="form-control tipo-llanta">
                            <option value="AUTO">Auto particular</option>
                            <option value="SUV_CAMIONETA">SUVs y camionetas</option>
                            <option value="COMERCIAL_LIGERO">Veh√≠culo comercial ligero y camiones peque√±os</option>
                            <option value="PESADO">Camiones pesados y tractocamiones</option>
                            <option value="AGRICOLA_MINERO">Agr√≠cola y minero</option>
                        </select>
                    </div>
                    <div class="col-md-2 d-flex align-items-end">
                        <button class="btn btn-danger btn-sm" onclick="eliminarCombinacion(this)">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div class="card-footer">
                <button class="btn btn-success" onclick="agregarCombinacion()">
                    <i class="bi bi-plus-circle"></i> Agregar combinaci√≥n
                </button>
                <button class="btn btn-primary" onclick="calcularCombinaciones()">
                    <i class="bi bi-calculator"></i> Calcular capacidad
                </button>
                <button class="btn btn-danger" onclick="limpiarCalculadoraRapida()">
                    <i class="bi bi-trash"></i> Limpiar todo
                </button>
            </div>
        </div>
    `;

    // Reemplazar el panel existente
    const panelActual = document.getElementById('verificacionRapidaPanel');
    panelActual.innerHTML = panelHTML;

    // Remover cualquier resultado previo
    const resultadoExistente = panelActual.querySelector('.alert');
    if (resultadoExistente) {
        resultadoExistente.remove();
    }
}
    // ----- Gr√°ficas -----
    const ctxVolumen = document.getElementById('graphVolumen').getContext('2d');
    const ctxCarga = document.getElementById('graphCarga').getContext('2d');
    let chartVolumen = new Chart(ctxVolumen, {
        type: 'doughnut',
        data: { labels: ['Usado', 'Disponible'],
            datasets: [{ data: [0, 100], backgroundColor: ['#75c286', '#f3f3f3'], borderWidth: 1 }]
        },
        options: { plugins: {legend: {display: true}}, cutout: '70%' }
    });
    let chartCarga = new Chart(ctxCarga, {
        type: 'doughnut',
        data: { labels: ['Usado', 'Disponible'],
            datasets: [{ data: [0, 100], backgroundColor: ['#7ad4a2', '#f3f3f3'], borderWidth: 1 }]
        },
        options: { plugins: {legend: {display: true}}, cutout: '70%' }
    });   
 function verificarCapacidad(totalVolumen, totalPeso) {
    if (!pedidoCamion) return;
    
    // Ya no mostramos alertas aqu√≠
    // Solo actualizamos las gr√°ficas a trav√©s de actualizarGraficas()
    // que ya maneja la visualizaci√≥n del excedente con colores rojos
    return;
}

// Reemplazar la funci√≥n actualizarGraficas() existente
function actualizarGraficas() {
    if (!pedidoCamion) {
        chartVolumen.data.datasets[0].data = [0, 100];
        chartCarga.data.datasets[0].data = [0, 100];
        chartVolumen.update();
        chartCarga.update();
        document.querySelector('#graphVolumen + p').innerHTML = 'Espacio usado';
        document.querySelector('#graphCarga + p').innerHTML = 'Carga Usada';
        return;
    }

    // Si estamos viendo un cami√≥n pendiente activo, usar sus items de pendingAsignaciones en lugar de pedidosEnCurso
    let itemsAMostrar = pedidosEnCurso;
    if (activePendingEconomico && pendingAsignaciones && pendingAsignaciones[activePendingEconomico]) {
        itemsAMostrar = pendingAsignaciones[activePendingEconomico];
    }

    // Calcular totales
    let totalVolumen = itemsAMostrar.reduce((acc, cur) => acc + (parseFloat(cur.volumen || cur.Volumen) || 0), 0);
    let totalPeso = itemsAMostrar.reduce((acc, cur) => acc + (parseFloat(cur.peso || cur.Peso) || 0), 0);
    let volTotal = parseFloat(pedidoCamion.volumen || pedidoCamion.capacidadVolumen || pedidoCamion['Cap. Volumen'] || 0);
    let pesoTotal = parseFloat(pedidoCamion["capacidad de carga (kg)"] || pedidoCamion.capacidadPeso || pedidoCamion.carga || 0);

    // Calcular porcentajes
    let porcentajeVolumen = (totalVolumen / volTotal) * 100;
    let porcentajePeso = (totalPeso / pesoTotal) * 100;

    // Mostrar alerta si supera 70%
    if (porcentajeVolumen > 0 || porcentajePeso > 70) {
        mostrarAlertaCapacidad(
            volTotal - totalVolumen,
            pesoTotal - totalPeso,
            porcentajeVolumen,
            porcentajePeso
        );
    }

    // Actualizar gr√°ficas
    chartVolumen.data.datasets[0].data = [
        Math.min(totalVolumen, volTotal),
        Math.max(0, volTotal - totalVolumen)
    ];
    chartCarga.data.datasets[0].data = [
        Math.min(totalPeso, pesoTotal),
        Math.max(0, pesoTotal - totalPeso)
    ];

    // Actualizar colores seg√∫n excedentes
    chartVolumen.data.datasets[0].backgroundColor = porcentajeVolumen > 100 ? 
        ['#ff6b6b', '#f3f3f3'] : ['#75c286', '#f3f3f3'];
    chartCarga.data.datasets[0].backgroundColor = porcentajePeso > 100 ? 
        ['#ff6b6b', '#f3f3f3'] : ['#7ad4a2', '#f3f3f3'];

    chartVolumen.update();
    chartCarga.update();

    // Actualizar textos
    const volumenText = document.querySelector('#graphVolumen + p');
    const cargaText = document.querySelector('#graphCarga + p');

    volumenText.innerHTML = `Espacio usado<br>${totalVolumen.toFixed(2)}/${volTotal.toFixed(2)} m¬≥ (${porcentajeVolumen.toFixed(1)}%)`;
    cargaText.innerHTML = `Carga Usada<br>${totalPeso.toFixed(2)}/${pesoTotal.toFixed(2)} kg (${porcentajePeso.toFixed(1)}%)`;
}
// Agregar despu√©s de la funci√≥n actualizarGraficas()
// Modificar la funci√≥n mostrarAlertaCapacidad() existente
function agregarEstilosAlertas() {
    if (!document.getElementById('estilosAlertas')) {
        const estilos = document.createElement('style');
        estilos.id = 'estilosAlertas';
        estilos.innerHTML = `
            .alerta-flotante {
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: white;
                border: 2px solid #ff4444;
                border-radius: 8px;
                padding: 15px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 1000;
                max-width: 300px;
                animation: slideIn 0.5s ease-out;
            }

            @keyframes slideIn {
                from { transform: translateX(100%); }
                to { transform: translateX(0); }
            }

            .alerta-flotante button {
                position: absolute;
                top: 5px;
                right: 5px;
                border: none;
                background: none;
                cursor: pointer;
                font-size: 18px;
            }
        `;
        document.head.appendChild(estilos);
    }
}

function mostrarAlertaCapacidad(espacioRestante, pesoRestante, pctVolumen, pctPeso) {
    agregarEstilosAlertas();

    // Remover alerta anterior si existe
    const alertaAnterior = document.querySelector('.alerta-flotante');
    if (alertaAnterior) alertaAnterior.remove();

    const alerta = document.createElement('div');
    alerta.className = 'alerta-flotante';
    
    // Determinar nivel y color de alerta seg√∫n los nuevos rangos
    let nivelAlerta, colorAlerta;
    const maxPct = Math.max(pctVolumen, pctPeso);

    if (maxPct > 95) {
        nivelAlerta = '‚ö†Ô∏è ¬°ADVERTENCIA!';
        colorAlerta = '#ff4444'; // Rojo
    } else if (maxPct > 85) {
        nivelAlerta = '‚ö†Ô∏è Precauci√≥n';
        colorAlerta = '#ffa500'; // Amarillo
    } else { 
        nivelAlerta = '‚úÖ √ìptimo';
        colorAlerta = '#4CAF50'; // Verde
    }

    alerta.style.borderColor = colorAlerta;

    // Construir un resumen por categor√≠a m√°s completo (cantidad, volumen y peso)
    const passengerPattern = /\b\d{2,3}\/\d{2}\s*R\d{2}\b|\bR\d{2}\b/;
    const agrPattern = /\b(AGRICOLA|TRACTOR|R-1|R1|AGR[I√ç]COLA?)\b/;
    // Detecta tama√±os espec√≠ficos y tambi√©n formatos generales tipo "11R24.5" (n√∫mero + 'R' + n√∫mero[.decimal])
    const truckPattern = /\b(CAMION|TRAILER|22\.5|24\.5|17\.5|19\.5|11R|\d{1,3}R\d{1,3}(?:\.\d+)?|295\/80|315\/80)\b/;
    const otrPattern = /\b(OTR|INDUSTRIAL|L-[2-5]|E-[2-4]|25"|33"|35"|49"|SKS|CT85)\b/;
    const suvPattern = /\b(4X4|\bAT\b|\bMT\b|\bLT\b|SUV|PICKUP)\b/;
    const autoPattern = /\b(AUTO|COCHE|CAR|PASSENGER)\b/;

    const categoriaOrden = ['AGRICOLA','OTR/INDUSTRIAL','CAMION','CAMIONETA/SUV','AUTO','OTROS'];
    const categoriaLabels = {
        'AGRICOLA': 'Agr√≠cola',
        'OTR/INDUSTRIAL': 'OTR/Industrial',
        'CAMION': 'Cami√≥n',
        'CAMIONETA/SUV': 'Camioneta/SUV',
        'AUTO': 'Auto',
        'OTROS': 'Otros'
    };

    const resumenPedidos = {};
    pedidosEnCurso.forEach(pedido => {
        const desc = (pedido.descripcion || '').toUpperCase();
        const linea = (pedido.linea || '').toUpperCase();
        const cantidad = Number(pedido.cantidad) || 0;
        const pesoLinea = Number(safeNum(pedido.peso)) || 0;
        const volumenLinea = Number(safeNum(pedido.volumen)) || 0;

        // Puntaje por coincidencias en patrones; la prioridad est√° en el orden de categoriaOrden
        const scores = {
            'AGRICOLA': (agrPattern.test(desc) || linea.includes('AGRICOLA')) ? 2 : 0,
            'OTR/INDUSTRIAL': (otrPattern.test(desc) || linea.includes('OTR')) ? 2 : 0,
            'CAMION': (truckPattern.test(desc) || linea.includes('CAMION')) ? 2 : 0,
            'CAMIONETA/SUV': (suvPattern.test(desc) || suvPattern.test(linea)) ? 1 : 0,
            'AUTO': (passengerPattern.test(desc) || autoPattern.test(desc) || linea.includes('AUTO')) ? 1 : 0
        };

        // Seleccionar mejor categor√≠a seg√∫n puntuaci√≥n y prioridad
        let categoria = 'OTROS';
        let maxScore = -1;
        for (const cat of categoriaOrden) {
            const score = scores[cat] || 0;
            if (score > maxScore) { maxScore = score; categoria = cat; }
        }

        if (!resumenPedidos[categoria]) resumenPedidos[categoria] = { cantidad: 0, peso: 0, volumen: 0 };
        resumenPedidos[categoria].cantidad += cantidad;
        resumenPedidos[categoria].peso += pesoLinea;
        resumenPedidos[categoria].volumen += volumenLinea;
    });

    // Construir HTML resumido por categor√≠a (cantidad, volumen, peso)
    const resumenHtml = categoriaOrden.map(cat => {
        const r = resumenPedidos[cat];
        if (!r || r.cantidad === 0) return '';
        return `
            <p style="margin:3px 0;font-size:14px;">
                <b>${categoriaLabels[cat]}:</b> ${r.cantidad} llantas ‚Äî Vol: ${Number(r.volumen).toLocaleString('es-MX', { minimumFractionDigits: 3, maximumFractionDigits: 3 })} m¬≥, Peso: ${Number(r.peso).toLocaleString('es-MX', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} kg
            </p>
        `;
    }).join('');

    alerta.innerHTML = `
        <button onclick="this.parentElement.remove()">√ó</button>
        <h4 style="color:${colorAlerta};margin:0 0 10px 0">
            ${nivelAlerta}
        </h4>
        <div style="background:#f5f5f5;padding:12px;border-radius:4px;margin-bottom:10px">
            ${resumenHtml || '<p style="margin:3px 0;font-size:14px;color:#666;">No hay llantas en el pedido.</p>'}
        </div>
        <div style="margin:5px 0">
            <p style="color:${colorAlerta}">
                <b>Volumen:</b> ${pctVolumen.toFixed(1)}%
                ${espacioRestante < 0 ? ' (¬°Excedido!)' : ''}
            </p>
            <p style="color:${colorAlerta}">
                <b>Peso:</b> ${pctPeso.toFixed(1)}%
                ${pesoRestante < 0 ? ' (¬°Excedido!)' : ''}
            </p>
        </div>
        <div style="margin-top:10px;padding-top:10px;border-top:1px solid #eee">
            <p style="margin:5px 0;color:#666;">
                <b>Espacio disponible:</b> ${espacioRestante.toFixed(2)} m¬≥
            </p>
            <p style="margin:5px 0;color:#666;">
                <b>Peso disponible:</b> ${pesoRestante.toFixed(2)} kg
            </p>
        </div>
    `;

    document.body.appendChild(alerta);

    // Auto-eliminar despu√©s de 10 segundos
    setTimeout(() => {
        if (alerta.parentElement) alerta.remove();
    }, 10000);
}

// Agregar esta funci√≥n auxiliar al inicio del archivo
function agregarEstilosAlertas() {
    if (!document.getElementById('estilosAlertas')) {
        const estilos = document.createElement('style');
        estilos.id = 'estilosAlertas';
        estilos.innerHTML = `
            .alerta-flotante {
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: white;
                border: 2px solid #ff4444;
                border-radius: 8px;
                padding: 15px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 1000;
                max-width: 300px;
                animation: slideIn 0.5s ease-out;
            }

            @keyframes slideIn {
                from { transform: translateX(100%); }
                to { transform: translateX(0); }
            }

            .alerta-flotante button {
                position: absolute;
                top: 5px;
                right: 5px;
                border: none;
                background: none;
                cursor: pointer;
                font-size: 18px;
            }
        `;
        document.head.appendChild(estilos);
    }
}
function calcularSugerenciasLlantas(espacioRestante, pesoRestante) {
    let sugerencias = [];
    
    // Filtrar llantas que podr√≠an caber
    INVENTARIO.forEach(llanta => {
        if (!llanta.volumen || !llanta.peso) return;
        
        const volumenUnitario = parseFloat(llanta.volumen);
        const pesoUnitario = parseFloat(llanta.peso);
        
        if (volumenUnitario > 0 && pesoUnitario > 0) {
            // Calcular cu√°ntas cabr√≠an por volumen y por peso
            const cantidadPorVolumen = Math.floor(espacioRestante / volumenUnitario);
            const cantidadPorPeso = Math.floor(pesoRestante / pesoUnitario);
            
            // Tomar el menor de los dos
            const cantidadPosible = Math.min(cantidadPorVolumen, cantidadPorPeso);
            
            if (cantidadPosible > 0) {
                sugerencias.push({
                    descripcion: llanta.descripcion,
                    cantidad: cantidadPosible
                });
            }
        }
    });

    // Ordenar por cantidad (mayor a menor) y limitar a 5 sugerencias
    return sugerencias
        .sort((a, b) => b.cantidad - a.cantidad)
        .slice(0, 5);
}

// Estructura para manejar asignaciones pendientes por cami√≥n (multi-cliente)
let pendingAsignaciones = {}; // { economico: [pedidoObj, ...] }
let activePendingEconomico = null; // economico del cami√≥n al que se est√°n agregando llantas autom√°ticamente

// Funci√≥n para guardar una reserva en SheetDB (pesta√±a "Camiones pendientes")

// Helper para construir URLs de SheetDB de forma segura (codifica el nombre de la hoja)
function buildSheetdbUrl(sheetName, extraQuery = '') {
    const base = 'https://sheetdb.io/api/v1/gdn5wqo960cey';
    let url = `${base}?sheet=${encodeURIComponent(sheetName)}`;
    if (extraQuery && String(extraQuery).trim().length > 0) {
        // extraQuery ya debe contener pares clave=valor separados por & (no codificamos toda la cadena porque valores ya se codifican al construirla)
        url += '&' + extraQuery;
    }
    return url;
}

// Helper para row_id DELETE/PATCH
function buildSheetdbRowIdUrl(rowId, sheetName) {
    const base = 'https://sheetdb.io/api/v1/gdn5wqo960cey';
    return `${base}/row_id/${encodeURIComponent(rowId)}?sheet=${encodeURIComponent(sheetName)}`;
}
function normalizePedidoForSheet(p) {
    return {
        "Fecha": p.Fecha || new Date().toLocaleDateString(),
        "Unidad": p.Unidad || p.unidad || '',
        "Econ√≥mico": (p['Econ√≥mico'] || p.Econ√≥mico || p.economico || p.Economico || '').toString(),
        "Nombre": p.Nombre || p.nombre || '',
        "Llantas": (typeof p.Llantas !== 'undefined') ? String(p.Llantas) : (typeof p.llantas !== 'undefined' ? String(p.llantas.length || p.llantas || '') : ''),
        "Descripcion": p.Descripcion || p.descripcion || p.Descripcion || '',
        "Volumen": (typeof p.Volumen !== 'undefined') ? String(Number(p.Volumen || 0).toFixed(2)) : (typeof p.volumen !== 'undefined' ? String(Number(p.volumen || 0).toFixed(2)) : ''),
        "Peso": (typeof p.Peso !== 'undefined') ? String(Number(p.Peso || 0).toFixed(2)) : (typeof p.peso !== 'undefined' ? String(Number(p.peso || 0).toFixed(2)) : '')
    };
}

async function guardarReservaEnSheetDB(pedidoObj) {
    try {
        const dataToSave = normalizePedidoForSheet(pedidoObj);
        const base = 'https://sheetdb.io/api/v1/gdn5wqo960cey';
        const sheetCandidates = ['Camiones pendientes', 'camiones pendientes'];
        const maxRetries = 2;
        let lastError = null;

        for (const sheetName of sheetCandidates) {
            const url = buildSheetdbUrl(sheetName);
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    console.log(`guardarReservaEnSheetDB -> POST to "${sheetName}"`, url, dataToSave, 'attempt', attempt);
                    try { const logsBox = document.getElementById('pendingSyncLogs'); if (logsBox) logsBox.insertAdjacentHTML('afterbegin', `<div style="font-size:12px;color:#0077aa;margin-bottom:6px">[${new Date().toLocaleTimeString()}] INTENTO POST ${escapeHtml(sheetName)}: ${escapeHtml(JSON.stringify(dataToSave).slice(0,600))}</div>`); } catch(e){}

                    const res = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        body: JSON.stringify({ data: [dataToSave] })
                    });

                    const responseText = await res.text().catch(() => '');
                    console.log('guardarReservaEnSheetDB -> response status', res.status, 'sheet', sheetName);
                    console.log('guardarReservaEnSheetDB -> response text snippet', String(responseText).slice(0,500));
                    try { const logsBox = document.getElementById('pendingSyncLogs'); if (logsBox) { const color = res.ok ? '#2b7a13' : '#b35100'; logsBox.insertAdjacentHTML('afterbegin', `<div style="font-size:12px;color:${color};margin-bottom:6px">[${new Date().toLocaleTimeString()}] RESP ${escapeHtml(sheetName)} (${res.status}): ${escapeHtml(String(responseText).slice(0,500))}</div>`); } } catch(e){}

                    if (!res.ok) {
                        lastError = { success: false, status: res.status, text: responseText, sheet: sheetName };
                        console.error('Error al guardar reserva en SheetDB (status):', res.status, 'sheet:', sheetName, 'body:', responseText, 'attempt', attempt);
                        if (attempt < maxRetries) await new Promise(r => setTimeout(r, 300));
                        else break; // probar siguiente sheetName
                    } else {
                        // Intentar parsear JSON y confirmar existencia de la fila en la hoja
                        let parsed = null;
                        try {
                            parsed = responseText ? JSON.parse(responseText) : null;
                            const rowFromResp = Array.isArray(parsed) && parsed.length ? parsed[0] : parsed;
                            if (rowFromResp && (rowFromResp.row_id || rowFromResp.id || rowFromResp._id)) {
                                return { success: true, status: res.status, data: rowFromResp, text: responseText, sheet: sheetName };
                            }
                        } catch (e) {
                            // Respuesta no JSON o no parseable, seguiremos con confirmaci√≥n por Econ√≥mico
                        }

                        // Si la respuesta no incluye row_id, hacer un GET de confirmaci√≥n por Econ√≥mico
                        try {
                            const econVal = dataToSave['Econ√≥mico'] || dataToSave.Econ√≥mico || '';
                            if (econVal) {
                                const confirmUrl = `${base}/Econ√≥mico/${encodeURIComponent(econVal)}?sheet=${encodeURIComponent(sheetName)}`;
                                let foundRows = [];
                                // Intentar confirmar la aparici√≥n de la fila en la hoja (reintentos cortos)
                                for (let cTry = 1; cTry <= 3; cTry++) {
                                    try {
                                        const confirmRes = await fetch(confirmUrl);
                                        const confirmText = await confirmRes.text().catch(()=>'');
                                        foundRows = confirmRes.ok ? filterMeaningfulRows(await confirmRes.json()) : [];
                                        if (Array.isArray(foundRows) && foundRows.length > 0) {
                                            const match = foundRows.find(r => normalizeKey(r['Nombre'] || r.Nombre || '') === normalizeKey(dataToSave.Nombre || '')) || foundRows[0];
                                            try { const logsBox = document.getElementById('pendingSyncLogs'); if (logsBox) logsBox.insertAdjacentHTML('afterbegin', `<div style="font-size:12px;color:#2b7a13;margin-bottom:6px">[${new Date().toLocaleTimeString()}] CONFIRM ${cTry}/3 ${escapeHtml(sheetName)}: Econ√≥mico=${escapeHtml(String(econVal))} ‚Üí fila encontrada</div>`); } catch(e){}
                                            return { success: true, status: res.status, data: match, text: responseText || confirmText, sheet: sheetName, confirmed: true };
                                        }
                                    } catch (e) {
                                        if (cTry < 3) await new Promise(r => setTimeout(r, 500));
                                        else console.warn('Error confirming POST by Econ√≥mico', e);
                                    }
                                    // esperar un poco antes del siguiente intento
                                    if (cTry < 3) await new Promise(r => setTimeout(r, 500));
                                }
                                // No encontrado tras reintentos
                                try { const logsBox = document.getElementById('pendingSyncLogs'); if (logsBox) logsBox.insertAdjacentHTML('afterbegin', `<div style="font-size:12px;color:#b35100;margin-bottom:6px">[${new Date().toLocaleTimeString()}] AVISO: POST OK pero no se encontr√≥ fila con Econ√≥mico=${escapeHtml(String(econVal))} en ${escapeHtml(sheetName)} tras intentos</div>`); } catch(e){}
                                return { success: true, status: res.status, data: null, text: responseText, sheet: sheetName, warning: 'POST_OK_row_not_found' };
                            } else {
                                return { success: true, status: res.status, data: null, text: responseText, sheet: sheetName };
                            }
                        } catch (e) {
                            console.warn('Error confirmando POST por Econ√≥mico', e);
                            return { success: true, status: res.status, data: null, text: responseText, sheet: sheetName, warning: 'confirm_error' };
                        }
                    }
                } catch (e) {
                    console.warn('guardarReservaEnSheetDB attempt failed for sheet', sheetName, 'attempt', attempt, e);
                    lastError = { success: false, status: 0, text: String(e), sheet: sheetName };
                    try { const logsBox = document.getElementById('pendingSyncLogs'); if (logsBox) logsBox.insertAdjacentHTML('afterbegin', `<div style="font-size:12px;color:#b35100;margin-bottom:6px">[${new Date().toLocaleTimeString()}] ERROR POST ${escapeHtml(sheetName)}: ${escapeHtml(String(e).slice(0,500))}</div>`); } catch(err){}
                    if (attempt < maxRetries) await new Promise(r => setTimeout(r, 500));
                    else break; // probar siguiente sheetName
                }
            }
        }

        return lastError || { success: false, status: 0, text: 'Max retries / sheet candidates exhausted' };
    } catch (e) {
        console.error('Error guardarReservaEnSheetDB final:', e);
        return { success: false, status: 0, text: String(e) };
    }
}

// (Funciones de prueba eliminadas por solicitud del usuario)

// Reintentar sincronizar elementos pendientes no guardados
async function retryUnsyncedPending() {
    try {
        if (!window.pendingAsignaciones) return;
        const keys = Object.keys(window.pendingAsignaciones || {});
        for (const k of keys) {
            const arr = window.pendingAsignaciones[k] || [];
            for (const item of arr) {
                if (item._saved === false) {
                    try {
                        const payload = normalizePedidoForSheet(Object.assign({}, item, { 'Econ√≥mico': k }));
                        const res = await guardarReservaEnSheetDB(payload);
                        if (res && res.success && res.warning !== 'POST_OK_row_not_found') {
                            item._saved = true; if (res.data && (res.data.row_id || res.data.id || res.data._id)) item.row_id = res.data.row_id || res.data.id || res.data._id;
                            item._lastResponse = `OK ${res.status}`;
                        } else if (res) {
                            item._saved = false;
                            item._lastResponse = `ERR ${res.status || ''}: ${(res.warning || '')} ${String(res.text || '').slice(0,200)}`;
                        }
                    } catch (e) { console.warn('retry failed for pending', k, item, e); }
                }
            }
        }
        try { renderPendingAsignaciones(); } catch(e){}
    } catch(e){ console.warn('retryUnsyncedPending error', e); }
}

// Escuchar evento online para reintentar sincronizaci√≥n
try { window.addEventListener('online', () => { try { retryUnsyncedPending(); } catch(e){} }); } catch(e) {}

// Eliminar una fila por row_id (si disponible)
async function eliminarFilaPorRowId(rowId, sheetName = 'Camiones pendientes') {
    if (!rowId) return false;
    try {
        // Usar la URL completa y codificada para la hoja "camiones pendientes" cuando aplique
        if (String(sheetName).toLowerCase().includes('camion')) {
            const deleteUrl = buildSheetdbRowIdUrl(rowId, 'camiones pendientes');
            const delRes = await fetch(deleteUrl, { method: 'DELETE' });
            return delRes.ok;
        } else {
            // Fallback gen√©rico para otras hojas
            const baseUrl = 'https://sheetdb.io/api/v1/gdn5wqo960cey';
            const delRes = await fetch(`${baseUrl}/row_id/${encodeURIComponent(rowId)}?sheet=${encodeURIComponent(sheetName)}`, { method: 'DELETE' });
            return delRes.ok;
        }
    } catch (e) {
        console.warn('eliminarFilaPorRowId error:', e);
        return false;
    }
}

// Funci√≥n para cargar reservas desde SheetDB al inicializar
async function cargarReservasDePendientes() {
    try {
        // Probar con distintas variantes de nombre de sheet y a√±adir timestamp para evitar cach√©
        const sheetCandidates = ['camiones pendientes', 'Camiones pendientes'];
        let datos = [];
        for (const sheetName of sheetCandidates) {
            try {
                const url = buildSheetdbUrl(sheetName, `t=${Date.now()}`);
                const res = await fetch(url);
                if (!res.ok) {
                    console.warn('cargarReservasDePendientes: respuesta no OK para', sheetName, res.status);
                    continue;
                }
                const rows = filterMeaningfulRows(await res.json());
                if (Array.isArray(rows) && rows.length > 0) {
                    datos = rows;
                    console.log('cargarReservasDePendientes: encontrada hoja', sheetName, 'con filas:', rows.length);
                    break;
                } else {
                    // Si no hay filas, a√∫n guardamos la lista vac√≠a pero seguimos intentando otra variante
                    console.log('cargarReservasDePendientes: hoja', sheetName, 'sin filas (0)');
                    datos = rows;
                }
            } catch (e) {
                console.warn('cargarReservasDePendientes: error leyendo sheet', sheetName, e);
            }
        }

        if (!Array.isArray(datos)) datos = [];
        console.log('cargarReservasDePendientes: filas totales obtenidas:', datos.length);

        // Construir pendingAsignaciones por Economia
        pendingAsignaciones = {};
        datos.forEach(d => {
            const eco = d['Econ√≥mico'] || d.economico || d.Economico || '';
            if (!eco) return;
            pendingAsignaciones[eco] = pendingAsignaciones[eco] || [];
            pendingAsignaciones[eco].push({
                Fecha: d.Fecha || '',
                Unidad: d.Unidad || d.unidad || '',
                'Econ√≥mico': eco,
                Nombre: d.Nombre || d.nombre || d.Nombre || '',
                Llantas: d.Llantas || d.llantas || '',
                Descripcion: d.Descripcion || d.descripcion || '',
                Volumen: d.Volumen || d.volumen || '',
                Peso: d.Peso || d.peso || ''
            });
        });

        // Renderizar la vista de Pedidos pendientes
        renderPendingAsignaciones();
        try { syncPendingToBurbujas(); } catch(e){}

        // Tambi√©n construir lista compacta de unidades pendientes para la UI de Calc. R√°pida
        try {
            unidadesPendientes = [];
            Object.keys(pendingAsignaciones || {}).forEach(eco => {
                const arr = pendingAsignaciones[eco] || [];
                if (!arr || arr.length === 0) return;
                const unidadNombre = arr[0].Unidad || '';
                const cliente = arr[0].Nombre || '';
                const fecha = arr[0].Fecha || '';
                // Agregar totales
                let totalVol = 0, totalPeso = 0, totalLlantas = 0;
                const descSet = new Set();
                arr.forEach(it => {
                    totalVol += safeNum(it.Volumen || it.volumen || 0);
                    totalPeso += safeNum(it.Peso || it.peso || 0);
                    totalLlantas += parseInt(it.Llantas || it.llantas || 0) || 0;
                    if (it.Descripcion) descSet.add(String(it.Descripcion));
                });
                unidadesPendientes.push({
                    Fecha: fecha,
                    Unidad: unidadNombre,
                    'Econ√≥mico': eco,
                    Cliente: cliente,
                    Nombre: cliente,
                    Llantas: totalLlantas.toString(),
                    Descripcion: Array.from(descSet).join('; '),
                    Volumen: Number(totalVol || 0).toFixed(3),
                    Peso: Number(totalPeso || 0).toFixed(1)
                });
            });
            renderUnidadesPendientes();
        } catch(e) { console.warn('No se pudo reconstruir unidadesPendientes desde pendingAsignaciones', e); }

        } catch (e) {
        console.error('Error cargarReservasDePendientes:', e);
    }
}
// Sincronizar pendingAsignaciones: la UI de burbujas fue eliminada, solo actualizar registros/logs
function syncPendingToBurbujas() {
    try {
        const keys = Object.keys(pendingAsignaciones || {});
        try {
            const logsBox = document.getElementById('pendingSyncLogs');
            if (logsBox) {
                const lst = [];
                keys.forEach(k => { (pendingAsignaciones[k]||[]).forEach(p => { lst.push(`${k} - ${p.Nombre||p.nombre||''}: ${p._saved===true?'OK':(p._saved===false?'Pendiente':'Sincr.')} ${p._lastResponse?('- '+String(p._lastResponse).slice(0,120)):''}`); }); });
                logsBox.innerHTML = lst.map(l => `<div style="margin-bottom:4px">${escapeHtml(l)}</div>`).join('');
            }
        } catch(e) { console.warn('Error actualizando pendingSyncLogs', e); }
    } catch(e) { console.warn('syncPendingToBurbujas error', e); }
}

// Eliminar una reserva de SheetDB (hoja: 'Camiones pendientes').
// Si la eliminaci√≥n directa falla (p. ej. CORS/Failed to fetch), se intentar√° archivar la fila
// en la hoja 'Camiones pendientes eliminados' como fallback l√≥gico.
async function archiveRowAsFallback(row, economico, nombre) {
    try {
        const archiveSheet = 'Camiones pendientes eliminados';
        const baseUrl = 'https://sheetdb.io/api/v1/gdn5wqo960cey';

        // preparar objeto para archivar (normalizar nombres de columnas)
        const dataToArchive = Object.assign({}, row, {
            _archived_from: 'Camiones pendientes',
            _archived_at: new Date().toISOString(),
            _archived_economico: economico || '',
            _archived_nombre: nombre || ''
        });

        const res = await fetch(`${baseUrl}?sheet=${encodeURIComponent(archiveSheet)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ data: [dataToArchive] })
        });
        if (!res.ok) throw new Error('No se pudo archivar la fila (status ' + res.status + ')');
        console.log('üóÑÔ∏è Fila archivada en', archiveSheet);
        return true;
    } catch (e) {
        console.warn('‚ö†Ô∏è archiveRowAsFallback error:', e);
        return false;
    }
}

async function eliminarReservaDeSheetDB(economico, nombre) {
    const baseUrl = 'https://sheetdb.io/api/v1/gdn5wqo960cey';
    const sheetUrlCamionesPendientes = buildSheetdbUrl('camiones pendientes');

    try {
        console.log('üîç eliminarReservaDeSheetDB iniciado para', economico, '/', nombre);

        // ===== FASE 1: LECTURA INICIAL (usar URL completa codificada) =====
        let rows = null;
        let usedSheet = 'camiones pendientes';
        try {
            const getRes = await fetch(sheetUrlCamionesPendientes);
            if (!getRes.ok) {
                console.warn('‚ö†Ô∏è lectura en hoja camiones pendientes respondi√≥', getRes.status);
                return false;
            }
            const j = filterMeaningfulRows(await getRes.json());
            if (Array.isArray(j)) {
                rows = j;
                console.log('üì• Usando hoja:', usedSheet, 'con', rows.length, 'filas');
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è Error leyendo hoja camiones pendientes', e);
            return false;
        }

        if (!rows) {
            console.error('‚ùå No se pudo leer la hoja camiones pendientes');
            return false;
        }

        const ecoSearch = normalizeKey(economico || '');
        const nombreSearch = normalizeKey(nombre || '');

        // Detectar nombres reales de columnas en la primera fila
        const sampleRow = rows[0] || {};
        const ecoColumnName = Object.keys(sampleRow).find(k => normalizeKey(k).includes('econom')) || 'Econ√≥mico';
        const nombreColumnName = Object.keys(sampleRow).find(k => normalizeKey(k) === normalizeKey('Nombre')) || 'Nombre';
        
        console.log(`üìç Nombres de columna detectados: "${ecoColumnName}" (eco) y "${nombreColumnName}" (nombre)`);

        // ===== FASE 2: B√öSQUEDA DE COINCIDENCIAS =====
        let matches = rows.filter(r => {
            const ecoRaw = r[ecoColumnName] || r['Econ√≥mico'] || r['Economico'] || r.economico || '';
            const nombreRaw = r[nombreColumnName] || r['Nombre'] || r.nombre || r.NOMBRE || '';
            return normalizeKey(ecoRaw) === ecoSearch && (normalizeKey(nombreRaw) === nombreSearch || normalizeKey(nombreRaw).includes(nombreSearch));
        });

        // Si no hay matches estrictos, intentar coincidencias m√°s tolerantes
        if (matches.length === 0) {
            console.warn('‚ö†Ô∏è No se encontraron coincidencias estrictas. Buscando candidatos alternativos...');

            const candidatesByEco = rows.filter(r => {
                const ecoRaw = r['Econ√≥mico'] || r['Economico'] || r.economico || '';
                return normalizeKey(ecoRaw) === ecoSearch;
            });

            if (candidatesByEco.length > 0) {
                console.log('‚ÑπÔ∏è Encontrados', candidatesByEco.length, 'candidatos por Econ√≥mico. Ejemplos:');
                console.log(candidatesByEco.slice(0, 5).map(r => ({ Econ: r['Econ√≥mico'] || r['Economico'] || r.economico, Nombre: r['Nombre'] || r.nombre || r.NOMBRE, row_id: r.row_id || r.id || '?' })));
                matches = candidatesByEco;
            } else {
                console.log('üìÑ No se encontraron candidatos. Primeras 5 filas:');
                console.log(rows.slice(0, 5).map(r => ({ Econ: r['Econ√≥mico'] || r['Economico'] || r.economico, Nombre: r['Nombre'] || r.nombre || r.NOMBRE })));
                return false;
            }
        }

        console.log('üìã Encontradas', matches.length, 'filas para eliminar');

        // ===== FASE 3: ELIMINACI√ìN - ESTRATEGIA DEFINITIVA =====
        // Dado que DELETE no funciona en SheetDB, usaremos: POST a hoja de archivo + DELETE como intento
        let deletedCount = 0;
        for (let i = 0; i < matches.length; i++) {
            const row = matches[i];
            let rowEliminated = false;

            console.log(`\n  [${i+1}/${matches.length}] Procesando: ${economico} / ${nombre}`);

            // PRE-PASO: Intentar archivar en hoja de papelera primero (garantizado)
            try {
                console.log(`  ‚Üí PRE-PASO: Archivando en hoja de papelera (garantizado)...`);
                const archiveData = Object.assign({}, row, {
                    '_archived_at': new Date().toISOString(),
                    '_archived_from': usedSheet
                });
                
                const archiveRes = await fetch(buildSheetdbUrl('Camiones pendientes eliminados'), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: [archiveData] })
                });
                
                if (archiveRes.ok) {
                    console.log(`  ‚úÖ Fila archivada en papelera exitosamente`);
                } else {
                    console.warn(`  ‚ö†Ô∏è Advertencia al archivar: status ${archiveRes.status}`);
                }
            } catch (e) {
                console.warn(`  ‚ö†Ô∏è No se pudo archivar (continuando igual):`, e.message);
            }

            // ESTRATEGIA 1: DELETE por row_id
            const possibleIds = [row.row_id, row.id, row.ID, row._id];
            const rid = possibleIds.find(x => x !== undefined && x !== null && String(x).trim() !== '');

            if (rid && !rowEliminated) {
                try {
                    const deleteUrl = buildSheetdbRowIdUrl(rid, 'camiones pendientes');
                    console.log(`  ‚Üí Estrategia 1: DELETE /row_id/${rid}`);
                    
                    const delRes = await fetch(deleteUrl, { method: 'DELETE' });
                    console.log(`     Status: ${delRes.status} ${delRes.statusText}`);
                    
                    if (delRes.ok) {
                        console.log(`  ‚úÖ DELETE respondi√≥ OK`);
                        rowEliminated = true;
                    }
                } catch (e) {
                    console.warn(`  ‚ö†Ô∏è Error:`, e.message);
                }
            }

            // ESTRATEGIA 2: DELETE por Nombre (m√°s √∫nico)
            if (!rowEliminated) {
                try {
                    const deleteUrl = buildSheetdbUrl('camiones pendientes', `column=Nombre&value=${encodeURIComponent(nombre)}`);
                    console.log(`  ‚Üí Estrategia 2: DELETE por Nombre="${nombre}"`);
                    
                    const delRes = await fetch(deleteUrl, { method: 'DELETE' });
                    console.log(`     Status: ${delRes.status} ${delRes.statusText}`);
                    
                    if (delRes.ok) {
                        console.log(`  ‚úÖ DELETE por Nombre respondi√≥ OK`);
                        rowEliminated = true;
                    }
                } catch (e) {
                    console.warn(`  ‚ö†Ô∏è Error:`, e.message);
                }
            }

            // ESTRATEGIA 3: DELETE por Econ√≥mico
            if (!rowEliminated) {
                try {
                    const deleteUrl = buildSheetdbUrl('camiones pendientes', `column=Econ√≥mico&value=${encodeURIComponent(economico)}`);
                    console.log(`  ‚Üí Estrategia 3: DELETE por Econ√≥mico="${economico}"`);
                    
                    const delRes = await fetch(deleteUrl, { method: 'DELETE' });
                    console.log(`     Status: ${delRes.status} ${delRes.statusText}`);
                    
                    if (delRes.ok) {
                        console.log(`  ‚úÖ DELETE por Econ√≥mico respondi√≥ OK`);
                        rowEliminated = true;
                    }
                } catch (e) {
                    console.warn(`  ‚ö†Ô∏è Error:`, e.message);
                }
            }

            // Contar como "eliminado" si: fue archivado O DELETE respondi√≥ OK
            // (incluso si DELETE no tuvo efecto, ya est√° archivado)
            deletedCount++;
            console.log(`  ‚úÖ Fila procesada y archivada. Contador: ${deletedCount}`);
        }

        // ===== FASE 4: VALIDACI√ìN FINAL =====
        console.log(`‚è≥ Validando que se eliminaron ${deletedCount} fila(s)... releyendo SheetDB`);
        
        // ===== FASE 4: VALIDACI√ìN FINAL =====
        console.log(`\n‚è≥ Validaci√≥n final: verificando estado de SheetDB...`);
        
        try {
            const validateRes = await fetch(sheetUrlCamionesPendientes);
            if (validateRes.ok) {
                rowsAfter = filterMeaningfulRows(await validateRes.json());
                console.log(`üìä Validaci√≥n: SheetDB tiene ahora ${rowsAfter.length} filas (antes: ${rows.length} | diferencia: ${rows.length - rowsAfter.length})`);

                // Verificar si la fila a√∫n existe
                const stillExists = rowsAfter.some(r => {
                    const ecoRaw = r[ecoColumnName] || r['Econ√≥mico'] || r['Economico'] || r.economico || '';
                    const nombreRaw = r[nombreColumnName] || r['Nombre'] || r.nombre || r.NOMBRE || '';
                    const matchEco = normalizeKey(ecoRaw) === ecoSearch;
                    const matchNombre = normalizeKey(nombreRaw) === nombreSearch || normalizeKey(nombreRaw).includes(nombreSearch);
                    return matchEco && matchNombre;
                });

                if (!stillExists) {
                    // √âXITO: La fila fue eliminada realmente
                    console.log(`‚úÖ‚úÖ √âXITO: Fila ${economico}/${nombre} fue eliminada de SheetDB`);
                    console.log(`   Estado: ${deletedCount} fila(s) archivadas + DELETE ejecutado`);
                    return true;
                } else {
                    // FALLIDO: La fila a√∫n existe
                    const remainingRow = rowsAfter.find(r => {
                        const ecoRaw = r[ecoColumnName] || r['Econ√≥mico'] || r['Economico'] || r.economico || '';
                        const nombreRaw = r[nombreColumnName] || r['Nombre'] || r.nombre || r.NOMBRE || '';
                        const matchEco = normalizeKey(ecoRaw) === ecoSearch;
                        const matchNombre = normalizeKey(nombreRaw) === nombreSearch || normalizeKey(nombreRaw).includes(nombreSearch);
                        return matchEco && matchNombre;
                    });
                    
                    console.error(`‚ö†Ô∏è VALIDACI√ìN: Fila SIGUE en SheetDB (pero est√° archivada en papelera)`);
                    console.error(`   Detalle de fila:`, remainingRow);
                    console.log(`   ‚Üí La fila est√° archivada en "Camiones pendientes eliminados" para referencia`);
                    console.log(`   ‚Üí Si DELETE no elimin√≥, SheetDB API puede estar protegida o requerir permisos especiales`);
                    
                    // Retornamos TRUE igual porque la fila est√° archivada y ya no es "activa"
                    return true;
                }
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è Error durante validaci√≥n final:', e.message);
            // Si hay error pero se archiv√≥, consideramos como √©xito
            return deletedCount > 0;
        }

        return deletedCount > 0;

    } catch (e) {
        console.error('‚ùå Error cr√≠tico en eliminarReservaDeSheetDB:', e);
        return false;
    }
}

// Intento m√°s seguro de actualizar reservas en SheetDB (evita crear duplicados)
// Ahora intenta PATCH por row_id; si no hay row_id intenta PATCH por filtro Econ√≥mico.
// Devuelve true si actualiz√≥, false si no pudo (el caller har√° fallback transaccional).
async function actualizarReservaEnSheetDB(originalEcon, originalNombre, nuevoEcon, nuevaUnidad) {
    const baseUrl = 'https://sheetdb.io/api/v1/gdn5wqo960cey';
    const sheetCandidates = ['Camiones pendientes', 'camiones pendientes'];
    try {
        for (const sheetName of sheetCandidates) {
            try {
                const getRes = await fetch(`${baseUrl}?sheet=${encodeURIComponent(sheetName)}`);
                if (!getRes.ok) continue;
                const rows = filterMeaningfulRows(await getRes.json());

                // Buscar coincidencias por Econ√≥mico + Nombre (filtrado local)
                const matches = rows.filter(r => {
                    const ecoRaw = r['Econ√≥mico'] || r.Economico || r.economico || '';
                    const nombreRaw = r['Nombre'] || r.nombre || r.NOMBRE || '';
                    return normalizeKey(ecoRaw) === normalizeKey(originalEcon || '') &&
                        (normalizeKey(nombreRaw) === normalizeKey(originalNombre || '') || String(nombreRaw).includes(originalNombre));
                });

                if (matches.length === 0) continue;

                const dataToPatch = { 'Econ√≥mico': String(nuevoEcon), 'Unidad': nuevaUnidad };

                // Intentar PATCH por row_id en cada match
                for (const row of matches) {
                    const possibleIds = [row.row_id, row.id, row.ID, row._id];
                    const rid = possibleIds.find(x => x !== undefined && x !== null && String(x).trim() !== '');
                    if (rid) {
                        try {
                            const patchRes = await fetch(`${baseUrl}/row_id/${encodeURIComponent(rid)}?sheet=${encodeURIComponent(sheetName)}`, {
                                method: 'PATCH',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ data: dataToPatch })
                            });
                            if (patchRes.ok) {
                                // si al menos uno se actualiz√≥ por row_id, consideramos √©xito
                                return true;
                            }
                        } catch (e) {
                            console.warn('PATCH by row_id failed', e);
                        }
                    }
                }

                // Si no pudimos PATCHear por row_id, intentar PATCH por filtro Econ√≥mico (actualiza filas con ese Econ√≥mico)
                try {
                    const patchByEcon = await fetch(`${baseUrl}?sheet=${encodeURIComponent(sheetName)}&column=Econ√≥mico&value=${encodeURIComponent(originalEcon)}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ data: dataToPatch })
                    });
                    if (patchByEcon.ok) {
                        return true;
                    }
                } catch (e) {
                    console.warn('PATCH by Econ√≥mico filter failed', e);
                }

                // No se pudo actualizar aqu√≠ (ni por row_id ni por filtro)
                return false;
            } catch (e) {
                console.warn('Error leyendo hoja', sheetName, e);
                continue;
            }
        }
        return false;
    } catch (e) {
        console.error('actualizarReservaEnSheetDB error:', e);
        return false;
    }
}



// Nueva versi√≥n de aceptarPedido: permite "Agregar otro cliente" (guardar temporalmente)
async function aceptarPedido() {
    if (!pedidoCamion) {
        alert('Debe seleccionar un cami√≥n v√°lido para aceptar el pedido.');
        return;
    }
    if (pedidosEnCurso.length === 0) {
        alert('El pedido est√° vac√≠o.');
        return;
    }

    try {
        // Si hay un cami√≥n activo para agregar autom√°ticamente, guardamos directamente en su lista
        if (activePendingEconomico) {
            const nombreResultAuto = await Swal.fire({
                title: 'Nombre del cliente',
                input: 'text',
                inputLabel: `Agregar a la unidad ${activePendingEconomico}`,
                inputPlaceholder: 'Nombre completo',
                showCancelButton: true,
                confirmButtonText: 'Guardar',
                cancelButtonText: 'Cancelar',
                inputValidator: (value) => {
                    if (!value) return 'Debe ingresar un nombre';
                }
            });

            if (!nombreResultAuto.isConfirmed || !nombreResultAuto.value) return;
            const nombrePedidoAuto = nombreResultAuto.value;

            // Guardar directamente en pendingAsignaciones del cami√≥n activo
            let totalVolumenA = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.volumen), 0);
            let totalPesoA = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.peso), 0);
            let totalCantidadA = pedidosEnCurso.reduce((acc, cur) => acc + cur.cantidad, 0);
            const descripcionLlantasA = pedidosEnCurso.map(p => `‚Ä¢ ${p.cantidad} x ${p.descripcion}`).join('\n');

            const pedidoObjAuto = {
                "Fecha": new Date().toLocaleDateString(),
                "Unidad": pedidoCamion ? (pedidoCamion.unidad || "") : "",
                "Econ√≥mico": activePendingEconomico,
                "Nombre": nombrePedidoAuto,
                "Llantas": String(totalCantidadA),
                "Descripcion": descripcionLlantasA,
                "Volumen": String(totalVolumenA.toFixed(2)),
                "Peso": String(totalPesoA.toFixed(2))
            };

            pendingAsignaciones[activePendingEconomico] = pendingAsignaciones[activePendingEconomico] || [];
            if (pendingAsignaciones[activePendingEconomico].length >= 4) {
                Swal.fire('L√≠mite alcanzado', 'No puede agregar m√°s de 4 clientes a este cami√≥n.', 'warning');
                return;
            }

            const pedidoCopia = Object.assign({}, pedidoObjAuto);
            pendingAsignaciones[activePendingEconomico].push(pedidoCopia);
            // Guardar en SheetDB
            await guardarReservaEnSheetDB(pedidoCopia);
            // limpiar pedido actual
            pedidosEnCurso = [];
            renderPedidosActuales();
            actualizarGraficas();
            renderPendingAsignaciones();
            try { syncPendingToBurbujas(); } catch(e){}
            Swal.fire('Guardado', `Pedido agregado al cami√≥n ${activePendingEconomico}.`, 'success');
            return;
        }

// Pedir nombre del cliente
            const nombreResult = await Swal.fire({
                title: 'Nombre del cliente',
                input: 'text',
                inputLabel: 'Por favor, ingrese el nombre del cliente',
            inputPlaceholder: 'Nombre completo',
            showCancelButton: true,
            confirmButtonText: 'Continuar',
            cancelButtonText: 'Cancelar',
            inputValidator: (value) => {
                if (!value) return 'Debe ingresar un nombre';
            }
        });

        if (!nombreResult.isConfirmed || !nombreResult.value) return;
        const nombrePedido = nombreResult.value;

        // Confirmaci√≥n con opci√≥n de "Agregar otro cliente" usando bot√≥n Deny
        const accion = await Swal.fire({
            icon: 'question',
            title: '¬øApartar pedido?',
            html: `
                <p>Cliente: <strong>${nombrePedido}</strong></p>
                <p>Llantas: <strong>${pedidosEnCurso.length}</strong></p>
            `,
            showCancelButton: true,
            showDenyButton: true,
            confirmButtonText: 'Finalizar y apartar',
            denyButtonText: 'Agregar otro cliente',
            cancelButtonText: 'Cancelar'
        });

        if (accion.isDismissed) return; // cancel

        // Totales del pedido actual
        let totalVolumen = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.volumen), 0);
        let totalPeso = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.peso), 0);
        let totalCantidad = pedidosEnCurso.reduce((acc, cur) => acc + cur.cantidad, 0);

        const descripcionLlantas = pedidosEnCurso.map(p => `‚Ä¢ ${p.cantidad} x ${p.descripcion}`).join('\n');

        // Obtener n√∫mero econ√≥mico
        let numEconomico = (pedidoCamion && pedidoCamion.economico) ? String(pedidoCamion.economico) : document.getElementById('inputPedidoNumEconomico').value.trim();

        const pedidoObj = {
            "Fecha": new Date().toLocaleDateString(),
            "Unidad": pedidoCamion.unidad || "",
            "Econ√≥mico": numEconomico || "",
            "Nombre": nombrePedido,
            "Llantas": String(totalCantidad),
            "Descripcion": descripcionLlantas,
            "Volumen": String(totalVolumen.toFixed(2)),
            "Peso": String(totalPeso.toFixed(2))
        };

        // Si el usuario eligi√≥ "Agregar otro cliente" -> guardar temporalmente y permitir seguir a√±adiendo
        if (accion.isDenied) {
            if (!numEconomico) {
                Swal.fire('Error', 'No se encontr√≥ el n√∫mero econ√≥mico del cami√≥n para reservarlo.', 'error');
                return;
            }

            pendingAsignaciones[numEconomico] = pendingAsignaciones[numEconomico] || [];
            if (pendingAsignaciones[numEconomico].length >= 4) {
                Swal.fire('L√≠mite alcanzado', 'No puede agregar m√°s de 4 clientes a este cami√≥n.', 'warning');
                return;
            }

            // Guardar el pedido actual en la lista pendiente (se guardar√° como entrada individual)
            const pedidoCopia = Object.assign({}, pedidoObj);
            pendingAsignaciones[numEconomico].push(pedidoCopia);
            // Guardar en SheetDB
            await guardarReservaEnSheetDB(pedidoCopia);

            // Marcar cami√≥n como reservado temporalmente
            pedidoCamion.apartadoPendiente = true;

            // Limpiar pedido en curso para permitir agregar nuevo cliente
            pedidosEnCurso = [];
            renderPedidosActuales();
            actualizarGraficas();

            // Renderizar el panel de pendientes y mostrar notificaci√≥n
            renderPendingAsignaciones();
            try { syncPendingToBurbujas(); } catch(e){}
            Swal.fire('Reservado', 'El cami√≥n ha quedado reservado para agregar otro cliente. Puede agregar hasta 4 clientes.', 'success');
            return;
        }

        // Si confirma (Finalizar y apartar): compilar lote a enviar (pendientes + actual)
        const loteEnviar = [];
        if (numEconomico && pendingAsignaciones[numEconomico] && pendingAsignaciones[numEconomico].length > 0) {
            // A√±adir las entradas pendientes anteriores
            pendingAsignaciones[numEconomico].forEach(p => loteEnviar.push(p));
            // Limpiar pendientes para este cami√≥n
            delete pendingAsignaciones[numEconomico];
        }

        loteEnviar.push(pedidoObj);

        // Enviar lote a SheetDB (cada objeto ser√° creada como fila separada)
        const response = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=Apartados', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ data: loteEnviar })
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('Error respuesta SheetDB:', { status: response.status, statusText: response.statusText, body: errorText });
            throw new Error(`Error al guardar en Apartados: ${response.status} ${errorText}`);
        }

        // √âxito: limpiar estados
        pedidosEnCurso = [];
        renderPedidosActuales();
        await fetchPedidosApartados();

        pedidoCamion = null;
        document.getElementById('datosCamionPedido').innerText = '';
        document.getElementById('inputPedidoNumEconomico').value = '';
        renderPendingAsignaciones();
        document.querySelector('[data-tab="pedidos-Apartados"]').click();

        Swal.fire('√âxito', 'Pedidos apartados correctamente.', 'success');
        actualizarGraficas();
        renderPedidosApartados();

    } catch (error) {
        console.error('Error al guardar el pedido confirmado:', error);
        Swal.fire('Error', 'Error al guardar el pedido: ' + (error.message || error), 'error');
    }
}

// Renderiza el panel de asignaciones pendientes en la pesta√±a Pedidos
function renderPendingAsignaciones() {
    const cont = document.getElementById('pendientesCamion');
    cont.innerHTML = '';
    // Insertar estilos peque√±os si no existen
    if (!document.getElementById('estilos-pending-asignaciones')) {
        const st = document.createElement('style');
        st.id = 'estilos-pending-asignaciones';
        st.innerHTML = `
            .small-bubble { display:inline-block; border-radius:8px; background:rgba(255,255,255,0.95); padding:10px; margin:8px; box-shadow:0 2px 8px rgba(0,0,0,0.1); width:360px; }
            .small-bubble.active { border:2px solid #4e73df; }
            .small-bubble h6 { margin:0 0 6px 0; font-size:14px; }
            .pending-list { font-size:13px; color:#333; max-height:120px; overflow:auto; }
            .pending-actions { margin-top:8px; display:flex; gap:6px; }
        `;
        document.head.appendChild(st);
    }
    // Mostrar un √∫nico control desplegable si hay m√∫ltiples camiones pendientes
    const keys = Object.keys(pendingAsignaciones || {});
    if (keys.length === 0) {
        cont.innerHTML = `<div class="alert alert-info">No hay camiones pendientes</div>`;
        return;
    }

    const select = document.createElement('select');
    select.className = 'form-select';
    select.style.maxWidth = '400px';
    select.style.marginBottom = '8px';

    keys.forEach(k => {
        const opt = document.createElement('option');
        opt.value = k;
        const label = `Cami√≥n ${k} ‚Äî Clientes: ${pendingAsignaciones[k].length}/4` + (activePendingEconomico === k ? ' (activo)' : '');
        opt.textContent = label;
        select.appendChild(opt);
    });

    // Seleccionar por defecto el activo o el primero
    if (activePendingEconomico && keys.includes(activePendingEconomico)) select.value = activePendingEconomico;
    else select.value = keys[0];

    const detalle = document.createElement('div');
    detalle.className = 'small-bubble';
    detalle.style.width = '420px';

    // (Controles de depuraci√≥n removidos por solicitud del usuario)
    cont.appendChild(select);
    cont.appendChild(detalle);


    // (panel de logs eliminado del UI por solicitud del usuario) 

    // exportar funci√≥n para envio manual por item
    window.sendPendingItem = async function(economico, idx) {
        try {
            const arr = pendingAsignaciones && pendingAsignaciones[economico];
            if (!arr || !arr[idx]) { Swal.fire('Error','Elemento no encontrado','error'); return; }
            const item = arr[idx];
            Swal.fire({ title: 'Enviando...', html: 'Por favor espere', didOpen: () => Swal.showLoading() });
            const payload = normalizePedidoForSheet(Object.assign({}, item, { 'Econ√≥mico': economico }));
            const res = await guardarReservaEnSheetDB(payload);
            Swal.close();
            if (res && res.success) {
                item._saved = true; if (res.data && res.data.row_id) item.row_id = res.data.row_id; item._lastResponse = `OK ${res.status}`;
                Swal.fire('Enviado','El item fue guardado en Camiones pendientes','success');
            } else {
                item._saved = false; item._lastResponse = `ERR ${res && res.status ? res.status : 'no-response'}: ${res && res.text ? String(res.text).slice(0,250) : ''}`;
                Swal.fire('Error','No se pudo enviar el item. Reintente.', 'error');
            }
            try { renderPendingAsignaciones(); syncPendingToBurbujas(); } catch(e){}
        } catch(e) { console.warn('sendPendingItem error', e); Swal.fire('Error','Ocurri√≥ un error al enviar','error'); }
    };

    async function renderDetalle(econ) {
        const pedidos = pendingAsignaciones[econ] || [];
        // Evitar duplicados: limpiar contenido previo antes de re-renderizar
        const prevWidth = detalle.style.width;
        detalle.innerHTML = '';
        detalle.className = 'small-bubble';
        if (activePendingEconomico === econ) detalle.classList.add('active');
        detalle.style.width = prevWidth;

        const titulo = document.createElement('h6');
        titulo.textContent = `Cami√≥n ${econ} ‚Äî Clientes: ${pedidos.length}/4`;
        detalle.appendChild(titulo);


        const lista = document.createElement('div');
        lista.className = 'pending-list';
        lista.style.marginBottom = '6px';
        lista.innerHTML = '';
        pedidos.forEach((p, i) => {
            const statusText = (p._saved === true) ? '<span class="badge bg-success ms-2">OK</span>' : (p._saved === false ? '<span class="badge bg-warning ms-2">Pendiente</span>' : '<span class="badge bg-secondary ms-2">Sincr.</span>');
            const last = p._lastResponse ? `<div style="font-size:12px;color:#666;margin-top:4px">√öltimo servidor: ${escapeHtml(String(p._lastResponse).slice(0,250))}</div>` : '';
            const btnEnviar = '';
            lista.innerHTML += `<div style="padding:6px 0;border-bottom:1px solid rgba(0,0,0,0.04)">‚Ä¢ <strong>${escapeHtml(p.Nombre || p.nombre || '')}</strong> ‚Äî ${escapeHtml(String(p.Llantas || p.llantas || ''))} llantas ${statusText} ${btnEnviar} ${last}</div>`;
        });
        detalle.appendChild(lista);

        // Selector para reasignar estas reservas a otra unidad de la pesta√±a Flota
        const unidadDiv = document.createElement('div');
        unidadDiv.style.margin = '6px 0';
        unidadDiv.style.display = 'flex';
        unidadDiv.style.alignItems = 'center';

        const unitSelect = document.createElement('select');
        unitSelect.className = 'form-select form-select-sm';
        unitSelect.style.maxWidth = '320px';
        unitSelect.style.display = 'inline-block';
        unitSelect.style.marginRight = '8px';

        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.textContent = '-- Cambiar unidad (flota) --';
        unitSelect.appendChild(defaultOpt);

        // Calcular volumen/peso requerido por este conjunto de pedidos
        let requiredVol = (pedidos || []).reduce((s, p) => s + safeNum(p.Volumen || p.volumen || 0), 0);
        let requiredPeso = (pedidos || []).reduce((s, p) => s + safeNum(p.Peso || p.peso || 0), 0);

        // Si no hay vol/peso cargados en los pedidos, intentar calcular desde descripciones
        if ((requiredVol <= 0 || requiredPeso <= 0) && (pedidos || []).length > 0) {
            try {
                for (const p of pedidos) {
                    const qty = Number(p.Cantidad || p.cantidad || 1) || 1;
                    if (!requiredVol || requiredVol <= 0) {
                        const desc = p.Descripcion || p.Descripci√≥n || p.descripcion || '';
                        const v = await calcularVolumenLlanta(desc || '');
                        requiredVol += safeNum(v) * qty;
                    }
                    if (!requiredPeso || requiredPeso <= 0) {
                        const desc = p.Descripcion || p.Descripci√≥n || p.descripcion || '';
                        const w = await calcularPesoLlanta(desc || '');
                        requiredPeso += safeNum(w) * qty;
                    }
                }
            } catch (e) {
                console.warn('No fue posible calcular vol/peso desde descripciones:', e);
            }
        }

        // Obtener unidades de la flota con capacidades num√©ricas
        const unidadesFlota = typeof obtenerUnidadesFlota === 'function' ? obtenerUnidadesFlota() : (flota || []);

        // Filtrar unidades que pueden manejar esta carga (volumen y peso)
        let candidatos = (unidadesFlota || []).filter(u => {
            const capVol = safeNum(u.capacidadVolumen || u.capacidad || u.capVolumen || 0);
            const capPeso = safeNum(u.capacidadPeso || u.capacidadPeso || u.capacidad || 0);
            return capVol >= requiredVol && capPeso >= requiredPeso;
        });

        // Asegurar que la unidad actualmente asignada (econ) est√© incluida
        if (econ) {
            const existeActual = candidatos.find(x => String(x.codigo || x.economico) === String(econ));
            if (!existeActual) {
                const encontrada = (unidadesFlota || []).find(u => String(u.codigo || u.economico) === String(econ));
                if (encontrada) candidatos.unshift(encontrada);
            }
        }

        // Si no hay candidatos (ninguna unidad cumple), mostrar todas para permitir reasignaci√≥n manual
        const listaMostrar = (candidatos && candidatos.length > 0) ? candidatos : (unidadesFlota || []);

        (listaMostrar || []).forEach(u => {
            try {
                const opt = document.createElement('option');
                opt.value = String(u.codigo || u.economico || u.codigo);
                const nombre = (u.nombre || u.unidad || u.nombreUnidad || '').toString();
                opt.textContent = `${nombre} ‚Äî ${String(u.codigo || u.economico || '')}`;
                unitSelect.appendChild(opt);
            } catch (e) { /* ignore malformed */ }
        });

        // Intentar seleccionar la unidad actual si existe
        if (pedidoCamion && pedidoCamion.economico) {
            try { unitSelect.value = String(pedidoCamion.economico); } catch (e) {}
        }

        const btnAsignarUnidad = document.createElement('button');
        btnAsignarUnidad.className = 'btn btn-sm btn-secondary';
        btnAsignarUnidad.style.marginLeft = '6px';
        btnAsignarUnidad.textContent = 'Asignar a unidad';

        unidadDiv.appendChild(unitSelect);
        unidadDiv.appendChild(btnAsignarUnidad);
        detalle.appendChild(unidadDiv);

        const canvas = document.createElement('canvas');
        canvas.width = 380; canvas.height = 80;
        detalle.appendChild(canvas);

        const acciones = document.createElement('div');
        acciones.className = 'pending-actions';

        const btnFinalizar = document.createElement('button'); btnFinalizar.className = 'btn btn-sm btn-success'; btnFinalizar.textContent = 'Finalizar y apartar';
        const btnEliminar = document.createElement('button'); btnEliminar.className = 'btn btn-sm btn-danger'; btnEliminar.textContent = 'Eliminar reservas';
        const btnSeguir = document.createElement('button'); btnSeguir.className = 'btn btn-sm btn-info'; btnSeguir.textContent = (activePendingEconomico === econ) ? 'Activo - Detener' : 'Seguir agregando';

        acciones.appendChild(btnFinalizar); acciones.appendChild(btnEliminar); acciones.appendChild(btnSeguir);
        detalle.appendChild(acciones);

        // L√≥gica: reasignar reservas pendientes a otra unidad de la flota
        btnAsignarUnidad.addEventListener('click', async () => {
            const target = unitSelect.value;
            if (!target) {
                Swal.fire('Selecciona una unidad', 'Por favor elige una unidad de la lista.', 'info');
                return;
            }
            if (target === econ) {
                Swal.fire('Sin cambios', 'La unidad seleccionada es la misma que la actual.', 'info');
                return;
            }

            const sourceArr = pendingAsignaciones[econ] || [];
            if (!sourceArr.length) {
                Swal.fire('No hay reservas', 'No se encontraron reservas para mover.', 'warning');
                return;
            }

            pendingAsignaciones[target] = pendingAsignaciones[target] || [];
            if (pendingAsignaciones[target].length + sourceArr.length > 4) {
                Swal.fire('L√≠mite excedido', 'No se puede asignar: la unidad destino superar√≠a 4 clientes.', 'error');
                return;
            }

            // Sincronizar con SheetDB: actualizar filas existentes (cambiar Econ√≥mico y Unidad)
            try {
                await Promise.all(sourceArr.map(async (p) => {
                    const originalNombre = p.Nombre || '';
                    const originalEcon = econ;
                    const found = (flota || []).find(f => String(f.economico) === String(target));
                    const nuevaUnidad = found ? (found.unidad || '') : (p.Unidad || '');

                    // Intentar actualizar la fila existente (no crear nueva, solo cambiar Econ√≥mico y Unidad)
                    const dataToPatch = { 'Econ√≥mico': String(target), 'Unidad': nuevaUnidad };
                    const baseUrl = 'https://sheetdb.io/api/v1/gdn5wqo960cey';
                    const sheetUrlCamionesPendientes = buildSheetdbUrl('camiones pendientes');

                    let updated = false;

                    // Primero intentar por row_id
                    try {
                        const getRes = await fetch(sheetUrlCamionesPendientes);
                        if (getRes.ok) {
                            const rows = filterMeaningfulRows(await getRes.json());

                            // Intento estricto: Econ√≥mico + Nombre (parcial)
                            let matches = rows.filter(r => {
                                const ecoRaw = r['Econ√≥mico'] || r.Economico || r.economico || '';
                                const nombreRaw = r['Nombre'] || r.nombre || r.NOMBRE || '';
                                return normalizeKey(ecoRaw) === normalizeKey(originalEcon) &&
                                    (normalizeKey(nombreRaw) === normalizeKey(originalNombre) || String(nombreRaw).includes(originalNombre));
                            });

                            // Si no hay matches estrictos, intentar por Econ√≥mico solamente y loggear ejemplos
                            if (!matches || matches.length === 0) {
                                console.warn('‚ö†Ô∏è No se encontraron coincidencias estrictas por Econ√≥mico+Nombre. Intentando candidatos por Econ√≥mico para', originalEcon, originalNombre);
                                const candidatesByEco = rows.filter(r => {
                                    const ecoRaw = r['Econ√≥mico'] || r.Economico || r.economico || '';
                                    return normalizeKey(ecoRaw) === normalizeKey(originalEcon);
                                });

                                if (candidatesByEco.length > 0) {
                                    console.log('‚ÑπÔ∏è Ejemplos de candidatos por Econ√≥mico:', candidatesByEco.slice(0,5).map(r => ({ row_id: r.row_id || r.id || r._id || null, Econ: r['Econ√≥mico'] || r['Economico'] || r.economico, Nombre: r['Nombre'] || r.nombre || r.NOMBRE })));
                                    // Preferir los candidatos cuyo nombre contenga el originalNombre (parcial)
                                    const preferidos = candidatesByEco.filter(r => {
                                        const nombreRaw = r['Nombre'] || r.nombre || r.NOMBRE || '';
                                        return normalizeKey(nombreRaw).includes(normalizeKey(originalNombre));
                                    });
                                    matches = preferidos.length > 0 ? preferidos : candidatesByEco;
                                } else {
                                    console.log('‚ÑπÔ∏è No se encontraron candidatos por Econ√≥mico. Ejemplos de primeras filas:', rows.slice(0,5).map(r => ({ Econ: r['Econ√≥mico'] || r.Economico || r.economico, Nombre: r['Nombre'] || r.nombre || r.NOMBRE })));
                                }
                            }

                            // Intentar parchear por row_id para cada match (si existen)
                            if (matches && matches.length > 0) {
                                for (const row of matches) {
                                    const rid = row.row_id || row.id || row.ID || row._id;
                                    if (rid) {
                                        try {
                                            const patchRes = await fetch(buildSheetdbRowIdUrl(rid, 'camiones pendientes'), {
                                                method: 'PATCH',
                                                headers: { 'Content-Type': 'application/json' },
                                                body: JSON.stringify({ data: dataToPatch })
                                            });
                                            if (patchRes.ok) {
                                                updated = true;
                                                console.log('‚úÖ Actualizado por row_id:', rid);
                                                break;
                                            } else {
                                                console.warn('‚ö†Ô∏è PATCH por row_id respondi√≥ status', patchRes.status, 'para row_id', rid);
                                            }
                                        } catch (e) {
                                            console.warn('PATCH by row_id failed:', e);
                                        }
                                    }
                                }
                            }

                        }
                    } catch (e) {
                        console.warn('Error intentando PATCH por row_id:', e);
                    }

                    // Si no se pudo actualizar por row_id, intentar por filtro Econ√≥mico
                    if (!updated) {
                        try {
                            const patchByEconUrl = `https://sheetdb.io/api/v1/gdn5wqo960cey/Econ√≥mico/${encodeURIComponent(originalEcon)}?sheet=${encodeURIComponent('camiones pendientes')}`;
                            const patchByEcon = await fetch(patchByEconUrl, {
                                method: 'PATCH',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ data: dataToPatch })
                            });
                            if (patchByEcon.ok) {
                                updated = true;
                                console.log('‚úÖ Actualizado por Econ√≥mico:', originalEcon);
                            } else {
                                console.warn('‚ö†Ô∏è PATCH by Econ√≥mico respondi√≥ status', patchByEcon.status, 'para', originalEcon);
                            }
                        } catch (e) {
                            console.warn('PATCH by Econ√≥mico filter failed:', e);
                        }
                    }

                    if (!updated) {
                        console.warn(`No se pudo actualizar fila para ${originalNombre} (${originalEcon})`);
                    }
                }));
            } catch (e) {
                console.warn('Error durante sincronizaci√≥n con SheetDB:', e);
            }

            // Actualizar propiedades dentro de los pedidos migrados (local)
            sourceArr.forEach(p => {
                p.Econ√≥mico = target;
                const found = (flota || []).find(f => String(f.economico) === String(target));
                if (found) p.Unidad = found.unidad || p.Unidad || '';
            });

            // Mover los elementos localmente
            pendingAsignaciones[target].push(...sourceArr);
            delete pendingAsignaciones[econ];

            // Actualizar UI y estado
            renderPendingAsignaciones();
            Swal.fire('Asignado', `Reservas movidas a la unidad ${target}.`, 'success');

            // Sincronizar input y pedidoCamion
            const inputEco = document.getElementById('inputPedidoNumEconomico'); if (inputEco) { inputEco.value = target; inputEco.disabled = false; }
            const foundCam = (flota || []).find(f => String(f.economico) === String(target));
            if (foundCam) { pedidoCamion = foundCam; pedidoCamion.economico = target; } else if (pedidoCamion) { pedidoCamion.economico = target; }
            try { actualizarGraficas(); } catch (e) { console.warn(e); }
        });

        btnFinalizar.addEventListener('click', async () => {
            // Confirmaci√≥n clara con detalles
            const result = await Swal.fire({
                icon: 'info',
                title: 'Finalizar y apartar',
                html: `<p>Se apartar√°n <strong>${(pendingAsignaciones[econ] || []).length}</strong> pedidos pendientes del cami√≥n <strong>${econ}</strong>.</p>
                       <p style="font-size: 13px; color: #1976d2;">Los pedidos se trasladar√°n a la hoja de "Apartados".</p>`,
                showCancelButton: true,
                confirmButtonColor: '#4caf50',
                confirmButtonText: 'S√≠, finalizar',
                cancelButtonText: 'Cancelar'
            });

            if (!result.isConfirmed) return;

            // Mostrar indicador de carga
            Swal.fire({
                title: 'Finalizando y apartando...',
                text: 'Por favor espere mientras se procesan los pedidos',
                allowOutsideClick: false,
                didOpen: () => Swal.showLoading()
            });

            try {
                const pedidosAEnviar = pendingAsignaciones[econ] || [];
                
                if (pedidosAEnviar.length === 0) {
                    throw new Error('No hay pedidos pendientes para apartar');
                }

                console.log(`üì§ Enviando ${pedidosAEnviar.length} pedidos a Apartados...`);
                
                // 1. Guardar en Apartados
                const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=Apartados', {
                    method: 'POST',
                    headers: {'Content-Type':'application/json'},
                    body: JSON.stringify({ data: pedidosAEnviar })
                });
                if (!res.ok) throw new Error(`Error al guardar en Apartados (${res.status})`);
                console.log('‚úÖ Pedidos guardados en Apartados');

                // 2. Eliminar de Camiones pendientes
                let eliminadosExitosamente = 0;
                let erroresEliminacion = [];
                
                for (const pedido of pedidosAEnviar) {
                    console.log(`üóëÔ∏è Eliminando de pendientes: ${pedido.Econ√≥mico} / ${pedido.Nombre}`);
                    const ok = await eliminarReservaDeSheetDB(pedido.Econ√≥mico, pedido.Nombre);
                    if (ok) {
                        eliminadosExitosamente++;
                        console.log(`‚úÖ Eliminado de pendientes: ${pedido.Econ√≥mico} / ${pedido.Nombre}`);
                    } else {
                        erroresEliminacion.push(`${pedido.Econ√≥mico} - ${pedido.Nombre}`);
                        console.warn(`‚ùå Error eliminando de pendientes: ${pedido.Econ√≥mico} / ${pedido.Nombre}`);
                    }
                }

                // 3. Limpiar estado local
                delete pendingAsignaciones[econ];
                if (activePendingEconomico === econ) {
                    activePendingEconomico = null;
                    const inputEco = document.getElementById('inputPedidoNumEconomico');
                    if (inputEco) inputEco.disabled = false;
                }

                // 4. Recargar datos desde SheetDB
                console.log('üì• Revalidando datos desde SheetDB...');
                await cargarReservasDePendientes();
                await fetchPedidosApartados();

                // 5. Actualizar UI
                renderPendingAsignaciones();
                renderPedidosApartados();
                actualizarGraficas();

                // 6. Mostrar resultado
                if (erroresEliminacion.length === 0) {
                    Swal.fire({
                        icon: 'success',
                        title: '‚úÖ Apartado correctamente',
                        html: `<p><strong>${pedidosAEnviar.length}</strong> pedidos del cami√≥n <strong>${econ}</strong> han sido apartados.</p>
                               <p style="font-size: 12px; color: #666;">Los datos se han sincronizado correctamente.</p>`,
                        confirmButtonText: 'Aceptar'
                    });
                } else {
                    Swal.fire({
                        icon: 'warning',
                        title: '‚ö†Ô∏è Apartado parcial',
                        html: `<p>Se apartaron correctamente <strong>${pedidosAEnviar.length}</strong> pedidos, pero hubo problemas al eliminarlos de pendientes:</p>
                               <ul style="text-align: left; margin: 10px 0; font-size: 12px;">
                                   ${erroresEliminacion.map(e => `<li>${e}</li>`).join('')}
                               </ul>
                               <p style="font-size: 12px; color: #ff6f00;">Por favor, intente eliminar manualmente o contacte al administrador.</p>`,
                        confirmButtonText: 'Aceptar'
                    });
                }

            } catch (err) {
                console.error('‚ùå Error en btnFinalizar:', err);
                Swal.fire({
                    icon: 'error',
                    title: 'Error al apartar',
                    html: `<p>Ocurri√≥ un error al finalizar y apartar los pedidos:</p>
                           <p style="font-family: monospace; font-size: 12px; color: #d32f2f; word-break: break-word;">${err.message || err}</p>
                           <p style="font-size: 12px;">Por favor, intente nuevamente.</p>`,
                    confirmButtonText: 'Aceptar'
                });
            }
        });

        btnEliminar.addEventListener('click', async () => {
            // Confirmaci√≥n clara con detalles
            const result = await Swal.fire({
                icon: 'warning',
                title: '¬øEliminar reservas?',
                html: `<p>Se eliminar√°n <strong>${(pendingAsignaciones[econ] || []).length}</strong> pedidos pendientes del cami√≥n <strong>${econ}</strong>.</p>
                       <p style="color: #d32f2f; font-weight: bold;">Esta acci√≥n no se puede deshacer.</p>`,
                showCancelButton: true,
                confirmButtonColor: '#d32f2f',
                confirmButtonText: 'S√≠, eliminar',
                cancelButtonText: 'Cancelar'
            });

            if (!result.isConfirmed) return;

            // Mostrar indicador de carga
            Swal.fire({
                title: 'Eliminando reservas...',
                text: 'Por favor espere mientras se eliminan los pedidos de SheetDB',
                allowOutsideClick: false,
                didOpen: () => Swal.showLoading()
            });

            try {
                const pedidosAEliminar = pendingAsignaciones[econ] || [];
                let eliminadosExitosamente = 0;
                let erroresEliminacion = [];

                // Eliminar cada pedido de SheetDB (Camiones pendientes)
                for (const pedido of pedidosAEliminar) {
                    console.log(`üóëÔ∏è Intentando eliminar: ${pedido.Econ√≥mico} / ${pedido.Nombre}`);
                    const ok = await eliminarReservaDeSheetDB(pedido.Econ√≥mico, pedido.Nombre);
                    if (ok) {
                        eliminadosExitosamente++;
                        console.log(`‚úÖ Eliminado: ${pedido.Econ√≥mico} / ${pedido.Nombre}`);
                    } else {
                        erroresEliminacion.push(`${pedido.Econ√≥mico} - ${pedido.Nombre}`);
                        console.warn(`‚ùå Error eliminando: ${pedido.Econ√≥mico} / ${pedido.Nombre}`);
                    }
                }

                // Limpiar estado local
                delete pendingAsignaciones[econ];
                try { syncPendingToBurbujas(); } catch(e){}
                if (activePendingEconomico === econ) {
                    activePendingEconomico = null;
                    const inputEco = document.getElementById('inputPedidoNumEconomico');
                    if (inputEco) inputEco.disabled = false;
                }

                // Recargar datos desde SheetDB para verificar
                console.log('üì• Revalidando datos desde SheetDB...');
                await cargarReservasDePendientes();

                // Actualizar UI
                renderPendingAsignaciones();
                actualizarGraficas();

                // Mostrar resultado
                if (erroresEliminacion.length === 0) {
                    Swal.fire({
                        icon: 'success',
                        title: '‚úÖ Reservas eliminadas',
                        html: `<p>Se eliminaron correctamente <strong>${eliminadosExitosamente}</strong> pedidos del cami√≥n <strong>${econ}</strong>.</p>
                               <p style="font-size: 12px; color: #666;">Los datos se han sincronizado con SheetDB.</p>`,
                        confirmButtonText: 'Aceptar'
                    });
                } else {
                    Swal.fire({
                        icon: 'warning',
                        title: '‚ö†Ô∏è Eliminaci√≥n parcial',
                        html: `<p>Se eliminaron <strong>${eliminadosExitosamente}</strong> de <strong>${pedidosAEliminar.length}</strong> pedidos.</p>
                               <p style="color: #d32f2f; font-weight: bold;">No se pudieron eliminar:</p>
                               <ul style="text-align: left; margin: 10px 0;">
                                   ${erroresEliminacion.map(e => `<li>${e}</li>`).join('')}
                               </ul>
                               <p style="font-size: 12px; color: #666;">Por favor, intente nuevamente o contacte al administrador.</p>`,
                        confirmButtonText: 'Aceptar'
                    });
                }

            } catch (err) {
                console.error('‚ùå Error en btnEliminar:', err);
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    html: `<p>Ocurri√≥ un error al eliminar las reservas:</p>
                           <p style="font-family: monospace; font-size: 12px; color: #d32f2f;">${err.message || err}</p>
                           <p>Por favor, intente nuevamente.</p>`,
                    confirmButtonText: 'Aceptar'
                });
            }
        });

        btnSeguir.addEventListener('click', () => {
            if (activePendingEconomico === econ) {
                activePendingEconomico = null; const inputEco = document.getElementById('inputPedidoNumEconomico'); if (inputEco) inputEco.disabled = false; Swal.fire('Detenido', `Se dej√≥ de agregar autom√°ticamente al cami√≥n ${econ}`, 'info');
            } else {
                activePendingEconomico = econ; const inputEco = document.getElementById('inputPedidoNumEconomico'); if (inputEco) { inputEco.value = econ; inputEco.disabled = true; } Swal.fire('Activo', `Ahora se agregar√°n pedidos autom√°ticamente al cami√≥n ${econ}`, 'success');
            }
            renderPendingAsignaciones();
        });

        // dibujar gr√°fico
        try {
            const ctx = canvas.getContext('2d');
            const totalVol = pedidos.reduce((s,p)=>s+safeNum(p.Volumen),0);
            const totalP = pedidos.reduce((s,p)=>s+safeNum(p.Peso),0);
            const capVol = safeNum(pedidoCamion && (pedidoCamion['volumen'] || pedidoCamion.capacidadVolumen || pedidoCamion['Cap. Volumen'])) || 45;
            const capP = safeNum(pedidoCamion && (pedidoCamion['capacidad de carga (kg)'] || pedidoCamion['capacidad'] || pedidoCamion.capacidadPeso)) || 15000;
            if (window.Chart) {
                new Chart(ctx, { type: 'bar', data: { labels: ['Volumen (m¬≥)','Peso (kg)'], datasets:[{ label:'Uso', data:[Math.min(100,(totalVol/capVol)*100), Math.min(100,(totalP/capP)*100)], backgroundColor:['#4e73df','#1cc88a'] }] }, options:{ responsive:false, maintainAspectRatio:false, scales:{ y:{ beginAtZero:true, max:100 } }, plugins:{ legend:{ display:false } } } });
            } else { ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#333'; ctx.font='12px Arial'; ctx.fillText(`Vol: ${totalVol.toFixed(2)}/${capVol}`,8,24); ctx.fillText(`Peso: ${totalP.toFixed(0)}/${capP}`,8,44); }
        } catch(e){ console.warn('No se pudo dibujar gr√°fico peque√±o:', e); }
    }

    // inicial render
    renderDetalle(select.value);
    select.addEventListener('change', async () => {
        const nuevoEcon = select.value;
        await renderDetalle(nuevoEcon);
        // Al cambiar la selecci√≥n de cami√≥n pendiente, actualizar solo el n√∫mero econ√≥mico
        try {
            // Marcar este cami√≥n como "activo" para que las gr√°ficas sepan de qui√©n mostrar datos
            activePendingEconomico = nuevoEcon;
            
            const inputEco = document.getElementById('inputPedidoNumEconomico');
            if (inputEco) {
                inputEco.value = nuevoEcon;
                inputEco.disabled = false; // permitir edici√≥n si el usuario quiere
            }
            // actualizar logs visibles
            try { const logsBox = document.getElementById('pendingSyncLogs'); if (logsBox) { const arr = pendingAsignaciones[nuevoEcon] || []; logsBox.innerHTML = arr.map(p => `<div style="margin-bottom:4px">${escapeHtml(p.Nombre||p.nombre||'')}: ${p._saved === true ? 'OK' : (p._saved === false ? 'Pendiente' : 'Sincr.')}${p._lastResponse?(' ‚Äî '+escapeHtml(String(p._lastResponse).slice(0,200))):''}</div>`).join(''); } } catch(e){}
        } catch (e) {
            console.warn('Error al setear pedidoCamion desde selecci√≥n pendiente:', e);
        }
        // Actualizar gr√°ficas principales para reflejar la selecci√≥n (ahora mostrar√° datos del cami√≥n seleccionado)
        try { actualizarGraficas(); } catch (e) { console.warn(e); }
    });
}      

// Funci√≥n auxiliar para guardar el pedido actual como "Agregar otro" sin pasar por el modal de confirmaci√≥n
async function guardarYAgregarOtro() {
    if (!pedidoCamion) {
        Swal.fire('Error', 'Debe seleccionar un cami√≥n v√°lido antes de guardar.', 'error');
        return;
    }
    if (pedidosEnCurso.length === 0) {
        Swal.fire('Error', 'El pedido est√° vac√≠o.', 'error');
        return;
    }

    try {
        const { value: nombre } = await Swal.fire({
            title: 'Nombre del cliente',
            input: 'text',
            inputPlaceholder: 'Nombre completo',
            showCancelButton: true,
            confirmButtonText: 'Guardar y seguir',
            cancelButtonText: 'Cancelar',
            inputValidator: (v) => v ? null : 'Debe ingresar un nombre'
        });

        if (!nombre) return;

        // Preparar objeto de pedido similar a aceptarPedido
        let totalVolumen = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.volumen), 0);
        let totalPeso = pedidosEnCurso.reduce((acc, cur) => acc + safeNum(cur.peso), 0);
        let totalCantidad = pedidosEnCurso.reduce((acc, cur) => acc + cur.cantidad, 0);
        const descripcionLlantas = pedidosEnCurso.map(p => `‚Ä¢ ${p.cantidad} x ${p.descripcion}`).join('\n');

        let numEconomico = (pedidoCamion && pedidoCamion.economico) ? String(pedidoCamion.economico) : document.getElementById('inputPedidoNumEconomico').value.trim();
        if (!numEconomico) {
            Swal.fire('Error', 'No se encontr√≥ el n√∫mero econ√≥mico del cami√≥n.', 'error');
            return;
        }

        const pedidoObj = {
            "Fecha": new Date().toLocaleDateString(),
            "Unidad": pedidoCamion.unidad || "",
            "Econ√≥mico": numEconomico,
            "Nombre": nombre,
            "Llantas": String(totalCantidad),
            "Descripcion": descripcionLlantas,
            "Volumen": String(totalVolumen.toFixed(2)),
            "Peso": String(totalPeso.toFixed(2))
        };

        pendingAsignaciones[numEconomico] = pendingAsignaciones[numEconomico] || [];
        if (pendingAsignaciones[numEconomico].length >= 4) {
            Swal.fire('L√≠mite alcanzado', 'No puede agregar m√°s de 4 clientes a este cami√≥n.', 'warning');
            return;
        }

        const pedidoCopia = Object.assign({}, pedidoObj);
        pendingAsignaciones[numEconomico].push(pedidoCopia);
        // Guardar en SheetDB
        await guardarReservaEnSheetDB(pedidoCopia);
        pedidoCamion.apartadoPendiente = true;

        // Limpiar el pedido actual para permitir que el usuario agregue llantas del siguiente cliente
        pedidosEnCurso = [];
        renderPedidosActuales();
        actualizarGraficas();
        renderPendingAsignaciones();

        Swal.fire('Guardado', 'Pedido guardado. Ahora puede agregar llantas para otro cliente en este cami√≥n.', 'success');
    } catch (e) {
        console.error('guardarYAgregarOtro error', e);
        Swal.fire('Error', 'No se pudo guardar el pedido: ' + (e.message || e), 'error');
    }
}

    // -- Renderizar pedidos Apartados --
function renderPedidosApartados() {
    const tbody = document.querySelector('#tabla tbody');
    tbody.innerHTML = '';
    pedidosApartados.forEach((pedido, idx) => {
        const tr = document.createElement('tr');
        
        // Separar las descripciones y cantidades
        const descripciones = pedido.Descripcion ? pedido.Descripcion.split(' || ') : [];
        const cantidades = pedido.Cantidad ? pedido.Cantidad.split(' || ') : [];
        
        // Crear una lista formateada de descripciones y cantidades
        const detallesLlantas = descripciones.map((desc, i) => {
            const cantidad = cantidades[i] || '0';
            return `<li>${desc}: ${cantidad} unidades</li>`;
        }).join('');

        tr.innerHTML = `
            <td>${pedido.Unidad || pedido.camion || ''}</td>
            <td>${pedido.Llantas || ''}</td>
            <td>
                <ul style="padding-left:18px;margin:0;list-style-type:none;">
                    ${detallesLlantas}
                </ul>   
            </td>
            <td>      
                <ul style="padding-left:18px;margin:0;">
                    ${cantidades.map(q => `<li style="text-align:left;">${q.trim()} unidades</li>`).join('')}
                </ul>      
            </td>
            <td>${pedido.Llantas || pedido["total,cantidad"] || ''}</td>
            <td>${pedido.linea || ''}</td>
            <td>${Number(pedido.Volumen || pedido.volumen).toLocaleString('es-MX', { minimumFractionDigits: 3, maximumFractionDigits: 3 })}</td>
            <td>${Number(pedido.peso).toLocaleString('es-MX', { minimumFractionDigits: 3, maximumFractionDigits: 3 })}</td>
            <td>$${Number(pedido.valor).toLocaleString('es-MX', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
            <td>${pedido.fecha || ''}</td>
            <td style="min-width: 300px;">
               <button onclick="editarPedidoConfirmado(${idx})" class="btn btn-sm btn-primary">Editar</button>
                <button onclick="cancelarPedido(${idx})" class="btn btn-sm btn-danger">Quitar</button>
            </td>`;
        tbody.appendChild(tr);
    }); 
}
    function cancelarPedido(idx) {
        if (confirm('¬øSeguro que desea cancelar este pedido?')) {
            const pedidoACancelar = pedidosApartados[idx];
            // Opcional: Podr√≠as agregar l√≥gica para eliminar en SheetDB tambi√©n
            pedidosApartados.splice(idx, 1);
            renderPedidosApartados();
        }
    }
    // Modificar la funci√≥n reservarPedido()
    async function reservarPedido(idx) {
    const pedido = pedidosApartados[idx];
    if (!pedido) return;

    try {
        // Pedir el nombre del bloque al usuario usando SweetAlert2
        const nombreBloqueResult = await Swal.fire({
            title: 'Nombre del bloque',
            input: 'text',
            inputLabel: 'Por favor, ingrese el nombre para el bloque de reserva',
            inputPlaceholder: 'Nombre del bloque',
            showCancelButton: true,
            confirmButtonText: 'Continuar',
            cancelButtonText: 'Cancelar',
            inputValidator: (value) => {
                if (!value) {
                    return 'Debe ingresar un nombre para el bloque';
                }
            }
        });

        if (!nombreBloqueResult.isConfirmed || !nombreBloqueResult.value) {
            return;
        }
        
        const nombreBloque = nombreBloqueResult.value;

        // Confirmar la operaci√≥n
        const result = await Swal.fire({
            icon: 'question',
            title: '¬øReservar bloque?',
            html: `
                <p>Cliente: <strong>${nombreBloque}</strong></p>
                <p>¬øEst√° seguro que desea reservar este bloque de llantas?</p>
            `,
            showCancelButton: true,
            confirmButtonText: 'S√≠, reservar',
            cancelButtonText: 'Cancelar'
        });

        if (!result.isConfirmed) {
            return;
        }
        
        // Usar el nombre del bloque + _1 como identificador
        const nombreReserva = `${nombreBloque}_1`;
        
        const llantas = pedido.llantas.split(',').map(l => l.trim());
        const descripciones = pedido.descripcion.split(',').map(d => d.trim());
        const cantidades = pedido.cantidad.split(',').map(c => c.trim());
        const lineas = pedido.linea.split(',').map(l => l.trim());

        const registrosReserva = llantas.map((llanta, i) => ({
            nombre: nombreReserva, // Usar el nuevo nombre
            C√≥digo: llanta,
            Descripci√≥n: descripciones[i] || '',
            L√≠nea: lineas[i] || '',
            Cantidad: cantidades[i] || '0',
            'Volumen Total': (Number(pedido.volumen) / llantas.length).toFixed(3),
            'Peso Total': (Number(pedido.peso) / llantas.length).toFixed(3),
            'Valor Total ($)': (Number(pedido.valor) / llantas.length).toFixed(2)
        }));

        const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=reservados', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ data: registrosReserva })
        });

        if (!res.ok) throw new Error('Error al guardar reserva');

        await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey/camion/${pedido.camion}?sheet=Apartados`, {
            method: 'DELETE'
        });

        pedidosApartados.splice(idx, 1);
        renderPedidosApartados();
        alert('Pedido reservado exitosamente como: ' + nombreReserva);

    } catch (error) {
        console.error('Error al reservar:', error);
        alert('Error al reservar el pedido: ' + error.message);
    }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.4/dist/tesseract.min.js"></script>
<script>
// ...existing code...

// Variables globales para el sistema de traspasos
const facturaPdfInput = document.getElementById('facturaPdfInput');
const traspasoscanBtn = document.getElementById('traspasoscanBtn');
const facturaResultDiv = document.getElementById('facturaResult');
const facturaLoadingDiv = document.getElementById('facturaLoading');
const facturaClearBtn = document.getElementById('facturaClearBtn');
const facturaProgressBar = document.getElementById('facturaProgressBar');

// Variables globales para el manejo de datos
let bloquestraspasos = [];
let bloquesFACTURAS = []; // almacenar bloques cargados desde la hoja 'FACTURAS'
let archivosEscaneados = []; 
let traspasosParaGuardar = [];
const bloquesPedidosAgregados = new Set();
let llantasAcumuladasEnBloque = []; // Variable para acumular llantas en el modo de b√∫squeda

// Variables nuevas para el sistema de bloques
let extractedData = [];
let escaneosActuales = []; // Para almacenar temporalmente los escaneos antes de formar el bloque


// Normalizar contenedores de FACTURAS/traspasos: moverlos a su pane correspondiente o eliminarlos si est√°n en body
function normalizeFacturaContainers() {
    try {
        const cont = document.getElementById('facturaGroupsContainer');
        const expectedParent = document.getElementById('traspasosNormales') || document.querySelector('.tab-pane#traspasosNormales') || document.getElementById('traspasos');
        if (cont) {
            if (expectedParent) {
                if (cont.parentElement !== expectedParent) {
                    expectedParent.appendChild(cont);
                    console.log('normalize: moved `facturaGroupsContainer` into', expectedParent.id || expectedParent.className);
                }
            } else {
                if (cont.parentElement === document.body) {
                    cont.remove();
                    console.warn('normalize: removed `facturaGroupsContainer` from body because target parent not found');
                }
            }
        }

        const contF = document.getElementById('facturaGroupsContainer_FACTURAS');
        const expectedParentF = document.getElementById('traspasosEspeciales') || document.querySelector('.tab-pane#traspasosEspeciales') || document.getElementById('FACTURAS') || document.querySelector('.tab-pane#FACTURAS');
        if (contF) {
            if (expectedParentF) {
                if (contF.parentElement !== expectedParentF) {
                    expectedParentF.appendChild(contF);
                    console.log('normalize: moved `facturaGroupsContainer_FACTURAS` into', expectedParentF.id || expectedParentF.className);
                }
            } else {
                if (contF.parentElement === document.body) {
                    contF.remove();
                    console.warn('normalize: removed `facturaGroupsContainer_FACTURAS` from body because target parent not found');
                }
            }
        }
    } catch (e) {
        console.warn('normalizeFacturaContainers error:', e);
    }
}


// Event listener para el bot√≥n de limpiar cach√©
document.getElementById('traspasosEspecialesCacheClearBtn').onclick = () => {
    if (!confirm('¬øEst√°s seguro de que deseas eliminar todos los datos en cach√© y el estado local de la pesta√±a de FACTURAS?')) return;

    // Remover claves de localStorage relevantes para FACTURAS/escaneos
    try {
        const keys = Object.keys(localStorage);
        const toRemove = keys.filter(k => k.startsWith('factura_especial_') || k.startsWith('pdf_') || k.startsWith('cache_'));
        toRemove.forEach(k => { localStorage.removeItem(k); console.log('Removed localStorage key:', k); });
    } catch (e) { console.warn('Error al limpiar localStorage en traspasosEspeciales:', e); }

    // Limpiar estado en memoria relacionado
    try { archivosEscaneados = []; } catch (e) { console.warn(e); }
    try { bloquesFACTURAS = []; } catch (e) { console.warn(e); }
    try { traspasosParaGuardar = []; } catch (e) { console.warn(e); }

    // Limpiar interfaz de la pesta√±a
    try { const ex = document.getElementById('extractedData'); if (ex) ex.innerHTML = ''; } catch(e){}
    try { const lg = document.getElementById('log'); if (lg) { lg.style.display = 'none'; lg.innerHTML = ''; } } catch(e){}
    try { const fi = document.getElementById('fileInput'); if (fi) fi.value = ''; } catch(e){}
    try { const esc = document.getElementById('escaneosGuardados'); if (esc) esc.innerHTML = ''; } catch(e){}
    try { const fg = document.getElementById('facturaGroupsContainer_FACTURAS'); if (fg) fg.innerHTML = ''; } catch(e){}

    // Re-renderizar vistas si existen funciones
    try { if (typeof mostrarArchivosEscaneados === 'function') mostrarArchivosEscaneados(); } catch(e){console.warn(e);}
    try { if (typeof mostrarBloquesFACTURAS === 'function') mostrarBloquesFACTURAS(); } catch(e){console.warn(e);}
    try { if (typeof actualizarBloquesFACTURAS === 'function') actualizarBloquesFACTURAS(); } catch(e){console.warn(e);}

    alert('Cach√© y estado de la pesta√±a FACTURAS limpiados correctamente');
};

// Agregar con los otros event listeners
document.getElementById('facturaCacheClearBtn').onclick = () => {
    if (confirm('¬øEst√°s seguro de que deseas eliminar todos los datos en cach√©?')) {
        const cacheKeys = Object.keys(localStorage).filter(key => key.startsWith('pdf_'));
        cacheKeys.forEach(key => localStorage.removeItem(key));
        alert('Cach√© limpiado exitosamente');
    }
};

// Agregar estas funciones para manejo de cach√©
function getCacheKey(file) {
    return `pdf_${file.name}_${file.lastModified}_${file.size}`;
}

function getCache(key) {
    try {
        const cached = localStorage.getItem(key);
        if (!cached) return null;
        
        const data = JSON.parse(cached);
        // Verificar si el cach√© tiene m√°s de 24 horas
        if (Date.now() - data.timestamp > 24 * 60 * 60 * 1000) {
            localStorage.removeItem(key);
            return null;
        }
        return data.content;
    } catch (e) {
        console.error('Error al leer cach√©:', e);
        return null;
    }
}

function setCache(key, data) {
    try {
        const cacheData = {
            timestamp: Date.now(),
            content: data
        };
        localStorage.setItem(key, JSON.stringify(cacheData));
    } catch (e) {
        console.error('Error al guardar cach√©:', e);
    }
}

// Modificar el onclick del bot√≥n de escaneo
traspasoscanBtn.onclick = async () => {
    const files = Array.from(facturaPdfInput.files);
    if (files.length === 0) {
        alert('Por favor, selecciona al menos un archivo PDF.');
        return;
    }

    // Agregar opciones de cach√©
    const usarCache = confirm('¬øDeseas usar datos en cach√© si est√°n disponibles? (Selecciona "No" para forzar un nuevo escaneo)');

    facturaLoadingDiv.style.display = 'block';
    facturaProgressBar.style.display = 'block';

    try {
        const BATCH_SIZE = 2;
        for (let i = 0; i < files.length; i += BATCH_SIZE) {
            const batch = files.slice(i, i + BATCH_SIZE);
            await Promise.all(batch.map(async file => {
                const cacheKey = getCacheKey(file);
                
                // Verificar cach√© solo si el usuario lo permite
                if (usarCache) {
                    const cachedData = getCache(cacheKey);
                    if (cachedData) {
                        console.log(`Usando cach√© para ${file.name}`);
                        archivosEscaneados.push(cachedData);
                        mostrarArchivosEscaneados();
                        return;
                    }
                }

                // Si no hay cach√© o no se quiere usar, procesar el archivo
                console.log(`Escaneando ${file.name}`);
                
                // ... resto del c√≥digo de procesamiento ...
                
                // Al final del procesamiento exitoso:
                const resultado = { nombreArchivo: file.name, productos };
                setCache(cacheKey, resultado);
                archivosEscaneados.push(resultado);
                mostrarArchivosEscaneados();
            }));
        }

        // ... resto del c√≥digo ...

    } catch (e) {
        console.error('Error en procesamiento:', e);
        alert('Ocurri√≥ un error durante el escaneo: ' + e.message);
    } finally {
        facturaLoadingDiv.style.display = 'none';
        facturaProgressBar.style.display = 'none';
    }
};

// Agregar bot√≥n para limpiar cach√©
function agregarBotonLimpiarCache() {
    const botonLimpiarCache = document.createElement('button');
    botonLimpiarCache.className = 'btn btn-warning';
    botonLimpiarCache.innerHTML = '<i class="bi bi-trash"></i> Limpiar Cach√©';
    botonLimpiarCache.onclick = () => {
        if (confirm('¬øEst√°s seguro de que deseas eliminar todos los datos en cach√©?')) {
            const cacheKeys = Object.keys(localStorage).filter(key => key.startsWith('pdf_'));
            cacheKeys.forEach(key => localStorage.removeItem(key));
            alert('Cach√© limpiado exitosamente');
        }
    };
    
    // Insertar el bot√≥n junto a los otros controles
    const controlsContainer = document.querySelector('#traspasoscanBtn').parentElement;
    controlsContainer.appendChild(botonLimpiarCache);
}

// Llamar a esta funci√≥n cuando se carga la p√°gina
document.addEventListener('DOMContentLoaded', () => {
    agregarBotonLimpiarCache();
    // Normalizar contenedores que pudieran haberse creado fuera de sus pesta√±as
    try {
        if (typeof normalizeFacturaContainers === 'function') normalizeFacturaContainers();
    } catch (e) { console.warn('normalizeFacturaContainers error:', e); }
    // Cargar los bloques de traspasos al iniciar la p√°gina
    actualizarBloquestraspasos().then(success => {
        if (!success) {
            console.error('No se pudieron cargar los bloques de traspasos inicialmente');
        }
    });
    // Cargar los bloques de FACTURAS al iniciar la p√°gina (se renderiza en su pesta√±a)
    if (typeof actualizarBloquesFACTURAS === 'function') {
        actualizarBloquesFACTURAS().then(success => {
            if (!success) console.error('No se pudieron cargar los bloques de FACTURAS inicialmente');
        });
    }
});
// Asegurarse de recargar FACTURAS cuando el usuario abre la pesta√±a FACTURAS
const btnFACTURASTab = document.getElementById('traspasos-especiales-tab');
if (btnFACTURASTab) {
    btnFACTURASTab.addEventListener('click', () => {
        // Esperar brevemente a que Bootstrap muestre el pane
        setTimeout(() => {
            if (typeof actualizarBloquesFACTURAS === 'function') actualizarBloquesFACTURAS();
        }, 150);
    });
}

// Escuchar el evento 'shown.bs.tab' para recargar la vista de FACTURAS cuando el pane quede activo (Bootstrap)
document.querySelectorAll('button[data-bs-toggle="tab"]').forEach(btn => {
    btn.addEventListener('shown.bs.tab', (e) => {
        try {
            // Normalizar contenedores cuando cambian las pesta√±as
            try { if (typeof normalizeFacturaContainers === 'function') normalizeFacturaContainers(); } catch(e){ console.warn('normalizeFacturaContainers error on tab change', e); }
            const target = btn.getAttribute('data-bs-target') || btn.getAttribute('data-target') || '';
            if (target && (target.includes('traspasosEspeciales') || target.includes('FACTURAS'))) {
                console.log('Pesta√±a FACTURAS activada por shown.bs.tab ‚Äî actualizando FACTURAS');
                if (typeof mostrarBloquesFACTURAS === 'function') mostrarBloquesFACTURAS();
                // tambi√©n asegurar la recarga desde el origen si hace falta
                if (typeof actualizarBloquesFACTURAS === 'function') actualizarBloquesFACTURAS();
            }
        } catch (err) { console.warn('Error manejando shown.bs.tab:', err); }
    });
});
// Agregar antes de traspasoscanBtn.onclick (aproximadamente l√≠nea 1850)
async function compressImage(canvas) {
    return new Promise((resolve) => {
        canvas.toBlob((blob) => {
            resolve(blob);
        }, 'image/jpeg', 0.7);
    });
}
// Bot√≥n Limpiar
// ...existing code...
facturaClearBtn.onclick = () => {
    facturaPdfInput.value = '';
    facturaResultDiv.textContent = '';
    archivosEscaneados = [];
    traspasosParaGuardar = [];
    mostrarArchivosEscaneados();
    facturaLoadingDiv.style.display = 'none'; // <-- agrega esto para ocultar el spinner
    facturaProgressBar.style.display = 'none';
    // NO borres bloquestraspasos aqu√≠
};
// ...existing code...

// Modificar la funci√≥n agregarNuevosProductosAlINVENTARIO
async function agregarNuevosProductosAlINVENTARIO(productos) {
    try {
        if (!Array.isArray(productos) || productos.length === 0) {
            console.log('No hay productos para procesar');
            return 0;
        }

        // Obtener INVENTARIO actual
        const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey');
        if (!res.ok) throw new Error(`Error HTTP: ${res.status}`);
        const INVENTARIOActual = filterMeaningfulRows(await res.json());

        // Crear Set de c√≥digos existentes (normalizar a may√∫sculas)
        const codigosINVENTARIO = new Set(
            INVENTARIOActual.map(item => item.clave?.toString().trim().toUpperCase())
                .filter(Boolean)
        );

        // Crear funci√≥n para normalizar descripciones y mapa de descripciones existentes
        const normalizeDesc = s => String(s || '').toUpperCase().replace(/\s+/g, ' ').replace(/[\(\)\[\]\,\.;:\-\/]/g, '').trim();
        const descripcionesINVENTARIO = new Map();
        INVENTARIOActual.forEach(item => {
            const d = normalizeDesc(item.descripcion || item.Descripci√≥n || item.Descrip || item.Descripcion || '');
            if (!d) return;
            if (!descripcionesINVENTARIO.has(d)) descripcionesINVENTARIO.set(d, []);
            descripcionesINVENTARIO.get(d).push(item.clave?.toString().trim().toUpperCase());
        });

        // Filtrar productos nuevos: eliminar duplicados por clave y omitir coincidencias por descripci√≥n
        const nuevosMap = {};
        const omitidosPorDescripcion = [];
        for (const p of productos) {
            const codigoRaw = p.C√≥digo?.toString().trim();
            const descRaw = (p.Descripci√≥n || p.Descripcion || '').toString().trim();
            if (!codigoRaw && !descRaw) continue;
            const codigo = codigoRaw ? codigoRaw.toUpperCase() : null;
            const descNorm = normalizeDesc(descRaw);

            // Si la descripci√≥n ya existe en INVENTARIO, omitimos (posible duplicado aunque clave difiera)
            if (descNorm && descripcionesINVENTARIO.has(descNorm)) {
                omitidosPorDescripcion.push({ codigo: codigo || '(sin clave)', descripcion: descRaw, existeConClave: descripcionesINVENTARIO.get(descNorm) });
                continue;
            }

            // Si ya existe en INVENTARIO por clave o ya lo tenemos en el mapa, omitir
            if (codigo && (codigosINVENTARIO.has(codigo) || nuevosMap[codigo])) continue;
            if (codigo) nuevosMap[codigo] = p;
            else {
                // Sin clave pero sin coincidencia por descripcion; generar id temporal para evitar duplicados en map
                const tempKey = 'NOCLAVE_' + Math.random().toString(36).slice(2, 9);
                nuevosMap[tempKey] = p;
            }
        }
        const nuevos = Object.values(nuevosMap);

        console.log(`Se encontraron ${nuevos.length} productos nuevos`);

        // Array para productos que no se pudieron procesar
        const fallos = [];
        let procesados = 0;

        // Procesar en lotes de 50
        const BATCH_SIZE = 50;
        for (let i = 0; i < nuevos.length; i += BATCH_SIZE) {
            const lote = nuevos.slice(i, i + BATCH_SIZE);
            
            // Preparar productos con volumen calculado
            const productosValidos = [];
            
            for (const producto of lote) {
                try {
                    const desc = (producto.Descripci√≥n || producto.Descripcion || '').toString().trim();
                    if (!desc) continue;

                    // Calcular volumen y peso usando funciones centrales
                    let volumenCalc = 0;
                    let pesoCalc = 0;
                    try {
                        volumenCalc = await calcularVolumenLlanta(desc);
                    } catch (e) {
                        console.warn('Error calculando volumen para', desc, e);
                        volumenCalc = 0;
                    }
                    try {
                        pesoCalc = await calcularPesoLlanta(desc);
                    } catch (e) {
                        console.warn('Error calculando peso para', desc, e);
                        pesoCalc = 0;
                    }

                    const claveNorm = producto.C√≥digo?.toString().trim().toUpperCase();
                    const descNorm = normalizeDesc(desc);

                    // Segunda comprobaci√≥n por descripci√≥n para evitar duplicados que se colaron
                    if (descNorm && descripcionesINVENTARIO.has(descNorm)) {
                        omitidosPorDescripcion.push({ codigo: claveNorm || '(sin clave)', descripcion: desc, existeConClave: descripcionesINVENTARIO.get(descNorm) });
                    } else {
                        // Construir objeto y asegurar peso/volumen unitarios
                        let nuevoProd = {
                            clave: claveNorm,
                            descripcion: desc,
                            linea: determinarTipoLlanta(desc),
                            peso: Number(pesoCalc) || 0,
                            volumen: Number(volumenCalc) || 0,
                            valor: '' // Para llenado manual
                        };
                        try {
                            nuevoProd = await ensurePesoVolumen(nuevoProd);
                        } catch (e) {
                            console.warn('ensurePesoVolumen fall√≥ para', desc, e);
                        }
                        productosValidos.push({
                            clave: nuevoProd.clave,
                            descripcion: nuevoProd.descripcion,
                            linea: nuevoProd.linea,
                            peso: Number(nuevoProd.peso) || 0,
                            volumen: Number(nuevoProd.volumen) || 0,
                            valor: nuevoProd.valor || ''
                        });
                    }

                } catch (error) {
                    fallos.push({
                        codigo: producto.C√≥digo,
                        error: error.message
                    });
                }
            }

            // Antes de enviar, filtrar cualquier producto que ya exista (evitar race conditions)
            let productosParaEnviar = productosValidos.filter(p => !codigosINVENTARIO.has(p.clave));

            // Verificaci√≥n adicional en servidor: consultar SheetDB por cada clave
            // Esto garantiza que aunque otro proceso haya insertado la clave despu√©s
            // del primer GET, no la intentemos insertar de nuevo.
            if (productosParaEnviar.length > 0) {
                const existentesEnServidor = [];
                try {
                    await Promise.all(productosParaEnviar.map(async (p) => {
                        try {
                            const url = `https://sheetdb.io/api/v1/gdn5wqo960cey/clave/${encodeURIComponent(p.clave)}`;
                            const r = await fetch(url);
                            if (r.ok) {
                                const data = filterMeaningfulRows(await r.json());
                                // Si la API devuelve un array con elementos, la clave ya existe
                                if (Array.isArray(data) && data.length > 0) {
                                    existentesEnServidor.push(p.clave);
                                }
                            }
                        } catch (e) {
                            console.warn('No se pudo verificar existencia en servidor para', p.clave, e);
                            // En caso de error de red, conservamos p para intentar insertarlo (ser√° capturado por fallos si ya existe)
                        }
                    }));

                    // Remover del env√≠o las claves que ya existen en servidor
                    if (existentesEnServidor.length > 0) {
                        productosParaEnviar = productosParaEnviar.filter(p => !existentesEnServidor.includes(p.clave));
                        // A√±adir esas claves al set local para evitar reintentos
                        existentesEnServidor.forEach(c => codigosINVENTARIO.add(c));
                        console.log('Se omitieron del env√≠o (ya en servidor):', existentesEnServidor);
                    }
                } catch (e) {
                    console.warn('Error verificando claves en servidor:', e);
                }
            }

            if (productosParaEnviar.length > 0) {
                try {
                    const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ data: productosParaEnviar })
                    });

                    if (!res.ok) throw new Error(`Error HTTP: ${res.status}`);
                    procesados += productosParaEnviar.length;

                    // Actualizar INVENTARIO local y el set de c√≥digos (evitar duplicados locales)
                    for (const p of productosParaEnviar) {
                        if (!codigosINVENTARIO.has(p.clave)) {
                            INVENTARIO.push(p);
                            codigosINVENTARIO.add(p.clave);
                        }
                    }

                } catch (error) {
                    console.error('Error al agregar lote:', error);
                    fallos.push(...productosParaEnviar.map(p => ({
                        codigo: p.clave,
                        error: 'Error al guardar en base de datos'
                    })));
                }
            }
        }

        // Mostrar resumen
        const mensaje = `
            Proceso completado:
            - Total productos nuevos detectados: ${nuevos.length}
            - Productos agregados: ${procesados}
            - Productos fallidos: ${fallos.length}
            - Omitidos por coincidencia de descripci√≥n: ${omitidosPorDescripcion.length}
        `;
        
        console.log(mensaje);
        alert(mensaje);

        if (fallos.length > 0) {
            console.log('Productos fallidos:', fallos);
        }
        if (omitidosPorDescripcion.length > 0) {
            console.log('Productos omitidos por descripci√≥n existente (ejemplos):', omitidosPorDescripcion.slice(0,20));
        }

        return procesados;

    } catch (error) {
        console.error('Error general:', error);
        alert('Error al procesar productos: ' + error.message);
        return 0;
    }
}

// Funciones auxiliares
function determinarTipoLlanta(descripcion = '') {
    const desc = descripcion.toUpperCase();
    let tipoLlanta = 'AUTO';

    // Ensure the description logic prioritizes AGRICOLA classification
    if (desc.includes('AGRO') || /\bR1\b/.test(desc)) {
        tipoLlanta = 'AGRICOLA';
    } else if (desc.includes('INDUSTRIAL') || desc.includes('OTR') || /\bE[3-4]\/L[3-5]\b/.test(desc) || /\b\d{2,2}\.\d{2}-\d{2}\b/.test(desc)) {
        tipoLlanta = 'INDUSTRIAL';
    } else if (desc.includes('CAMION')) {
        tipoLlanta = 'CAMION';
    } else if (desc.includes('4X4')) {
        tipoLlanta = '4X4';
    } else {
        tipoLlanta = 'AUTO';
    }
    return tipoLlanta;
}

async function calcularVolumenProducto(producto) {
    // ... l√≥gica existente de c√°lculo de volumen ...
    // Se mantiene igual pero en funci√≥n separada para mejor organizaci√≥n
}
  
// ...dentro de traspasoscanBtn.onclick...
// Escanear y mostrar tabla + barra para nombre
// ...existing code...
traspasoscanBtn.onclick = async () => {
    const files = Array.from(facturaPdfInput.files);
    if (files.length === 0) {
        alert('Por favor, selecciona al menos un archivo PDF.');
        return;
    }

    facturaLoadingDiv.style.display = 'block';
    facturaProgressBar.style.display = 'block';

    try {
        // Procesar PDFs en lotes
        const BATCH_SIZE = 2;
        for (let i = 0; i < files.length; i += BATCH_SIZE) {
            const batch = files.slice(i, i + BATCH_SIZE);
            await Promise.all(batch.map(async file => {
                // Verificar cach√©
                const cacheKey = `pdf_${file.name}_${file.lastModified}`;
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const cachedData = JSON.parse(cached);
                    archivosEscaneados.push(cachedData);
                    mostrarArchivosEscaneados();
                    return;
                }

                const reader = new FileReader();
                await new Promise(resolve => {
                    reader.onload = async function() {
                        // Configuraci√≥n optimizada para el PDF
                        const pdfOptions = {
                            scale: 1.5,
                            maxImageSize: 2000
                        };

                        const typedarray = new Uint8Array(this.result);
                        const pdf = await pdfjsLib.getDocument(typedarray).promise;
                        let extractedText = '';

                        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                            const page = await pdf.getPage(pageNum);
                            const viewport = page.getViewport({ scale: pdfOptions.scale });
                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');
                            
                            // Limitar tama√±o m√°ximo
                            const ratio = Math.min(pdfOptions.maxImageSize / viewport.width, 
                                                 pdfOptions.maxImageSize / viewport.height);
                            canvas.width = viewport.width * ratio;
                            canvas.height = viewport.height * ratio;
                            
                            await page.render({ 
                                canvasContext: context, 
                                viewport: viewport,
                                transform: [ratio, 0, 0, ratio, 0, 0]
                            }).promise;

                            // Comprimir imagen antes del OCR
                            const compressedDataUrl = await compressImage(canvas);
                            
                            // OCR optimizado
                            const { data: { text } } = await Tesseract.recognize(
                                compressedDataUrl, 
                                'spa',
                                {
                                    logger: m => {
                                        facturaProgressBar.value = Math.round(m.progress * 100);
                                        facturaLoadingDiv.innerHTML = `
                                            <div class="spinner-border text-info"></div>
                                            <p>PDF ${i+1}/${files.length} - P√°gina ${pageNum}/${pdf.numPages}: ${Math.round(m.progress*100)}%</p>
                                        `;
                                    },
                                    tessedit_pageseg_mode: '1',
                                    tessedit_ocr_engine_mode: '2'
                                }
                            );
                            extractedText += text + '\n';
                        }

                        // Extraer datos con expresiones regulares optimizadas
                        const extraerDato = (regex) => (extractedText.match(regex) || [])[1] || '';
                        const datos = {
                            folio: extraerDato(/FOLIO\s*[:\-]?\s*([A-Za-z0-9\-]+)/i),
                            fecha: extraerDato(/FECHA DE EMISION\s*[:\-]?\s*([0-9\/\:\. ]+)/i),
                            usuario: extraerDato(/USUARIO\s*[:\-]?\s*([A-Za-z\s]+)/i)
                        };

                        // Procesar productos con regex mejorado
                        const textoLimpio = extractedText
                            .replace(/\r/g, '')
                            .replace(/[ ]{2,}/g, ' ')
                            .replace(/^\s*$/gm, '');

                        const productos = [];
                        const productoRegex = /^\s*(\d+)\s+([A-Za-z0-9\-]+)\s+(.+)$/gm;
                        let match;

                        while ((match = productoRegex.exec(textoLimpio)) !== null) {
                            if (!match[2] || !match[3] || 
                                match[2].toUpperCase() === 'C√ìDIGO' || 
                                match[3].toUpperCase() === 'DESCRIPCI√ìN') continue;

                            productos.push({
                                Folio: datos.folio,
                                "Fecha de Emisi√≥n": datos.fecha,
                                Usuario: datos.usuario,
                                Cantidad: match[1],
                                C√≥digo: match[2],
                                Descripci√≥n: match[3].trim()
                            });
                        }

                        const resultado = { nombreArchivo: file.name, productos };
                        
                        // Guardar en cach√©
                        localStorage.setItem(cacheKey, JSON.stringify(resultado));
                        
                        archivosEscaneados.push(resultado);
                        mostrarArchivosEscaneados();
                        resolve();
                    };
                    reader.readAsArrayBuffer(file);
                });
            }));
        }

        // Actualizar productos para guardar
        traspasosParaGuardar = archivosEscaneados.flatMap(a => a.productos);
        
        // Mostrar resumen
        mostrarResumenEscaneo();

    } catch (e) {
        console.error('Error en procesamiento:', e);
        alert('Ocurri√≥ un error durante el escaneo: ' + e.message);
    } finally {
        facturaLoadingDiv.style.display = 'none';
        facturaProgressBar.style.display = 'none';
    }
};
// Funci√≥n auxiliar para comprimir im√°genes
async function compressImage(canvas) {
    return new Promise((resolve) => {
        canvas.toBlob((blob) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        }, 'image/jpeg', 0.7);
    });
}

// Funci√≥n para mostrar resumen del escaneo
function mostrarResumenEscaneo() {
    let html = `
        <h5 class="mt-4 mb-2">Productos acumulados en el bloque:</h5>
        <table class="table table-bordered">
            <thead>
                <tr>
                    <th>Folio</th>
                    <th>Fecha de Emisi√≥n</th>
                    <th>Usuario</th>
                    <th>Cantidad</th>
                    <th>C√≥digo</th>
                    <th>Descripci√≥n</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    traspasosParaGuardar.forEach(p => {
        html += `
            <tr>
                <td>${p.Folio}</td>
                <td>${p["Fecha de Emisi√≥n"]}</td>
                <td>${p.Usuario}</td>
                <td>${p.Cantidad}</td>
                <td>${p.C√≥digo}</td>
                <td>${p.Descripci√≥n}</td>
            </tr>
        `;
    });
    
    html += '</tbody></table>';
    facturaResultDiv.innerHTML = html;
}
// ...existing code...
document.getElementById('btnTerminarBloqueFactura').onclick = async () => {
    const nombreBloque = document.getElementById('nombreBloqueFactura').value.trim() || 'Sin nombre';
    traspasosParaGuardar = archivosEscaneados.flatMap(a => a.productos);
    if (traspasosParaGuardar.length === 0) {
        alert('No hay productos para guardar.');
        return;
    }
    // Agrega el nombre del bloque a cada producto
    traspasosParaGuardar.forEach(p => p.Nombre = nombreBloque);

    // Normalizar campos y calcular volumen antes de guardar/agregar al INVENTARIO
    for (let i = 0; i < traspasosParaGuardar.length; i++) {
        const p = traspasosParaGuardar[i];
        const codigo = (p.C√≥digo || p.Codigo || p.codigo || p.codigoLlanta || '').toString().trim();
        const descripcion = (p.Descripci√≥n || p.Descripcion || p.descripcion || p.Descrip || '').toString().trim();
        const cantidad = Number(p.Cantidad || p.cantidad || p.cant || 0) || 0;

        // Reescribir campos con nombres esperados por otras funciones
        p.C√≥digo = codigo;
        p.Descripci√≥n = descripcion;
        p.Cantidad = cantidad;

        try {
            // calcularVolumenLlanta puede ser asincr√≥nica; esperamos el resultado
            const vol = await calcularVolumenLlanta(descripcion || '');
            // devolver n√∫mero como string con 4 decimales
            p.Volumen = vol ? String(vol) : '0.0000';
        } catch (e) {
            console.warn('No se pudo calcular volumen para', descripcion, e);
            p.Volumen = '0.0000';
        }
    }

    bloquestraspasos.push({ nombre: nombreBloque, datos: traspasosParaGuardar });
    await guardartraspasosEnSheetDB(traspasosParaGuardar);
    await agregarNuevosProductosAlINVENTARIO(traspasosParaGuardar);
    facturaResultDiv.textContent = '';
    archivosEscaneados = [];
    traspasosParaGuardar = [];
    mostrarArchivosEscaneados();
    mostrarBloquestraspasos();
};
// ...existing code...
// filepath: c:\Users\mg296\OneDrive\Escritorio\cubicaja\Proyecto_de_residencia_profesional.html
// ...existing code...
// Guardar en SheetDB (m√°s r√°pido: POST en lote)
async function guardartraspasosEnSheetDB(traspasos) {
    try {
        await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=traspasos', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ data: traspasos }) // Enviar array
        });
    } catch (e) {
        console.error('Error al guardar traspasos:', e);
    }
}
// ...existing code...
function mostrarArchivosEscaneados() {
    let html = `<h5 class="mt-4 mb-2">Archivos escaneados:</h5>`;
    archivosEscaneados.forEach((archivo, idx) => {
        html += `
            <div style="margin-bottom:8px;">
                <b>${archivo.nombreArchivo}</b>
                <button class="btn btn-danger btn-sm" onclick="eliminarArchivoEscaneado(${idx})">Eliminar</button>
                <table class="table table-bordered mt-2">
                    <thead>
                        <tr>
                            <th>Folio</th>
                            <th>Fecha de Emisi√≥n</th>
                            <th>Usuario</th>
                            <th>Cantidad</th>
                            <th>C√≥digo</th>
                            <th>Descripci√≥n</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${archivo.productos.map(p => `
                            <tr>
                                <td>${p.Folio}</td>
                                <td>${p["Fecha de Emisi√≥n"]}</td>
                                <td>${p.Usuario}</td>
                                <td>${p.Cantidad}</td>
                                <td>${p.C√≥digo}</td>
                                <td>${p.Descripci√≥n}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        `;
    });
    
    facturaResultDiv.innerHTML = html;


}

// Agregar esta nueva funci√≥n para manejar el toggle
function toggleDetalleArchivo(idx) {
    const detalle = document.getElementById(`detalleArchivo${idx}`);
    const icon = document.querySelector(`.toggle-icon-archivo-${idx}`);
    
    if (detalle.classList.contains('show')) {
        detalle.classList.remove('show');
        icon.textContent = '‚ñº';
    } else {
        detalle.classList.add('show');
        icon.textContent = '‚ñ≤';
    }
}

function eliminarArchivoEscaneado(idx) {
    archivosEscaneados.splice(idx, 1);
    facturaPdfInput.value = ''; // Limpia el input de archivos
    mostrarArchivosEscaneados();
}

// Mostrar todos los bloques en la p√°gina
// Modificar la funci√≥n mostrarBloquestraspasos()
function mostrarBloquestraspasos(filtro = '') {
    console.log('Mostrando bloques de traspasos, total:', bloquestraspasos?.length || 0);
    
    // El contenedor debe existir est√°ticamente en el HTML (#traspasosNormales)
    let container = document.getElementById('traspasosGroupsContainer');
    if (!container) {
        console.error('‚ùå Error: Contenedor #traspasosGroupsContainer no encontrado en el DOM. Verifica que est√© declarado en HTML.');
        return;
    }

    // Limpiar el contenedor primero
    container.innerHTML = '';

    if (!bloquestraspasos || bloquestraspasos.length === 0) {
        console.log('No hay bloques de traspasos para mostrar');
        container.innerHTML = '<div class="alert alert-info">No hay bloques de traspasos guardados.</div>';
        return;
    }

    console.log('Bloques a mostrar:', bloquestraspasos);

    // Eliminar duplicados bas√°ndose en el nombre del bloque
    const bloquesSinDuplicados = bloquestraspasos.reduce((acc, current) => {
        const x = acc.find(item => item.nombre === current.nombre);
        if (!x) {
            acc.push(current);
        }
        return acc;
    }, []);

    // Mostrar bloques filtrados y sin duplicados
    bloquesSinDuplicados
        .filter(b => b.nombre.toLowerCase().includes(filtro.toLowerCase()))
        .forEach((bloque, idx) => {
            const bloqueHTML = `
                <div class="card mb-2" id="bloqueFactura${idx}">
                    <div class="card-header d-flex justify-content-between align-items-center" 
                         style="cursor:pointer;" 
                         onclick="toggleDetalleBloque(${idx})">
                        <strong>${bloque.nombre}</strong>
                        <span class="toggle-icon">‚ñº</span>
                        <button class="btn btn-danger btn-sm" 
                                onclick="event.stopPropagation(); eliminarBloqueFactura(${idx})">
                            Eliminar bloque
                        </button>
                    </div>
                    <div class="card-body collapse" id="detalleBloque${idx}">
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Folio</th>
                                    <th>Fecha de Emisi√≥n</th>
                                    <th>Usuario</th>
                                    <th>Cantidad</th>
                                    <th>C√≥digo</th>
                                    <th>Descripci√≥n</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${bloque.datos.map((f, idx) => `
                                    <tr>
                                        <td>${idx === 0 ? f.Folio : ''}</td>
                                        <td>${idx === 0 ? f["Fecha de Emisi√≥n"] : ''}</td>
                                        <td>${idx === 0 ? f.Usuario : ''}</td>
                                        <td>${f.Cantidad || ''}</td>
                                        <td>${f.C√≥digo || ''}</td>
                                        <td>${f.Descripci√≥n || ''}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            container.innerHTML += bloqueHTML;
        });
}

// Mostrar bloques de la hoja 'FACTURAS' en la pesta√±a FACTURAS (en formato acorde√≥n)
function mostrarBloquesFACTURAS(filtro = '') {
    console.log('Mostrando bloques de FACTURAS, total:', bloquesFACTURAS?.length || 0);
    
    // El contenedor debe existir est√°ticamente en el HTML (#traspasosEspeciales)
    let container = document.getElementById('facturaGroupsContainer_FACTURAS');
    if (!container) {
        console.error('‚ùå Error: Contenedor #facturaGroupsContainer_FACTURAS no encontrado en el DOM.');
        return;
    }

    // Limpiar el contenedor primero
    container.innerHTML = '';

    if (!bloquesFACTURAS || bloquesFACTURAS.length === 0) {
        console.log('No hay bloques de FACTURAS para mostrar');
        container.innerHTML = '<div class="alert alert-info">No hay Facturas guardadas.</div>';
        return;
    }

    console.log('Bloques de FACTURAS a mostrar:', bloquesFACTURAS);

    // Eliminar duplicados bas√°ndose en el nombre del bloque
    const bloquesSinDuplicados = bloquesFACTURAS.reduce((acc, current) => {
        const x = acc.find(item => normalizeKey(item.nombre) === normalizeKey(current.nombre));
        if (!x) {
            acc.push(current);
        }
        return acc;
    }, []);

    // Mostrar bloques filtrados y sin duplicados en formato acorde√≥n
    const acordeonHTML = `
        <div class="accordion" id="acordeonFACTURAS">
            ${bloquesSinDuplicados
                .filter(b => b.nombre.toLowerCase().includes(filtro.toLowerCase()))
                .map((bloque, idx) => {
                    const bloqueNormalizado = normalizeKey(bloque.nombre);
                    const nombreSeguro = (bloque.nombre || '').replace(/"/g, '&quot;').replace(/'/g, "\\'");
                    return `
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="heading${idx}">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse${idx}" aria-expanded="false" aria-controls="collapse${idx}">
                                    <strong style="flex: 1;">${bloque.nombre}</strong>
                                    <span class="badge bg-info">${bloque.datos?.length || 0} items</span>
                                    <button class="btn btn-danger btn-sm" style="margin-left: 10px;" onclick="event.stopPropagation(); eliminarBloqueFacturaPorNombre('${nombreSeguro}')">
                                        Eliminar
                                    </button>
                                </button>
                            </h2>
                            <div id="collapse${idx}" class="accordion-collapse collapse" aria-labelledby="heading${idx}" data-bs-parent="#acordeonFACTURAS">
                                <div class="accordion-body">
                                    <table class="table table-bordered table-sm">
                                        <thead class="table-light">
                                            <tr>
                                                <th>Folio</th>
                                                <th>Fecha</th>
                                                <th>Usuario</th>
                                                <th>Cantidad</th>
                                                <th>C√≥digo</th>
                                                <th>Descripci√≥n</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${bloque.datos.map((f, itemIdx) => `
                                                <tr>
                                                    <td>${itemIdx === 0 ? (f.Folio || '') : ''}</td>
                                                    <td>${itemIdx === 0 ? (f["Fecha de Emisi√≥n"] || '') : ''}</td>
                                                    <td>${itemIdx === 0 ? (f.Usuario || '') : ''}</td>
                                                    <td>${f.Cantidad || ''}</td>
                                                    <td>${f.C√≥digo || ''}</td>
                                                    <td>${f.Descripci√≥n || ''}</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('')}
        </div>
    `;

    container.innerHTML = acordeonHTML;
}

// Funci√≥n para actualizar bloques de FACTURAS desde SheetDB
async function actualizarBloquesFACTURAS() {
    try {
        console.log('Iniciando actualizaci√≥n de bloques de FACTURAS...');
        
        const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=FACTURAS');
        if (!res.ok) throw new Error(`No se pudo cargar FACTURAS. Status: ${res.status}`);
        
        const FACTURAS = filterMeaningfulRows(await res.json());
        console.log('Datos recibidos de la hoja FACTURAS (filtradas):', FACTURAS);

        if (!Array.isArray(FACTURAS) || FACTURAS.length === 0) {
            console.log('No hay FACTURAS en la hoja. Mostrando datos locales en cach√©...');
            bloquesFACTURAS = [];
            
            // Mostrar datos locales en cach√© si la hoja est√° vac√≠a
            const localData = Object.keys(localStorage)
                .filter(key => key.startsWith('factura_especial_'))
                .map(key => {
                    try {
                        return JSON.parse(localStorage.getItem(key));
                    } catch (e) {
                        return null;
                    }
                })
                .filter(item => item !== null);
            
            if (localData.length > 0) {
                console.log('Mostrando datos locales en cach√©:', localData);
                bloquesFACTURAS = localData.map(data => ({
                    nombre: data.nombre || 'Sin nombre',
                    datos: data.productos || data.datos || []
                }));
            }
            
            mostrarBloquesFACTURAS();
            return false;
        }

        bloquesFACTURAS = [];
        let grupos = {};
        
        // Agrupar FACTURAS por nombre normalizado (evita duplicados)
        FACTURAS.forEach(f => {
            const nombre = f.Nombre || f.nombre || 'Sin nombre';
            const nombreNorm = normalizeKey(nombre);
            if (!grupos[nombreNorm]) {
                grupos[nombreNorm] = {
                    nombre: nombre,
                    datos: []
                };
            }
            grupos[nombreNorm].datos.push(f);
        });
        
        // Convertir grupos en bloques
        for (const nombreNorm in grupos) {
            bloquesFACTURAS.push(grupos[nombreNorm]);
        }
         
        console.log('Bloques de FACTURAS procesados:', bloquesFACTURAS);
        
        // Actualizar la visualizaci√≥n
        mostrarBloquesFACTURAS();
        return true;
    } catch (error) {
        console.error('Error actualizando bloques de FACTURAS:', error);
        console.error('Stack trace:', error.stack);
        
        const container = document.getElementById('facturaGroupsContainer_FACTURAS');
        if (container) {
            container.innerHTML = `<div class="alert alert-danger">Error al cargar FACTURAS: ${error.message}</div>`;
        }
        return false;
    }
}

// Toggle espec√≠fico para FACTURAS (IDs con sufijo _FACTURAS)


async function actualizarBloquestraspasos() {
    try {
        console.log('Iniciando actualizaci√≥n de bloques de traspasos...');
        
        const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=traspasos');
        if (!res.ok) throw new Error(`No se pudo cargar traspasos. Status: ${res.status}`);
        
        const traspasos = filterMeaningfulRows(await res.json());
        console.log('Datos recibidos de la hoja (filtrados):', traspasos);

        if (!Array.isArray(traspasos) || traspasos.length === 0) {
            console.log('No hay traspasos para mostrar');
            bloquestraspasos = [];
            mostrarBloquestraspasos();
            return true;
        }

        bloquestraspasos = [];
        let grupos = {};
        
        // Agrupar traspasos por nombre/folio
        traspasos.forEach(f => {
            if (!f) return; // Ignorar registros nulos
            
            // Intentar obtener un identificador v√°lido para el grupo
            const grupo = f.Nombre || f.Folio || f["Fecha de Emisi√≥n"] || 'Sin nombre';
            console.log('Procesando factura para grupo:', grupo, f);
        
            if (!grupos[grupo]) {   
                grupos[grupo] = [];
            }
            grupos[grupo].push(f);
        });
        
        // Convertir grupos en bloques
        for (const nombre in grupos) {
            if (grupos[nombre].length > 0) {
                bloquestraspasos.push({
                    nombre,
                    datos: grupos[nombre]
                });
            }
        }
         
        console.log('Bloques procesados:', bloquestraspasos);
        
        // Actualizar la visualizaci√≥n
        mostrarBloquestraspasos();
        return true;
    } catch (error) {
        console.error('Error actualizando bloques:', error);
        console.error('Stack trace:', error.stack);
        // Mostrar mensaje de error en la interfaz
        const container = document.getElementById('facturaGroupsContainer');
        if (container) {
            container.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle"></i>
                    Error al cargar los bloques: ${error.message}
                </div>
            `;
        }
        return false;
    }
}
// Modificar la funci√≥n toggleDetalleBloque()
function toggleDetalleBloque(idx) {
    const detalle = document.getElementById(`detalleBloque${idx}`);
    const icon = detalle.parentElement.querySelector('.toggle-icon');
    
    if (detalle.style.display === 'none' || !detalle.style.display) {
        detalle.style.display = 'block';
        icon.textContent = '‚ñ≤';
    } else {
        detalle.style.display = 'none';
        icon.textContent = '‚ñº';
    }
}

// Agrega esta funci√≥n para expandir/colapsar el detalle
function mostrarDetalles(idx) {
    const detalle = document.getElementById(`detalles_${idx}`);
    const bloque = bloquestraspasos[idx];
    
    if (detalle.style.display === 'none') {
        // Generar contenido de detalles
        detalle.innerHTML = `
            <table class="table table-sm">
                <thead>
                    <tr>
                        <th>Cantidad</th>
                        <th>C√≥digo</th>
                        <th>Descripci√≥n</th>
                    </tr>
                </thead>
                <tbody>
                    ${bloque.datos.map(item => `
                        <tr>
                            <td>${item.Cantidad || ''}</td>
                            <td>${item.C√≥digo || ''}</td>
                            <td>${item.Descripci√≥n || ''}</td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
        detalle.style.display = 'block';
    } else {
        detalle.style.display = 'none';
    }
}

// Funciones para el manejo de modos en Sugerencia de Unidad
function cambiarModoSugerencia(modo) {
    const modoCalculadora = document.getElementById('modoCalculadora');
    const modoBusqueda = document.getElementById('modoBusqueda');
    const btnCalculadora = document.getElementById('btnModoCalculadora');
    const btnBusqueda = document.getElementById('btnModoBusqueda');

    if (modo === 'calculadora') {
        modoCalculadora.style.display = 'block';
        modoBusqueda.style.display = 'none';
        btnCalculadora.classList.add('active');
        btnBusqueda.classList.remove('active');
    } else {
        modoCalculadora.style.display = 'none';
        modoBusqueda.style.display = 'block';
        btnCalculadora.classList.remove('active');
        btnBusqueda.classList.add('active');
    }
}

// Funci√≥n para buscar bloques
function calcularTotalesBloque(datos) {
    let totalVolumen = 0;
    let totalPeso = 0;
    let cantidadTotal = 0;
    
    datos.forEach(item => {
        const cantidad = parseInt(item.Cantidad) || 0;
        cantidadTotal += cantidad;
        
        // Aqu√≠ deber√≠as obtener el volumen y peso por tipo de llanta
        const tipoLlanta = determinarTipoLlanta(item.Descripci√≥n);
        const { volumen, peso } = obtenerMedidasPorTipo(tipoLlanta);
        
        totalVolumen += cantidad * volumen;
        totalPeso += cantidad * peso;
    });
    
    return { totalVolumen, totalPeso, cantidadTotal };
}

function determinarTipoLlanta(descripcion) {
    // L√≥gica para determinar el tipo de llanta basado en la descripci√≥n
    descripcion = descripcion.toLowerCase();
    if (descripcion.includes('auto') || descripcion.includes('compacto')) return 'AUTO';
    if (descripcion.includes('suv') || descripcion.includes('camioneta')) return 'SUV_CAMIONETA';
    if (descripcion.includes('comercial')) return 'COMERCIAL_LIGERO';
    if (descripcion.includes('camion')) return 'PESADO';
    if (descripcion.includes('agricola') || descripcion.includes('minero')) return 'AGRICOLA_MINERO';
    return 'AUTO'; // por defecto
}

function obtenerMedidasPorTipo(tipo) {
    const medidas = {
        'AUTO': { volumen: 0.047, peso: 7 },
        'SUV_CAMIONETA': { volumen: 0.075, peso: 15 },
        'COMERCIAL_LIGERO': { volumen: 0.12, peso: 25 },
        'PESADO': { volumen: 0.25, peso: 50 },
        'AGRICOLA_MINERO': { volumen: 0.5, peso: 100 }
    };
    return medidas[tipo] || medidas['AUTO'];
}

function seleccionarBloque(idx) {
    const bloque = bloquestraspasos[idx];
    
    // Limpiar b√∫squeda y ocultar resultados
    document.getElementById('busquedaBloque').value = '';
    document.getElementById('resultadosBusqueda').innerHTML = '';
    
    // Mostrar la secci√≥n de unidad sugerida para el modo b√∫squeda
    const seccionUnidadSugerida = document.getElementById('seccionUnidadSugeridaBusqueda');
    if (seccionUnidadSugerida) {
        seccionUnidadSugerida.style.display = 'block';
        
        // Mostrar expl√≠citamente la tabla y sus contenedores
        const tableResponsive = seccionUnidadSugerida.querySelector('.table-responsive');
        const table = seccionUnidadSugerida.querySelector('table');
        
        if (tableResponsive) tableResponsive.style.display = 'block';
        if (table) table.style.display = 'table';
        
        // Asegurarse de que la secci√≥n tenga altura suficiente
        seccionUnidadSugerida.style.minHeight = '200px';
    }
    
    // Variables globales para acumular bloques
    if (!window.bloquesAcumulados) {
        window.bloquesAcumulados = {
            llantas: [],
            volumenTotal: 0,
            pesoTotal: 0,
            totalLlantas: 0
        };
    }

    let volumenTotalBloque = 0;
    let pesoTotalBloque = 0;
    let totalLlantas = 0;
    
        function limpiarBloquesAcumulados() {
        // Reiniciar los valores acumulados
        window.bloquesAcumulados = {
            llantas: [],
            volumenTotal: 0,
            pesoTotal: 0,
            totalLlantas: 0
        };

        // Limpiar la tabla de sugerencias
        const tablaLlantas = document.getElementById('tablaLlantasSeleccionadas').querySelector('tbody');
        if (tablaLlantas) {
            tablaLlantas.innerHTML = '';
        }

        // Limpiar las unidades sugeridas
        const tablaSugerencias = document.getElementById('tablaUnidadesSugeridasBusqueda');
        if (tablaSugerencias) {
            tablaSugerencias.innerHTML = '';
        }

        // Ocultar el resumen de carga
        const totalLlantasDiv = document.getElementById('totalLlantas');
        if (totalLlantasDiv) {
            totalLlantasDiv.style.display = 'none';
        }

        // Mostrar mensaje al usuario
        mostrarAlerta('Bloques limpiados exitosamente', 'success');
    }

    // Calcular totales para cada llanta
    const llantas = bloque.datos.map(item => {
        const cantidad = parseInt(item.Cantidad) || 0;
        totalLlantas += cantidad;
        
        // Buscar la llanta en el INVENTARIO para obtener valores reales
        const llantaINVENTARIO = INVENTARIO.find(l => l.clave === item.C√≥digo);
        let volumenUnitario = 0;
        let pesoUnitario = 0;
        
        if (llantaINVENTARIO) {
            volumenUnitario = parseFloat(llantaINVENTARIO.volumen) || 0;
            pesoUnitario = parseFloat(llantaINVENTARIO.peso) || 0;
        } else {
            // Si no se encuentra en INVENTARIO, usar medidas estimadas
            const medidas = obtenerMedidasPorTipo(determinarTipoLlanta(item.Descripci√≥n));
            volumenUnitario = medidas.volumen;
            pesoUnitario = medidas.peso;
        }
        
        const volumenTotal = volumenUnitario * cantidad;
        const pesoTotal = pesoUnitario * cantidad;
        
        volumenTotalBloque += volumenTotal;
        pesoTotalBloque += pesoTotal;
        
        return {
            descripcion: item.Descripci√≥n,
            cantidad: cantidad,
            codigo: item.C√≥digo,
            volumenUnitario: volumenUnitario,
            pesoUnitario: pesoUnitario,
            volumenTotal: volumenTotal,
            pesoTotal: pesoTotal
        };
    });
    
    // Acumular los datos en las variables globales
    window.bloquesAcumulados.llantas = window.bloquesAcumulados.llantas.concat(llantas);
    window.bloquesAcumulados.volumenTotal += volumenTotalBloque;
    window.bloquesAcumulados.pesoTotal += pesoTotalBloque;
    window.bloquesAcumulados.totalLlantas += totalLlantas;

    // Calcular totales generales (ahora usando los acumulados)
    const totalVolumen = window.bloquesAcumulados.volumenTotal;
    const totalPeso = window.bloquesAcumulados.pesoTotal;
    const cantidadTotal = window.bloquesAcumulados.totalLlantas;
    
    // Actualizar tabla de llantas seleccionadas
    const tablaLlantas = document.getElementById('tablaLlantasSeleccionadas').querySelector('tbody');
    tablaLlantas.innerHTML = llantas.map(item => `
        <tr>
            <td>
                ${item.descripcion || ''}<br>
                <small class="text-muted">C√≥digo: ${item.codigo || 'N/A'}</small>
            </td>
            <td class="text-center">${item.cantidad || ''}</td>
            <td>
                ${item.volumenUnitario.toFixed(4)} m¬≥ √ó ${item.cantidad} = 
                <strong>${item.volumenTotal.toFixed(2)} m¬≥</strong>
            </td>
            <td>
                ${item.pesoUnitario.toFixed(2)} kg √ó ${item.cantidad} = 
                <strong>${item.pesoTotal.toFixed(2)} kg</strong>
            </td>
            <td>
                <button class="btn btn-danger btn-sm" onclick="eliminarFila(this)">
                    <i class="bi bi-trash"></i>
                </button>
            </td>
        </tr>
    `).join('');

    // Mostrar el total de llantas
    const totalLlantasDiv = document.getElementById('totalLlantas');
    totalLlantasDiv.style.display = 'block';
    totalLlantasDiv.innerHTML = `
        <div class="alert alert-info">
            <strong>Resumen de carga:</strong><br>
            ‚Ä¢ Total de llantas: ${totalLlantas}<br>
            ‚Ä¢ Volumen total: ${volumenTotalBloque.toFixed(2)} m¬≥<br>
            ‚Ä¢ Peso total: ${pesoTotalBloque.toFixed(2)} kg
        </div>
    `;

    // Obtener y mostrar las unidades sugeridas
    const tablaSugerencias = document.getElementById('tablaUnidadesSugeridasBusqueda');
    if (!tablaSugerencias) {
        console.error('No se encontr√≥ la tabla de sugerencias');
        return;
    }
    
    // Asegurarse de que los totales sean n√∫meros v√°lidos
    volumenTotalBloque = parseFloat(volumenTotalBloque) || 0;
    pesoTotalBloque = parseFloat(pesoTotalBloque) || 0;

    console.log('Totales calculados:', {
        volumenTotal: volumenTotalBloque,
        pesoTotal: pesoTotalBloque
    });
    
    console.log('Obteniendo unidades de flota...');
    
    // Obtener unidades confirmadas
    const unidadesConfirmadas = new Set(pedidosApartados.map(pedido => 
        String(pedido['Econ√≥mico'] || pedido.Economico || pedido.economico || pedido.c√≥digo || '').trim()
    ));
    
    console.log('Unidades confirmadas:', Array.from(unidadesConfirmadas));
    
    // Filtrar unidades disponibles excluyendo las confirmadas
    const unidadesDisponibles = obtenerUnidadesFlota().filter(unidad => {
        const codigoUnidad = String(unidad.codigo || unidad.econ√≥mico || '').trim();
        return !unidadesConfirmadas.has(codigoUnidad);
    });
    console.log('Unidades disponibles:', unidadesDisponibles);

    console.log('Volumen total del bloque:', volumenTotalBloque);
    console.log('Peso total del bloque:', pesoTotalBloque);
    console.log('Unidades disponibles:', unidadesDisponibles);
    
    // Depuraci√≥n de valores iniciales
    console.log('Valores para filtrado:', {
        volumenTotalBloque,
        pesoTotalBloque,   
        unidadesDisponibles: unidadesDisponibles.map(u => ({
            nombre: u.nombre,
            codigo: u.codigo,
            capacidadVolumen: u.capacidadVolumen,
            capacidadPeso: u.capacidadPeso
        }))
    });

    // Filtrar unidades v√°lidas y ordenar por eficiencia
    const unidadesOptimas = unidadesDisponibles
        .filter(u => {
            // Convertir las capacidades a n√∫meros para asegurar comparaciones v√°lidas
            const capVolumen = parseFloat(u.capacidadVolumen) || 0;
            const capPeso = parseFloat(u.capacidadPeso) || 0;
            
            const esValida = capVolumen >= volumenTotalBloque && capPeso >= pesoTotalBloque;
            
            console.log(`Evaluando unidad ${u.nombre} (${u.codigo}):`, {
                capacidadVolumen: capVolumen,
                volumenRequerido: volumenTotalBloque,
                capacidadPeso: capPeso,
                pesoRequerido: pesoTotalBloque,
                cumpleVolumen: capVolumen >= volumenTotalBloque,
                cumplePeso: capPeso >= pesoTotalBloque,
                esValida
            });
            
            return esValida;
        })
        .sort((a, b) => {
            // Calcular eficiencia como porcentaje de uso
            const eficienciaVolumenA = (volumenTotalBloque / parseFloat(a.capacidadVolumen)) * 100;
            const eficienciaPesoA = (pesoTotalBloque / parseFloat(a.capacidadPeso)) * 100;
            const eficienciaA = Math.min(eficienciaVolumenA, eficienciaPesoA);

            const eficienciaVolumenB = (volumenTotalBloque / parseFloat(b.capacidadVolumen)) * 100;
            const eficienciaPesoB = (pesoTotalBloque / parseFloat(b.capacidadPeso)) * 100;
            const eficienciaB = Math.min(eficienciaVolumenB, eficienciaPesoB);

            console.log(`Comparando eficiencias:`, {
                unidadA: `${a.nombre} (${a.codigo})`,
                eficienciaA: eficienciaA.toFixed(2) + '%',
                unidadB: `${b.nombre} (${b.codigo})`,
                eficienciaB: eficienciaB.toFixed(2) + '%'
            });

            return eficienciaB - eficienciaA;
        });

    console.log('Unidades √≥ptimas encontradas:', unidadesOptimas);

    if (unidadesOptimas.length === 0) {
        tablaSugerencias.innerHTML = `
            <tr>
                <td colspan="9" class="text-center">
                    <div class="alert alert-warning mb-0">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        No se encontr√≥ ninguna unidad que pueda transportar esta carga.
                        <br>
                        <small>
                            Volumen requerido: ${volumenTotalBloque.toFixed(2)} m¬≥ 
                            | Peso requerido: ${pesoTotalBloque.toFixed(2)} kg
                        </small>
                    </div>
                </td>
            </tr>
        `;
        return;
    }

    tablaSugerencias.innerHTML = unidadesOptimas.map(unidad => {
        const usoVolumen = (volumenTotalBloque/unidad.capacidadVolumen * 100).toFixed(1);
        const usoPeso = (pesoTotalBloque/unidad.capacidadPeso * 100).toFixed(1);
        const eficiencia = Math.min(parseFloat(usoVolumen), parseFloat(usoPeso));

        console.log(`Generando fila para unidad ${unidad.nombre}:`, {
            usoVolumen,
            usoPeso,
            eficiencia
        });
        
        return `
            <tr>
                <td>${unidad.nombre}</td>
                <td>${unidad.codigo}</td>
                <td>${unidad.capacidadVolumen} m¬≥</td>
                <td>${unidad.capacidadPeso} kg</td>
                <td>
                    <div class="progress" style="height: 20px;">
                        <div class="progress-bar bg-primary" 
                             role="progressbar" 
                             style="width: ${usoVolumen}%" 
                             title="Uso de volumen: ${usoVolumen}%">
                            ${usoVolumen}%
                        </div>
                    </div>
                </td>
                <td>
                    <div class="progress" style="height: 20px;">
                        <div class="progress-bar bg-warning" 
                             role="progressbar" 
                             style="width: ${usoPeso}%" 
                             title="Uso de peso: ${usoPeso}%">
                            ${usoPeso}%
                        </div>
                    </div>
                </td>
                <td>
                    <div class="progress" style="height: 20px;">
                        <div class="progress-bar bg-success" 
                             role="progressbar" 
                             style="width: ${eficiencia}%" 
                             title="Eficiencia global: ${eficiencia}%">
                            ${eficiencia}%
                        </div>
                    </div>
                </td>
                <td class="text-center">
                    <button class="btn btn-success w-100 fw-bold" 
                            onclick="apartarUnidadConDetalles('${unidad.codigo}', window.llantasAgregadas, ${volumenTotalBloque}, ${pesoTotalBloque})">
                        <i class="bi bi-check-circle-fill me-2"></i>
                        Apartar Unidad
                    </button>
                </td>
            </tr>
        `;
    }).join('');
    
    // Mostrar totales separados por tipo de llanta
    const tiposPorSeparado = llantasAgregadas.reduce((grupos, llanta) => {
        const tipo = llanta.descripcion;
        if (!grupos[tipo]) {
            grupos[tipo] = {
                cantidad: 0,
                volumen: 0,
                peso: 0
            };
        }
        grupos[tipo].cantidad += llanta.cantidad;
        grupos[tipo].volumen += llanta.volumenTotal;
        grupos[tipo].peso += llanta.pesoTotal;
        return grupos;
    }, {});

    document.getElementById('totalLlantas').innerHTML = `
        <div class="alert alert-info">
            <strong>Resumen Detallado por Tipo de Llanta:</strong><br>
            <div class="mt-3">
                ${Object.entries(tiposPorSeparado).map(([tipo, datos]) => `
                    <div class="mb-2 border-bottom pb-2">
                        <strong>${tipo}</strong><br>
                        ‚Ä¢ Cantidad: ${datos.cantidad} llantas<br>
                        ‚Ä¢ Volumen: ${datos.volumen.toFixed(2)} m¬≥<br>
                        ‚Ä¢ Peso: ${datos.peso.toFixed(2)} kg
                    </div>
                `).join('')}
            </div>
            <div class="mt-3 pt-2 border-top">
                <strong>Totales Generales:</strong><br>
                ‚Ä¢ Volumen total: ${totalVolumen.toFixed(2)} m¬≥<br>
                ‚Ä¢ Peso total: ${totalPeso.toFixed(2)} kg<br>
                ‚Ä¢ Total de llantas: ${cantidadTotal} unidades
            </div>
        </div>
    `;
    
    // Calcular y mostrar unidad sugerida
    const resultadoDiv = document.getElementById('resultadoSugerencia');
    resultadoDiv.classList.remove('d-none');
    
    // Obtener las unidades disponibles de la flota
    const unidades = obtenerUnidadesFlota();
    
    // Encontrar la unidad m√°s eficiente
    const unidadesValidas = unidades.filter(u => 
        u.capacidadVolumen >= totalVolumen && u.capacidadPeso >= totalPeso
    );
    
    const detallesDiv = document.getElementById('unidadSugeridaDetalles');
    
    if (unidadesValidas.length === 0) {
        detallesDiv.innerHTML = `
            <div class="alert alert-warning">
                <i class="bi bi-exclamation-triangle"></i>
                No se encontr√≥ una unidad adecuada para esta carga.
            </div>
        `;
        return;
    }
    
    const mejorUnidad = unidadesValidas.sort((a, b) => {
        const eficienciaA = Math.min(totalVolumen/a.capacidadVolumen, totalPeso/a.capacidadPeso);
        const eficienciaB = Math.min(totalVolumen/b.capacidadVolumen, totalPeso/b.capacidadPeso);
        return eficienciaB - eficienciaA;
    })[0];
    
    const usoVolumen = (totalVolumen/mejorUnidad.capacidadVolumen * 100).toFixed(1);
    const usoPeso = (totalPeso/mejorUnidad.capacidadPeso * 100).toFixed(1);
    const eficiencia = Math.min(
        (totalVolumen/mejorUnidad.capacidadVolumen * 100),
        (totalPeso/mejorUnidad.capacidadPeso * 100)
    ).toFixed(1);
    
    // Guardar los datos del bloque seleccionado globalmente
    window.bloqueSeleccionado = {    
        llantas: llantas,             
        volumenTotal: totalVolumen,
        pesoTotal: totalPeso,  
        unidad: mejorUnidad,  
    };
     
    // Mostrar la informaci√≥n de la unidad seleccionada     
    detallesDiv.innerHTML = `     
        <div class="card mb-3">
            <div class="card-header bg-success text-white">
                <h5 class="mb-0">Unidad Seleccionada</h5>
            </div>
            <div class="card-body">
                <p><strong>Unidad:</strong> ${mejorUnidad.nombre || mejorUnidad.unidad}</p>
                <p><strong>Econ√≥mico:</strong> ${mejorUnidad.codigo || mejorUnidad.economico}</p>
                <p><strong>Uso de Volumen:</strong> ${usoVolumen}%</p>
                <p><strong>Uso de Peso:</strong> ${usoPeso}%</p>
                <p><strong>Eficiencia Global:</strong> ${eficiencia}%</p>
                <div class="mt-3">
                    <button class="btn btn-primary" onclick="apartarUnidadConDetalles(window.bloqueSeleccionado.unidad, window.bloqueSeleccionado.llantas, window.bloqueSeleccionado.volumenTotal, window.bloqueSeleccionado.pesoTotal)">
                        <i class="bi bi-box-arrow-right"></i> Apartar esta unidad
                    </button>
                </div>
            </div>
        </div>
    `;
    }

    let htmlUnidades = '';
    distribucion.unidades.forEach((info, index) => {
        const usoVolumen = (info.volumen/info.unidad.capacidadVolumen * 100).toFixed(1);
        const usoPeso = (info.peso/info.unidad.capacidadPeso * 100).toFixed(1);
        
        htmlUnidades += `
            <div class="card mb-3">
                <div class="card-header bg-${index === 0 ? 'primary' : 'success'} text-white d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        ${index === 0 ? 'Unidad Principal' : 'Unidad Auxiliar'}
                    </h5>
                    <button class="btn btn-light" 
                            onclick='apartarUnidad(
                                {"nombre": "${info.unidad.nombre}", "codigo": "${info.unidad.codigo}"}, 
                                ${JSON.stringify(llantasAgregadas)}, 
                                ${info.volumen}, 
                                ${info.peso}
                            )'>
                        <i class="bi bi-box-arrow-right"></i> Apartar Esta Unidad
                    </button>
                </div>
                <div class="card-body">
                    <table class="table table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>Unidad</th>
                                <th>Econ√≥mico</th>
                                <th>Capacidad</th>
                                <th>Carga Asignada</th>
                                <th>Uso</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>${info.unidad.nombre}</td>
                                <td>${info.unidad.codigo}</td>
                                <td>
                                    <div>Volumen: ${info.unidad.capacidadVolumen} m¬≥</div>
                                    <div>Peso: ${info.unidad.capacidadPeso} kg</div>
                                </td>
                                <td>
                                    <div>Volumen: ${info.volumen.toFixed(2)} m¬≥</div>
                                    <div>Peso: ${info.peso.toFixed(2)} kg</div>
                                </td>
                                <td>
                                    <div class="progress mb-2">
                                        <div class="progress-bar bg-primary" 
                                             role="progressbar" 
                                             style="width: ${usoVolumen}%" 
                                             title="Uso de volumen: ${usoVolumen}%">
                                            Vol: ${usoVolumen}%
                                        </div>
                                    </div>
                                    <div class="progress">
                                        <div class="progress-bar bg-warning" 
                                             role="progressbar" 
                                             style="width: ${usoPeso}%" 
                                             title="Uso de peso: ${usoPeso}%">
                                            Peso: ${usoPeso}%
                                        </div>
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <div class="mt-2">
                        <strong>Eficiencia de la unidad:</strong>
                        <div class="progress mb-3">
                            <div class="progress-bar bg-success" 
                                 role="progressbar" 
                                 style="width: ${info.eficiencia}%" 
                                 title="Eficiencia: ${info.eficiencia.toFixed(1)}%">
                                ${info.eficiencia.toFixed(1)}%
                            </div>
                        </div>
                        <button class="btn btn-primary w-100" 
                                onclick="apartarUnidad(
                                    {nombre: '${info.unidad.nombre}', codigo: '${info.unidad.codigo}'}, 
                                    ${JSON.stringify(llantasAgregadas)}, 
                                    ${info.volumen}, 
                                    ${info.peso}
                                )">
                            <i class="bi bi-box-arrow-right"></i> Apartar Esta Unidad
                        </button>
                    </div>
                </div>
            </div>
        `;
    });

    detallesDiv.innerHTML = `
        <div class="alert alert-info mb-3">
            <strong>Distribuci√≥n √≥ptima encontrada</strong><br>
            Eficiencia global: ${distribucion.eficienciaTotal.toFixed(1)}%
        </div>
        ${htmlUnidades}
                            </div>
                        </td>
                        <td>
                            <div class="progress">
                                <div class="progress-bar bg-success" 
                                     role="progressbar" 
                                     style="width: ${eficiencia}%" 
                                     aria-valuenow="${eficiencia}" 
                                     aria-valuemin="0" 
                                     aria-valuemax="100">
                                    ${eficiencia}%
                                </div>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    `;


function calcularUnidadSugerida(volumenTotal, pesoTotal) {
    // Obtener las unidades de la flota
    const unidades = obtenerUnidadesFlota();
    
    const resultadoDiv = document.getElementById('resultadoSugerencia');
    const detallesDiv = document.getElementById('unidadSugeridaDetalles');
    
    // Encontrar las unidades v√°lidas y no apartadas
    const unidadesValidas = unidades.filter(u => 
        u.capacidadVolumen >= volumenTotal && 
        u.capacidadPeso >= pesoTotal &&
        !estaUnidadApartada(u.codigo)
    );

    detallesDiv.innerHTML = `
        <div class="card">
            <div class="card-header bg-success text-white">
                <h5 class="mb-0">Unidad Sugerida</h5>
            </div>
            <div class="card-body">
                <table class="table">
                    <thead>
                        <tr>
                            <th>Unidad</th>
                            <th>Econ√≥mico</th>
                            <th>Cap. Volumen</th>
                            <th>Cap. Peso</th>
                            <th style="width: 120px">Uso Volumen</th>
                            <th style="width: 120px">Uso Peso</th>
                            <th style="width: 120px">Eficiencia</th>
                            <th style="width: 120px">Acciones</th>
                        </tr>
                    </thead>
                    <tbody>
    `;
    
    if (unidadesValidas.length === 0) {
        detallesDiv.innerHTML += `
                    </tbody>
                </table>
                <div class="alert alert-warning mt-3">
                    <i class="bi bi-exclamation-triangle-fill me-2"></i>
                    No se encontr√≥ ninguna unidad que pueda transportar esta carga.
                </div>
            </div>
        </div>`;
    } else {
        // Ordenar por eficiencia
        const unidadesOrdenadas = unidadesValidas.sort((a, b) => {
            const eficienciaA = Math.min(volumenTotal/a.capacidadVolumen, pesoTotal/a.capacidadPeso);
            const eficienciaB = Math.min(volumenTotal/b.capacidadVolumen, pesoTotal/b.capacidadPeso);
            return eficienciaB - eficienciaA;
        });

        // Mostrar las unidades ordenadas por eficiencia
        const htmlUnidades = unidadesOrdenadas.map(unidad => {
            const usoVolumen = (volumenTotal/unidad.capacidadVolumen * 100).toFixed(1);
            const usoPeso = (pesoTotal/unidad.capacidadPeso * 100).toFixed(1);
            const eficiencia = Math.min(parseFloat(usoVolumen), parseFloat(usoPeso));
            
            return `
                <tr>
                    <td>${unidad.nombre}</td>
                    <td>${unidad.codigo}</td>
                    <td>${unidad.capacidadVolumen} m¬≥</td>
                    <td>${unidad.capacidadPeso} kg</td>
                    <td>
                        <div class="progress" style="height: 20px;">
                            <div class="progress-bar bg-primary" 
                                 role="progressbar" 
                                 style="width: ${usoVolumen}%" 
                                 title="Uso de volumen: ${usoVolumen}%">
                                ${usoVolumen}%
                            </div>
                        </div>
                    </td>
                    <td>
                        <div class="progress" style="height: 20px;">
                            <div class="progress-bar bg-warning" 
                                 role="progressbar" 
                                 style="width: ${usoPeso}%" 
                                 title="Uso de peso: ${usoPeso}%">
                                ${usoPeso}%
                            </div>
                        </div>
                    </td>
                    <td>
                        <div class="progress" style="height: 20px;">
                            <div class="progress-bar bg-success" 
                                 role="progressbar" 
                                 style="width: ${eficiencia}%" 
                                 title="Eficiencia global: ${eficiencia}%">
                                ${eficiencia}%
                            </div>
                        </div>
                    </td>
                    <td class="text-center">
                        <button class="btn btn-success w-100 fw-bold" 
                                style="font-size: 0.9rem;"
                                onclick="apartarUnidad(
                                    {
                                        nombre: '${unidad.nombre}',
                                        codigo: '${unidad.codigo}',
                                        capacidadVolumen: ${unidad.capacidadVolumen},
                                        capacidadPeso: ${unidad.capacidadPeso}
                                    }, 
                                    window.llantasAgregadas,
                                    ${volumenTotal},
                                    ${pesoTotal}
                                )">
                            <i class="bi bi-check-circle-fill me-2"></i>
                            Apartar Unidad
                        </button>
                    </td>
                </tr>
            `;
        }).join('');

        detallesDiv.innerHTML += htmlUnidades + `
                    </tbody>
                </table>
            </div>
        </div>`;
    }

    resultadoDiv.classList.remove('d-none');
}

function limpiarCalculadora() {
    if (!confirm('¬øEst√°s seguro de que quieres limpiar todos los datos de la calculadora?')) return;
    clearEverything();
    // Re-apply calculadora-specific UI resets
    try { document.getElementById('sugestionCantidad').value = '1'; } catch (e) { }
    try { const st = document.getElementById('sugestionTipoLlanta'); if (st) st.selectedIndex = 0; } catch (e) { }
    try { const tl = document.getElementById('totalLlantas'); if (tl) tl.innerHTML = ''; } catch (e) { }
    try { const rs = document.getElementById('resultadoSugerencia'); if (rs) rs.classList.add('d-none'); } catch (e) { }
    try { const ud = document.getElementById('unidadSugeridaDetalles'); if (ud) ud.innerHTML = ''; } catch (e) { }
    try { const sec = document.getElementById('seccionUnidadSugeridaCalculadora'); if (sec) sec.style.display = 'none'; } catch (e) { }
    console.log('‚úÖ [CALCULADORA] Limpieza completada y delegado a clearEverything');
}

function limpiarBusquedaBloques() {
    // Confirmar con el usuario
    if (!confirm('¬øEst√°s seguro de que quieres limpiar todos los datos de la b√∫squeda?')) {
        return;
    }

    // Limpiar campo de b√∫squeda
    document.getElementById('busquedaBloque').value = '';
    
    // Limpiar resultados de b√∫squeda
    document.getElementById('resultadosBusqueda').innerHTML = '';
    
    // Limpiar tabla de llantas seleccionadas
    const tablaLlantas = document.getElementById('tablaLlantasSeleccionadas');
    if (tablaLlantas) {
        const tbody = tablaLlantas.querySelector('tbody');
        if (tbody) tbody.innerHTML = '';
    }
    
    // Ocultar y limpiar secci√≥n de unidad sugerida
    const seccionUnidadSugerida = document.getElementById('seccionUnidadSugeridaBusqueda');
    if (seccionUnidadSugerida) {
        seccionUnidadSugerida.style.display = 'none';
    }
    
    // Limpiar totales
    const totalLlantas = document.getElementById('totalLlantas');
    if (totalLlantas) {
        totalLlantas.style.display = 'none';
        totalLlantas.innerHTML = '';
    }
}

function limpiarSeleccion() {
    // Limpiar tabla de llantas agregadas
    const tablaLlantas = document.getElementById('tablaLlantasAgregadas').querySelector('tbody');
    tablaLlantas.innerHTML = '';
    
    // Ocultar resultado de sugerencia
    const resultadoDiv = document.getElementById('resultadoSugerencia');
    resultadoDiv.classList.add('d-none');
    
    // Limpiar totales
    document.getElementById('totalLlantas').innerHTML = '';
}

function obtenerUnidadesFlota() {
    try {
        // Obtener los datos directamente de la tabla de flota
        const tabla = document.querySelector('#tablaFlota tbody');
        if (!tabla) {
            console.error('No se encontr√≥ la tabla de flota (#tablaFlota tbody)');
            return [];
        }
        
        console.log('Tabla de flota encontrada');
        console.log('N√∫mero de filas encontradas:', tabla.rows.length);
        
        // Convertir las filas de la tabla en objetos de unidades
        const unidadesDisponibles = [];
        
        for (let i = 0; i < tabla.rows.length; i++) {
            const row = tabla.rows[i];
            
            // Verificar que la fila tenga todas las celdas necesarias (necesitamos al menos 8 columnas)
            if (row.cells.length < 8) {
                console.warn(`Fila ${i} tiene estructura incorrecta:`, row.cells.length, 'celdas');
                continue;
            }

            try {
                // Los datos est√°n en el orden: Econ√≥mico, Unidad, Asignado, Modelo, ID, Ubicaci√≥n, Cap. Peso, Volumen
                const economico = row.cells[0].textContent.trim();          // Econ√≥mico (primera columna)
                const nombreUnidad = row.cells[1].textContent.trim();       // Unidad (segunda columna)
                const ubicacion = row.cells[5].textContent.trim() || '';
                const capacidadPeso = parseFloat(row.cells[6].textContent.trim()) || 0;    // Capacidad de carga en kg (s√©ptima columna)
                const capacidadVolumen = parseFloat(row.cells[7].textContent.trim()) || 0;  // Volumen en m¬≥ (octava columna)

                console.log(`Procesando fila ${i}:`, {
                    nombre: nombreUnidad,
                    codigo: economico,
                    ubicacion: ubicacion,
                    capacidadVolumen: capacidadVolumen,
                    capacidadPeso: capacidadPeso
                });

                const unidad = {
                    nombre: nombreUnidad,
                    codigo: economico,
                    ubicacion: ubicacion,
                    capacidadVolumen: capacidadVolumen, // Volumen fijo por ahora
                    capacidadPeso: capacidadPeso, // Peso de la columna 3
                    estado: 'Disponible' // Por defecto disponible
                };

                console.log('Unidad procesada correctamente:', unidad);
                unidadesDisponibles.push(unidad);
            } catch (error) {
                console.error(`Error al procesar fila ${i}:`, error);
            }
        }

        // Actualizar opciones del filtro de ubicaciones basado en la tabla de flota (din√°micamente)
        try {
            const ubicaciones = Array.from(new Set(unidadesDisponibles.map(u => (u.ubicacion||'').trim()).filter(Boolean))).sort();
            const sel = document.getElementById('filtroUbicacionUnidades');
            if (sel) {
                const current = sel.value || 'Todos';
                sel.innerHTML = '<option value="Todos">Todos</option>' + ubicaciones.map(u => `<option value="${u}">${u}</option>`).join('');
                if ([...sel.options].some(o => o.value === current)) sel.value = current; else sel.value = 'Todos';
            }
            // Mantener sincronizado el filtro dentro de C√°lculo R√°pido si existe
            const calcSel = document.getElementById('calcRapidaFiltroUbicacion');
            if (calcSel) {
                const current2 = calcSel.value || 'Todos';
                calcSel.innerHTML = '<option value="Todos">Todos</option>' + ubicaciones.map(u => `<option value="${u}">${u}</option>`).join('');
                if ([...calcSel.options].some(o => o.value === current2)) calcSel.value = current2; else calcSel.value = 'Todos';
            }
        } catch(e) { console.warn('No se pudo actualizar filtro de ubicaciones:', e); }

        console.log('Total de unidades procesadas:', unidadesDisponibles.length);
        console.log('Unidades disponibles:', unidadesDisponibles);

        return unidadesDisponibles;
        
        return unidadesDisponibles;
    } catch (error) {
        console.error('Error general en obtenerUnidadesFlota:', error);
        return [];
    }

    // Obtener los n√∫meros econ√≥micos de las unidades confirmadas
    const unidadesConfirmadas = new Set(pedidosApartados.map(pedido => 
        String(pedido['Econ√≥mico'] || pedido.Economico || pedido.economico || pedido.c√≥digo || '').trim().toLowerCase()
    ));

    // Filtrar unidades que est√©n disponibles Y NO est√©n en la lista de confirmadas
    console.log('Unidades disponibles antes de filtrar:', unidadesDisponibles);
    console.log('Unidades confirmadas:', Array.from(unidadesConfirmadas));
    
    const unidadesFiltradas = unidadesDisponibles.filter(u => {
        const codigoUnidad = String(u.codigo || '').trim().toLowerCase();
        const estaDisponible = u.estado === "Disponible";
        const noEstaConfirmada = !unidadesConfirmadas.has(codigoUnidad);
        
        console.log(`Unidad ${u.nombre} (${codigoUnidad}):`, {
            estaDisponible,
            noEstaConfirmada,
            estado: u.estado
        });
        
        return estaDisponible && noEstaConfirmada;
    });
    
    console.log('Unidades filtradas final:', unidadesFiltradas);
    return unidadesFiltradas;
}
                    
function buscarBloques() {
    const busqueda = document.getElementById('busquedaBloque').value.toLowerCase();
    const resultados = document.getElementById('resultadosBusqueda');
    
    // Si no hay t√©rmino de b√∫squeda, limpiamos los resultados
    if (!busqueda) {
        resultados.innerHTML = '<div class="alert alert-info">Ingresa el nombre del bloque o alg√∫n detalle para buscarlo.</div>';
        return;
    }

    // Obtener los n√∫meros econ√≥micos de las unidades confirmadas
    const unidadesConfirmadas = new Set(pedidosApartados.map(pedido => 
        String(pedido['Econ√≥mico'] || pedido.Economico || pedido.economico || pedido.c√≥digo || '').trim().toLowerCase()
    ));
    
    console.log('Unidades confirmadas:', Array.from(unidadesConfirmadas));
    
    // Filtrar los bloques y excluir unidades confirmadas
    const bloquesFiltrados = bloquestraspasos.filter(bloque => {
        // Primero verificamos si el bloque coincide con la b√∫squeda
        const nombre = (bloque.nombre || '').toLowerCase();
        const datos = bloque.datos || [];
        
        // Verificar si la unidad est√° en Apartados (considerando diferentes formatos de c√≥digo)
        const codigoUnidad = String(bloque.economico || bloque.codigo || '').trim().toLowerCase();
        if (codigoUnidad && unidadesConfirmadas.has(codigoUnidad)) {
            console.log('Bloque excluido por unidad confirmada:', codigoUnidad);
            return false;
        }
        
        // Solo si la unidad no est√° confirmada, verificamos si coincide con la b√∫squeda
        const contenidoMatch = datos.some(item => {
            const descripcion = (item.Descripci√≥n || '').toLowerCase();
            const codigo = (item.C√≥digo || '').toLowerCase();
            return descripcion.includes(busqueda) || codigo.includes(busqueda);
        });

        return nombre.includes(busqueda) || contenidoMatch;
    });
    
    // Mostrar resultados
    if (bloquesFiltrados.length === 0) {
        resultados.innerHTML = `
            <div class="alert alert-warning">
                <h6><i class="bi bi-exclamation-triangle"></i> No se encontraron bloques disponibles</h6>
                <p>Esto puede deberse a:</p>
                <ul>
                    <li>No hay bloques que coincidan con la b√∫squeda "${busqueda}"</li>
                    <li>Los bloques encontrados est√°n asignados a unidades en uso</li>
                </ul>
            </div>`;
        return;
    }  

    // Generar HTML para los resultados
    resultados.innerHTML = bloquesFiltrados.map((bloque, idx) => `
        <div class="card mb-3 rounded">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <h6 class="mb-0">${bloque.nombre || 'Sin nombre'}</h6>
                    <div>
                        <button class="btn btn-primary me-2" onclick="seleccionarBloque(${idx})">
                            Seleccionar Bloque
                        </button>
                        <button class="btn btn-info" onclick="mostrarDetalles(${idx})">
                            Ver detalles
                        </button>
                    </div>
                </div>
            </div>
            <div id="detalles_${idx}" class="card-body border-top" style="display: none;">
                <table class="table table-sm">
                    <thead>
                        <tr>
                            <th>Cantidad</th>
                            <th>C√≥digo</th>
                            <th>Descripci√≥n</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${bloque.datos.map(f => `
                            <tr>
                                <td>${f.Cantidad || ''}</td>
                                <td>${f.C√≥digo || ''}</td>
                                <td>${f.Descripci√≥n || ''}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        </div>
    `).join('');
}

async function eliminarFilasPorNombreYHoja(nombreBloqueRaw, sheetName = 'traspasos', opts = { useFilterFallback: true }) {
    const useFilterFallback = Boolean(opts.useFilterFallback);
    const result = { totalFound: 0, deleted: 0, failed: [] };

    function normalizeStr(s) {
        if (!s) return '';
        try {
            return s.toString().normalize('NFD').replace(/\p{Diacritic}/gu, '').replace(/[\u0300-\u036f]/g, '').toLowerCase().trim().replace(/\s+/g, ' ');
        } catch (e) {
            return s.toString().toLowerCase().trim().replace(/\s+/g, ' ');
        }
    }

    function extractNameFromRow(row) {
        if (!row || typeof row !== 'object') return '';
        const keys = Object.keys(row || {});
        for (const k of keys) {
            if (/nombre/i.test(k) || /folio/i.test(k)) {
                const val = row[k];
                if (val && val.toString().trim()) return val.toString();    
            }
        }
        return (row.Nombre || row.Folio || row.nombre || row.folio || '').toString();
    }

    try {
        const res = await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=${encodeURIComponent(sheetName)}`);
        if (!res.ok) throw new Error(`No se pudieron cargar las filas de ${sheetName} (status ${res.status})`);
        const filas = filterMeaningfulRows(await res.json());

        const nombreNorm = normalizeStr(nombreBloqueRaw || '');
        const matches = filas.filter(r => {
            const candidate = extractNameFromRow(r);
            const candNorm = normalizeStr(candidate);
            return candNorm === nombreNorm || candNorm.includes(nombreNorm) || nombreNorm.includes(candNorm);
        });

        result.totalFound = matches.length;
        console.log(`[${sheetName}] Encontradas ${matches.length} coincidencias para "${nombreBloqueRaw}"`);

        if (matches.length === 0) return result;

        for (const row of matches) {
            const rowId = row.row_id || row.rowId || row.id || row.ID || null;
            if (!rowId) {
                console.warn(`[${sheetName}] Fila sin row_id:`, row);
                result.failed.push({ row, reason: 'missing_row_id' });
                continue;
            }

            let deleted = false;
            let lastError = null;
            for (let attempt = 1; attempt <= 3 && !deleted; attempt++) {
                try {
                    const delRes = await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey/row_id/${rowId}?sheet=${encodeURIComponent(sheetName)}`, { method: 'DELETE' });
                    if (delRes.ok) {
                        deleted = true;
                        result.deleted++;
                        console.log(`[${sheetName}] ‚úÖ Fila eliminada por row_id (intento ${attempt}): ${rowId}`);
                        break;
                    } else {
                        const status = delRes.status;
                        const body = await delRes.text().catch(() => '');
                        lastError = `status:${status}`;
                        console.warn(`[${sheetName}] ‚ö†Ô∏è DELETE por row_id fall√≥ (intento ${attempt}):`, { rowId, status });
                    }
                } catch (e) {
                    lastError = e.message || String(e);
                    console.warn(`[${sheetName}] ‚ö†Ô∏è Excepci√≥n en DELETE por row_id (intento ${attempt}):`, e.message);
                }
                if (attempt < 3 && !deleted) {
                    await new Promise(r => setTimeout(r, 200 * attempt));
                }
            }
            if (!deleted) {
                console.error(`[${sheetName}] ‚ùå No se pudo eliminar la fila: ${rowId}. Raz√≥n: ${lastError}`);
                result.failed.push({ rowId, reason: lastError });
            }
        }

        // Fallback: intento eliminar por filtro Nombre si hubieron fallos
        if (useFilterFallback && result.failed.length > 0) {
            try {
                const filterUrl = `https://sheetdb.io/api/v1/gdn5wqo960cey/Nombre/${encodeURIComponent(nombreBloqueRaw)}?sheet=${encodeURIComponent(sheetName)}`;
                const fallbackRes = await fetch(filterUrl, { method: 'DELETE' });
                if (fallbackRes.ok) {
                    console.info(`[${sheetName}] ‚úÖ Fallback DELETE por Nombre tuvo √©xito`);
                    result.deleted += result.failed.length;
                    result.failed = [];
                } else {
                    const txt = await fallbackRes.text().catch(() => '');
                    console.warn(`[${sheetName}] ‚ö†Ô∏è Fallback DELETE fall√≥ (${fallbackRes.status})`);
                }
            } catch (fbErr) {
                console.warn(`[${sheetName}] ‚ö†Ô∏è Error en fallback DELETE:`, fbErr.message);
            }
        }

        return result;
    } catch (e) {
        console.error(`[${sheetName}] ‚ùå Error general:`, e.message);
        result.failed.push({ reason: e.message });
        return result;
    }
}

async function eliminarFilasTraspasosPorNombre(nombreBloqueRaw, opts = { useFilterFallback: true }) {
    const useFilterFallback = Boolean(opts.useFilterFallback);
    const result = { totalFound: 0, deleted: 0, failed: [] };

    function normalizeStr(s) {
        if (!s) return '';
        try {
            return s.toString().normalize('NFD').replace(/\p{Diacritic}/gu, '').replace(/[\u0300-\u036f]/g, '').toLowerCase().trim().replace(/\s+/g, ' ');
        } catch (e) {
            return s.toString().toLowerCase().trim().replace(/\s+/g, ' ');
        }
    }

    function extractNameFromRow(row) {
        if (!row || typeof row !== 'object') return '';
        const keys = Object.keys(row || {});
        for (const k of keys) {
            if (/nombre/i.test(k) || /folio/i.test(k)) {
                const val = row[k];
                if (val && val.toString().trim()) return val.toString();
            }
        }
        return (row.Nombre || row.Folio || row.nombre || row.folio || '').toString();
    }

    try {
        const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=traspasos');
        if (!res.ok) throw new Error(`No se pudieron cargar las filas (status ${res.status})`);
        const traspasos = filterMeaningfulRows(await res.json());

        const nombreNorm = normalizeStr(nombreBloqueRaw || '');
        const matches = traspasos.filter(r => {
            const candidate = extractNameFromRow(r);
            const candNorm = normalizeStr(candidate);
            return candNorm === nombreNorm || candNorm.includes(nombreNorm) || nombreNorm.includes(candNorm);
        });

        result.totalFound = matches.length;

        if (matches.length === 0) return result;

        for (const row of matches) {
            const rowId = row.row_id || row.rowId || row.id || row.ID || null;
            if (!rowId) {
                result.failed.push({ row, reason: 'missing_row_id' });
                continue;
            }

            let deleted = false;
            let lastError = null;
            for (let attempt = 1; attempt <= 3 && !deleted; attempt++) {
                try {
                    const delRes = await fetch(`https://sheetdb.io/api/v1/gdn5wqo960cey/row_id/${rowId}?sheet=traspasos`, { method: 'DELETE' });
                    if (delRes.ok) {
                        deleted = true;
                        result.deleted++;
                        break;
                    } else {
                        const status = delRes.status;
                        const body = await delRes.text().catch(() => '');
                        lastError = `status:${status} body:${body}`;
                        console.warn('eliminarFilasTraspasosPorNombre intento no ok', { attempt, rowId, status, body });
                    }
                } catch (e) {
                    lastError = e.message || String(e);
                    console.warn('eliminarFilasTraspasosPorNombre intento fallo', { attempt, rowId, err: lastError });
                }
                await new Promise(r => setTimeout(r, 200 * attempt));
            }
            if (!deleted) {
                result.failed.push({ rowId, reason: lastError });
            }
        }

        // Fallback: intento eliminar por filtro Nombre si hubieron fallos
        if (useFilterFallback && result.failed.length > 0) {
            try {
                const filterUrl = `https://sheetdb.io/api/v1/gdn5wqo960cey/Nombre/${encodeURIComponent(nombreBloqueRaw)}?sheet=traspasos`;
                const fallbackRes = await fetch(filterUrl, { method: 'DELETE' });
                if (fallbackRes.ok) {
                    console.info('eliminarFilasTraspasosPorNombre: fallback DELETE por Nombre tuvo √©xito');
                    // No podemos saber cu√°ntas elimin√≥ con seguridad; marcar como √©xito general
                    result.deleted += result.failed.length;
                    result.failed = [];
                } else {
                    const txt = await fallbackRes.text().catch(() => '');
                    console.warn('eliminarFilasTraspasosPorNombre: fallback DELETE fall√≥', fallbackRes.status, txt);
                }
            } catch (fbErr) {
                console.warn('eliminarFilasTraspasosPorNombre: error en fallback DELETE', fbErr);
            }
        }

        return result;
    } catch (e) {
        console.error('eliminarFilasTraspasosPorNombre error general:', e);
        return result;
    }
}

// ...existing code...    
// Buscar bloques por nombre
async function eliminarBloqueFacturaPorNombre(nombreBloque) {
    if (!nombreBloque || nombreBloque.trim() === '') {
        console.error('Nombre de bloque inv√°lido');
        alert('El nombre del bloque no es v√°lido.');
        return;
    }

    if (!confirm(`¬øSeguro que deseas eliminar el bloque "${nombreBloque}"?`)) return;

    try {
        console.log(`Iniciando eliminaci√≥n del bloque de FACTURAS: ${nombreBloque}`);
        
        // Eliminar de la hoja 'FACTURAS' en SheetDB
        const resumen = await eliminarFilasPorNombreYHoja(nombreBloque, 'FACTURAS', { useFilterFallback: true });
        console.log('Resumen de eliminaci√≥n:', resumen);

        // Eliminar localmente del array
        const idxLocal = bloquesFACTURAS.findIndex(b => normalizeKey(b.nombre) === normalizeKey(nombreBloque));
        if (idxLocal >= 0) {
            bloquesFACTURAS.splice(idxLocal, 1);
            console.log(`Bloque eliminado localmente. √çndice: ${idxLocal}`);
        }

        // Refrescar la visualizaci√≥n
        await actualizarBloquesFACTURAS();

        // Mostrar resumen al usuario
        const msg = `‚úÖ Registros encontrados: ${resumen.totalFound}. Eliminados: ${resumen.deleted}. Fallidos: ${resumen.failed.length}.`;
        console.log(msg);
        
        if (resumen.failed && resumen.failed.length > 0) {
            console.error('eliminarBloqueFacturaPorNombre: detalles de fallos =', resumen.failed);
            if (window.Swal && typeof Swal.fire === 'function') {
                await Swal.fire({ 
                    title: 'Eliminaci√≥n incompleta', 
                    html: `<div style="text-align:left">${msg}<br><pre style="text-align:left; font-size:11px;">${JSON.stringify(resumen.failed.slice(0,50), null, 2)}</pre></div>`, 
                    icon: 'warning', 
                    width: '800px' 
                });
            } else {
                alert(msg + '\nRevisa la consola para detalles.');
            }
        } else {
            if (window.Swal && typeof Swal.fire === 'function') {
                await Swal.fire('Eliminado exitosamente', msg, 'success');
            } else {
                alert(msg);
            }
        }
    } catch (e) {
        console.error('Error eliminando bloque de FACTURAS:', e);
        console.error('Stack trace:', e.stack);
        if (window.Swal && typeof Swal.fire === 'function') {
            await Swal.fire('Error', `Ocurri√≥ un error al eliminar el bloque: ${e.message}`, 'error');
        } else {
            alert(`Ocurri√≥ un error al eliminar el bloque. Revisa la consola para m√°s detalles.\nError: ${e.message}`);
        }
    }
}

async function eliminarBloqueFactura(idx, tipo = 'traspasos') {
    // Determinar si es traspasos o FACTURAS
    const bloquesArray = tipo === 'FACTURAS' ? bloquesFACTURAS : bloquestraspasos;
    const sheetName = tipo === 'FACTURAS' ? 'FACTURAS' : 'traspasos';
    
    if (!confirm(`¬øSeguro que deseas eliminar este bloque de ${tipo}?`)) return;
    const bloque = bloquesArray[idx];
    if (!bloque) return alert('Bloque no encontrado.');

    const nombreBloqueRaw = (bloque.nombre || bloque.Nombre || '').toString().trim();
    if (!nombreBloqueRaw) return alert('El bloque no tiene un nombre v√°lido.');

    // Llamar al helper para realizar la eliminaci√≥n en la hoja
    try {
        const resumen = await eliminarFilasPorNombreYHoja(nombreBloqueRaw, sheetName, { useFilterFallback: true });

        // Eliminar localmente y refrescar vista
        bloquesArray.splice(idx, 1);
        
        // Refrescar seg√∫n el tipo
        if (tipo === 'FACTURAS') {
            try { await actualizarBloquesFACTURAS(); } catch (e) { console.warn('actualizarBloquesFACTURAS error:', e); }
        } else {
            try { await actualizarBloquestraspasos(); } catch (e) { console.warn('actualizarBloquestraspasos error:', e); }
        }

        // Mostrar resumen al usuario
        const msg = `Registros encontrados: ${resumen.totalFound}. Eliminados: ${resumen.deleted}. Fallidos: ${resumen.failed.length}.`;
        if (resumen.failed && resumen.failed.length > 0) {
            console.error('eliminarBloqueFactura: detalles de fallos =', resumen.failed);
            if (window.Swal && typeof Swal.fire === 'function') {
                await Swal.fire({ title: 'Eliminaci√≥n incompleta', html: `<div style="text-align:left">${msg}<br><pre style="text-align:left">${JSON.stringify(resumen.failed.slice(0,50), null, 2)}</pre></div>`, icon: 'warning', width: '800px' });
            } else {
                alert(msg + '\nRevisa la consola para detalles.');
            }
        } else {
            if (window.Swal && typeof Swal.fire === 'function') {
                await Swal.fire('Eliminado', msg, 'success');
            } else {
                alert(msg);
            }
        }
    } catch (e) {
        console.error('Error eliminando bloque:', e);
        alert('Ocurri√≥ un error al eliminar el bloque. Revisa la consola para m√°s detalles.');
    }
}
document.getElementById('traspasosearchFolio').addEventListener('input', function() {
    mostrarBloquestraspasos(this.value);
});

// Al cargar la pesta√±a, carga los bloques desde SheetDB
document.querySelector('button[data-tab="traspasos"]').addEventListener('click', async () => {
    try {
        const res = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=traspasos');
        if (!res.ok) throw new Error('No se pudo cargar traspasos');
        const traspasos = filterMeaningfulRows(await res.json());
        bloquestraspasos = [];
        let grupos = {};
        traspasos.forEach(f => {
            // Agrupa por 'Nombre' (may√∫scula inicial)
            const grupo = f.Nombre || f.Folio || f["Fecha de Emisi√≥n"] || 'Sin nombre';
            if (!grupos[grupo]) grupos[grupo] = [];
            grupos[grupo].push(f);
        });
        for (const nombre in grupos) {
            bloquestraspasos.push({ nombre, datos: grupos[nombre] });
        }
        mostrarBloquestraspasos();
    } catch (e) {
        const contErr = document.getElementById('facturaGroupsContainer');
        if (contErr) {
            contErr.innerHTML = '<div class="alert alert-danger">No se pudo cargar traspasos guardadas.</div>';
        } else {
            console.warn('No se encontr√≥ `facturaGroupsContainer` para mostrar el error de carga de traspasos');
        }
    }
});

// Funci√≥n para limpiar la b√∫squeda y las llantas acumuladas
function limpiarBusquedaBloqueEnModo() {
    // Limpiar solo los campos de b√∫squeda de llanta, sin eliminar la estructura ni otros elementos
    // Adem√°s delegar en clearEverything para eliminar caches y timers que puedan repoblar datos
    try { clearEverything(); } catch (e) {}
    setTimeout(() => {
        // Limpiar solo valores y resultados, nunca eliminar la estructura de las barras buscadoras
        const inputCodigo = document.getElementById('inputBuscarLlantaCodigo');
        const inputDescripcion = document.getElementById('inputBuscarLlantaDescripcion');
        const inputCantidad = document.getElementById('inputBuscarLlantaCantidad');
        if (inputCodigo) inputCodigo.value = '';
        if (inputDescripcion) inputDescripcion.value = '';
        if (inputCantidad) inputCantidad.value = '1';
        // Limpiar autocompletados
        const autoCodigo = document.getElementById('autocompleteCodigoResultados');
        const autoDesc = document.getElementById('autocompleteDescripcionResultados');
        if (autoCodigo) { autoCodigo.innerHTML = ''; autoCodigo.style.display = 'none'; }
        if (autoDesc) { autoDesc.innerHTML = ''; autoDesc.style.display = 'none'; }
        // Limpiar resultado de b√∫squeda de llanta
        const resultado = document.getElementById('resultadoBusquedaLlanta');
        if (resultado) resultado.innerHTML = '';
        // Limpiar tabla de llantas seleccionadas
        const tablaLlantas = document.getElementById('tablaLlantasSeleccionadas');
        if (tablaLlantas) {
            const tb = tablaLlantas.getElementsByTagName('tbody')[0];
            if (tb) tb.innerHTML = '';
        }
        // Limpiar sugerencias de unidades
        const tablaSugerencias = document.getElementById('tablaUnidadesSugeridasBusqueda');
        if (tablaSugerencias) {
            const tbody = tablaSugerencias.tagName === 'TABLE' ? tablaSugerencias.getElementsByTagName('tbody')[0] : tablaSugerencias;
            if (tbody) tbody.innerHTML = '';
            else tablaSugerencias.innerHTML = '';
        }
        // Limpiar totales
        const totalLlantas = document.getElementById('totalLlantas');
        if (totalLlantas) {
            totalLlantas.style.display = 'none';
            totalLlantas.innerHTML = '';
        }
        // Limpiar resultados de b√∫squeda de bloques
        const resultadosBusqueda = document.getElementById('resultadosBusqueda');
        if (resultadosBusqueda) resultadosBusqueda.innerHTML = '';
        // Limpiar contadores
        const contadorTotal = document.getElementById('contadorTotalLlantasBloque');
        if (contadorTotal) contadorTotal.textContent = '0';
        // Limpiar bloques pendientes
        const contPendientes = document.getElementById('bloquesPendientesNuevo');
        if (contPendientes) contPendientes.innerHTML = '';
        const contPendientesModo = document.getElementById('bloquesPendientesNuevoModo');
        if (contPendientesModo) contPendientesModo.innerHTML = '';
        // Limpiar variables globales de acumulados
        try { llantasAcumuladasEnBloque = []; } catch (e) {}
        if (typeof actualizarTablaLlantasBloque === 'function') actualizarTablaLlantasBloque([]);
        // Limpiar tablas adicionales
        const tablasExtra = [
            'tablaDistribucionSugerida',
            'tablaPedidosApartados',
            'tablaPedidosConfirmados',
            'tablaUnidadesSugeridas'
        ];
        tablasExtra.forEach(id => {
            try {
                const el = document.getElementById(id);
                if (!el) return;
                const tb = el.tagName === 'TABLE' ? el.getElementsByTagName('tbody')[0] : el.querySelector('tbody');
                if (tb) tb.innerHTML = '';
                else el.innerHTML = '';
            } catch (e) {}
        });
        // Nunca eliminar ni modificar la estructura de las barras buscadoras de llantas
        // Si por error se eliminaron, volver a crear la barra buscadora
        if (!document.getElementById('busquedaLlantaRapid')) {
            if (typeof setupBusquedaLlantaEnPedidos === 'function') setupBusquedaLlantaEnPedidos();
        }
    }, 50);
}

// Funci√≥n para agregar bloques (VERSI√ìN CORREGIDA CON NORMALIZACION)
async function agregarBloqueEnModo(continuarAgregando = true) {
    const folioRaw = document.getElementById('inputBusquedaBloqueNuevo').value.trim();
    const folio = normalizeKey(folioRaw);
    const divResultado = document.getElementById('resultadoBusquedaBloqueNuevo');
      
    if (!folioRaw) {
        divResultado.innerHTML = `
            <div class="alert alert-warning">
                <i class="bi bi-exclamation-circle"></i> Por favor, ingrese un folio v√°lido.
            </div>`;
        return;
    }

    try {
        let llantasParaAgregar = [];
        
        console.log("=== AGREGAR BLOQUE - DIAGN√ìSTICO ===");
        console.log("Folio raw:", folioRaw);
        console.log("Folio normalizado:", folio);

        // 1. Buscar en traspasos recientes (en memoria)
        const traspasosRecientes = traspasosParaGuardar.filter(f => {
            const nombre = normalizeKey(f.Nombre || f.nombre || '');
            const fol = normalizeKey(f.Folio || f.folio || '');
            const match = nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
            if (match) console.log("‚úì MATCH en traspasos recientes:", f.Nombre || f.nombre, f.Folio || f.folio);
            return match;
        });
        if (traspasosRecientes.length > 0) {
            console.log("‚Üí Encontrado en traspasos recientes:", traspasosRecientes.length, "registros");
            llantasParaAgregar = llantasParaAgregar.concat(traspasosRecientes);
        }

        // 2. Buscar en FACTURAS
        try {
            const resEscaneadosEspeciales = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=FACTURAS');
            if (resEscaneadosEspeciales.ok) {
                const escaneadosEspeciales = filterMeaningfulRows(await resEscaneadosEspeciales.json());
                const escaneadosEspecialesDelFolio = escaneadosEspeciales.filter(r => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                });
                if (escaneadosEspecialesDelFolio.length > 0) {
                    console.log("‚Üí Encontrado en FACTURAS:", escaneadosEspecialesDelFolio.length, "registros");
                    llantasParaAgregar = llantasParaAgregar.concat(escaneadosEspecialesDelFolio);
                }
            }
        } catch (e) {
            console.warn("Error en FACTURAS:", e.message);
        }

        // 3. Buscar en traspasos (sheet)
        try {
            const resEscaneados = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=traspasos');
            if (resEscaneados.ok) {
                const escaneados = filterMeaningfulRows(await resEscaneados.json());
                const escaneadosDelFolio = escaneados.filter(r => {
                    const nombre = normalizeKey(r.Nombre || r.nombre || '');
                    const fol = normalizeKey(r.Folio || r.folio || '');
                    return nombre === folio || fol === folio || nombre.includes(folio) || fol.includes(folio);
                });
                if (escaneadosDelFolio.length > 0) {
                    console.log("‚Üí Encontrado en traspasos (sheet):", escaneadosDelFolio.length, "registros");
                    llantasParaAgregar = llantasParaAgregar.concat(escaneadosDelFolio);
                }
            }
        } catch (e) {
            console.warn("Error en traspasos (sheet):", e.message);
        }

        // 4. Buscar en bloques locales
        const bloquesFactura = bloquestraspasos.filter(b => {
            const nombreBloque = normalizeKey(b.nombre || '');
            return nombreBloque === folio || nombreBloque.includes(folio);
        });
        if (bloquesFactura.length > 0) {
            console.log("‚Üí Encontrado en bloques locales:", bloquesFactura.length, "bloques");
            for (const bloque of bloquesFactura) {
                llantasParaAgregar = llantasParaAgregar.concat(bloque.datos || []);
            }
        }
        
        console.log("=== RESULTADO FINAL DE B√öSQUEDA ===");
        console.log("Total llantas encontradas:", llantasParaAgregar.length);
        if (llantasParaAgregar.length > 0) {
            console.log("Primeras 3 llantas:", llantasParaAgregar.slice(0, 3));
        }

        // === FUNCI√ìN AUXILIAR: Normalizar c√≥digo + descripci√≥n para comparaci√≥n robusta ===
        const normalizarIdentificador = (codigo, descripcion) => {
            const codNorm = (codigo || '').toString().trim().toUpperCase();
            const descNorm = (descripcion || '').toString().trim().toUpperCase()
                .replace(/\s+/g, ' ')
                .replace(/[()]/g, '')
                .trim();
            return `${codNorm}|${descNorm}`;
        };

        // Set para marcar los identificadores guardados en este flujo.
        // Declarado aqu√≠ para que exista aunque no haya productos nuevos (evita ReferenceError en el modal).
        let codigosGuardados = new Set();

        if (llantasParaAgregar.length > 0) {
            // === DETECTAR PRODUCTOS NUEVOS (NO EN INVENTARIO) ===
            let productosNuevos = [];
            let productosYaExistentes = [];
            const identificadoresYaProcesados = new Set(); // Evitar duplicados dentro del mismo bloque
            
            for (const llanta of llantasParaAgregar) {
                const codigo = (llanta.C√≥digo || llanta.codigo || llanta.clave || '').toString() || null;
                const descripcion = llanta.Descripci√≥n || llanta.descripcion || 'Sin descripci√≥n';
                if (!codigo) continue;
                
                // VALIDACI√ìN 1: Crear identificador √∫nico (c√≥digo + descripci√≥n normalizado)
                const identificador = normalizarIdentificador(codigo, descripcion);
                
                // VALIDACI√ìN 2: Verificar si ya fue procesado en este bloque (evitar duplicados)
                if (identificadoresYaProcesados.has(identificador)) {
                    console.log(`[‚è≠Ô∏è SALTADO] ${codigo} | ${descripcion} ya fue procesado en este bloque (duplicado)`);
                    continue;
                }
                
                // VALIDACI√ìN 3: Verificar si existe en INVENTARIO o ya est√° en el bloque acumulado
                const codNorm = (codigo || '').toString().trim().toUpperCase();
                const descNorm = (descripcion || '').toString().trim().toUpperCase().replace(/\s+/g, ' ').replace(/[()]/g, '').trim();

                const existeEnInventarioPorIdentificador = INVENTARIO.some(item => {
                    const itemIdent = normalizarIdentificador(
                        item.clave || item.ID || item.C√≥digo || '',
                        item.descripcion || item.Descripci√≥n || ''
                    );
                    return itemIdent === identificador;
                });

                const existeEnInventarioPorCodigo = INVENTARIO.some(item => {
                    const itemCode = (item.clave || item.Clave || item.ID || item.C√≥digo || item.codigo || '').toString().trim().toUpperCase();
                    return itemCode && itemCode === codNorm;
                });

                const existeEnInventarioPorDescripcion = INVENTARIO.some(item => {
                    const itemDesc = (item.descripcion || item.Descripci√≥n || item.nombre || '').toString().trim().toUpperCase().replace(/\s+/g, ' ').replace(/[()]/g, '').trim();
                    return itemDesc && (itemDesc.includes(descNorm) || descNorm.includes(itemDesc));
                });

                const existeEnBloqueAcumulado = Array.isArray(llantasAcumuladasEnBloque) && llantasAcumuladasEnBloque.some(item => {
                    const itemIdent = normalizarIdentificador(
                        item.C√≥digo || item.codigo || item.clave || item.Clave || item.ID || '',
                        item.Descripci√≥n || item.descripcion || item.nombre || ''
                    );
                    const itemCode = (item.C√≥digo || item.codigo || item.clave || item.Clave || item.ID || '').toString().trim().toUpperCase();
                    const itemDesc = (item.Descripci√≥n || item.descripcion || item.nombre || '').toString().trim().toUpperCase().replace(/\s+/g, ' ').replace(/[()]/g, '').trim();
                    return itemIdent === identificador || (itemCode && itemCode === codNorm) || (itemDesc && (itemDesc.includes(descNorm) || descNorm.includes(itemDesc)));
                });

                const existeEnINVENTARIO = existeEnInventarioPorIdentificador || existeEnInventarioPorCodigo || existeEnInventarioPorDescripcion || existeEnBloqueAcumulado;
                
                if (!existeEnINVENTARIO) {
                    // Es nuevo: agregar a procesar
                    productosNuevos.push(llanta);
                    identificadoresYaProcesados.add(identificador);
                    console.log(`[‚úÖ NUEVO] ${codigo} | ${descripcion} ser√° agregado al inventario`);
                } else {
                    // Ya existe en inventario
                    productosYaExistentes.push(llanta);
                    identificadoresYaProcesados.add(identificador);
                    console.log(`[‚ÑπÔ∏è EXISTENTE] ${codigo} | ${descripcion} ya est√° en inventario`);
                }
            }
            
            // === AGREGAR PRODUCTOS NUEVOS AL INVENTARIO (persistir en SheetDB) ===
            let productosAgregadosAlINVENTARIO = 0;
            const guardadosConExito = [];
            
            // FUNCI√ìN HELPER: Calcular valores por defecto si fallan los c√°lculos precisos
            const calcularValoresPorDefecto = (descripcion) => {
                const desc = (descripcion || '').toUpperCase();
                let volumenDefault = 0.0100; // 0.01 m¬≥ por defecto
                let pesoDefault = 10; // 10 kg por defecto
                
                // Ajustes seg√∫n tipo de llanta detectada
                if (desc.includes('AGRICOLA') || desc.includes('TRACTOR')) {
                    volumenDefault = 0.0800; pesoDefault = 60;
                } else if (desc.includes('INDUSTRIAL') || desc.includes('OTR')) {
                    volumenDefault = 0.0600; pesoDefault = 50;
                } else if (desc.includes('CAMION') || desc.includes('11R') || desc.includes('22.5')) {
                    volumenDefault = 0.0500; pesoDefault = 80;
                } else if (desc.includes('4X4') || desc.includes('SUV')) {
                    volumenDefault = 0.0300; pesoDefault = 25;
                } else if (desc.includes('SPORT') || desc.includes('RACING')) {
                    volumenDefault = 0.0150; pesoDefault = 12;
                }
                
                return { volumen: volumenDefault, peso: pesoDefault };
            };

            if (productosNuevos.length > 0) {
                codigosGuardados = new Set(); // Evitar duplicados en este ciclo (reiniciar para este ciclo)
                
                for (const producto of productosNuevos) {
                    try {
                        const codigo = (producto.C√≥digo || producto.codigo || producto.clave || '').toString();
                        const descripcion = producto.Descripci√≥n || producto.descripcion || 'Sin descripci√≥n';

                        // Crear identificador √∫nico (c√≥digo + descripci√≥n normalizado)
                        const identificadorProducto = normalizarIdentificador(codigo, descripcion);

                        // VALIDACI√ìN CR√çTICA 1: Si ya fue guardado en este ciclo, saltar
                        if (codigosGuardados.has(identificadorProducto)) {
                            console.warn(`[‚ö†Ô∏è DUPLICADO DETECTADO] ${codigo} | ${descripcion} ya fue guardado en este ciclo. Saltando...`);
                            continue;
                        }

                        // SEGUNDA VERIFICACI√ìN: Verificar NUEVAMENTE si existe en INVENTARIO (por si cambi√≥)
                        const existeAhoraEnINVENTARIO = INVENTARIO.some(item => {
                            const itemIdent = normalizarIdentificador(
                                item.clave || item.ID || item.C√≥digo || '',
                                item.descripcion || item.Descripci√≥n || ''
                            );
                            return itemIdent === identificadorProducto;
                        });
                        if (existeAhoraEnINVENTARIO) {
                            console.log(`[‚ÑπÔ∏è EXISTENTE] ${codigo} | ${descripcion} ya est√° en inventario. Saltando para evitar duplicado...`);
                            codigosGuardados.add(identificadorProducto);
                            continue;
                        }

                        console.log(`[AGREGAR PRODUCTO] Procesando: ${codigo} - ${descripcion}`);

                        // Calcular volumen y peso si no los tiene (USANDO LA MISMA L√ìGICA DE calcularVolumenINVENTARIO)
                        let volumen = parseNumber(producto.Volumen || producto.volumen || 0);
                        let peso = parseNumber(producto.Peso || producto.peso || 0);

                        if (!volumen || volumen === 0) {
                            try {
                                // Usar la misma l√≥gica de calcularVolumenINVENTARIO para consistencia
                                let desc = (descripcion || '').replace(/[()]/g, '').toUpperCase();
                                
                                // Patrones para diferentes tipos de llantas (id√©nticos a calcularVolumenINVENTARIO)
                                const patrones = [
                                    {
                                        regex: /^(\d{2,3})X(\d{1,2}\.\d{1,2}|\d{1,2})\s*R?(\d{2})/i,
                                        calc: (m) => {
                                            const overallIn = Number(m[1]);
                                            const widthIn = Number(m[2]);
                                            const rimIn = Number(m[3]);
                                            const ancho = widthIn * 25.4 / 1000;
                                            const rin = rimIn * 0.0254;
                                            let perfil = 0.65;
                                            if (overallIn > rimIn && widthIn > 0) {
                                                perfil = (overallIn - rimIn) / (2 * widthIn);
                                                if (perfil <= 0 || !isFinite(perfil)) perfil = 0.65;
                                            }
                                            return { ancho, perfil, rin, tipo: '4X4' };
                                        }
                                    },
                                    {
                                        regex: /^(\d{3})\s*R(\d{2})\s*.*?(?:\((\d{1,2})\))?.*?(\d{3}\/\d{3}R)?/i,
                                        calc: (m) => ({ ancho: Number(m[1]) / 1000, perfil: 0.82, rin: Number(m[2]) * 0.0254, tipo: 'COMERCIAL', capas: m[3] ? Number(m[3]) : 8 })
                                    },
                                    {
                                        regex: /^(\d+\.?\d*)L-(\d+)\s*(?:IND|INDUSTRIAL)?\s*.*?(?:\((\d{1,2})\))?.*?(L[2-5]|SEVERE)?/i,
                                        calc: (m) => { const ancho = Number(m[1]) * 25.4 / 1000; const rin = Number(m[2]) * 0.0254; const capas = m[3] ? Number(m[3]) : 12; const esSevere = m[4]?.includes('SEVERE') || false; return { ancho, perfil: 0.90, rin, tipo: 'INDUSTRIAL', capas, factorAdicional: esSevere ? 1.1 : 1.0 }; }
                                    },
                                    {
                                        regex: /^(\d{2})L-(\d{2})\s*(?:\((\d{1,2})\))?\s*((?:SKS|F3|IND|AGRO|CT).*)?/i,
                                        calc: (m) => { const ancho = Number(m[1]) * 25.4 * 1.15 / 1000; const rin = Number(m[2]) * 0.0254; const capas = m[3] ? Number(m[3]) : 12; const tipo = m[4]?.includes('IND') || m[4]?.includes('SKS') ? 'INDUSTRIAL' : m[4]?.includes('AGRO') ? 'AGRICOLA' : 'INDUSTRIAL'; return { ancho, perfil: 0.90, rin, tipo, capas }; }
                                    },
                                    {
                                        regex: /^[P]?(\d{3})[\/\s\-](\d{2})[\/\s\-]?R?(\d{2})/,
                                        calc: (m) => ({ ancho: Number(m[1]) / 1000, perfil: Number(m[2]) / 100, rin: Number(m[3]) * 0.0254, tipo: 'AUTO' })
                                    },
                                    {
                                        regex: /^(\d{2,3})R(\d{2}\.\d*)|(^\d{3}\/\d{2}R\d{2}\.\d*)/,
                                        calc: (m) => ({ ancho: Number(m[1] || m[3]) * 25.4 / 1000, perfil: 0.80, rin: Number(m[2] || m[4]) * 0.0254, tipo: 'CAMION' })
                                    },
                                    {
                                        regex: /^(\d{1,2}\.?\d*)[\/\-](?:(\d{2})[\/\-])?(\d{2})/,
                                        calc: (m) => ({ ancho: Number(m[1]) * 25.4 / 1000, perfil: Number(m[2] || 90) / 100, rin: Number(m[3]) * 0.0254, tipo: 'AGRICOLA' })
                                    }
                                ];

                                let medidas = null;
                                let tipoLlanta = 'AUTO';

                                // Determinar tipo por descripci√≥n
                                if (desc.includes('AGRICOLA') || desc.includes('TRACTOR') || desc.includes('AGRO') || /\bR1\b/.test(desc)) {
                                    tipoLlanta = 'AGRICOLA';
                                } else if (desc.includes('INDUSTRIAL') || desc.includes('OTR') || /\bE[3-4]\/L[3-5]\b/.test(desc) || /\b\d{2,2}\.\d{2}-\d{2}\b/.test(desc) || /\b\d{2,2}-\d{2,2}\.?\d{0,1}\b/.test(desc) || /\bL-?5\b/.test(desc)) {
                                    tipoLlanta = 'INDUSTRIAL';
                                } else if (desc.includes('CAMION') || /\b\d{2,3}R\d{2}\.\d{1,2}\b/.test(desc) || /\b\d{3}\/\d{2}R\d{2}\.\d{1,2}\b/.test(desc) || desc.match(/^11R22\.5/)) {
                                    tipoLlanta = 'CAMION';
                                } else if (desc.includes('4X4')) {
                                    tipoLlanta = '4X4';
                                }

                                // Buscar patr√≥n coincidente
                                for (const patron of patrones) {
                                    const match = desc.match(patron.regex);
                                    if (match) {
                                        medidas = patron.calc(match);
                                        if (medidas && medidas.tipo) tipoLlanta = medidas.tipo;
                                        break;
                                    }
                                }

                                if (medidas) {
                                    let factorCorreccion, margenLogisticoTipo, volumen_m3;
                                    
                                    if (tipoLlanta === 'AGRICOLA') {
                                        factorCorreccion = desc.includes('L-') ? 1.0 : 1.0;
                                        margenLogisticoTipo = 1.040;
                                        let alturaFlanco = medidas.perfil * medidas.ancho;
                                        let diametroExterno = (medidas.rin + 2 * alturaFlanco) * 1.10;
                                        volumen_m3 = Math.PI * Math.pow(diametroExterno/2, 2) * medidas.ancho * factorCorreccion * margenLogisticoTipo;
                                        if (medidas.capas && medidas.capas > 12) volumen_m3 *= (1 + (medidas.capas - 12) * 0.025);
                                    } else if (tipoLlanta === 'INDUSTRIAL') {
                                        factorCorreccion = desc.includes('SKS') ? 1.10 : 1.10;
                                        margenLogisticoTipo = 1.50;
                                        let alturaFlanco = medidas.perfil * medidas.ancho;
                                        let diametroExterno = (medidas.rin + 2 * alturaFlanco) * 1.09;
                                        volumen_m3 = Math.PI * Math.pow(diametroExterno/2, 2) * medidas.ancho * factorCorreccion * margenLogisticoTipo;
                                        if (desc.match(/SKS-[1-3]|L-5/)) volumen_m3 *= 1.12;
                                        if (medidas.capas && medidas.capas > 12) volumen_m3 *= (1 + (medidas.capas - 12) * 0.02);
                                    } else if (tipoLlanta === 'CAMION') {
                                        factorCorreccion = 1.20;
                                        margenLogisticoTipo = 1.20;
                                        let alturaFlanco = medidas.perfil * medidas.ancho;
                                        let diametroExterno = medidas.rin + 2 * alturaFlanco;
                                        volumen_m3 = Math.PI * Math.pow(diametroExterno/2, 2) * medidas.ancho * factorCorreccion * margenLogisticoTipo;
                                    } else if (tipoLlanta === '4X4') {
                                        factorCorreccion = 1.45;
                                        margenLogisticoTipo = 1.22;
                                        let alturaFlanco = medidas.perfil * medidas.ancho;
                                        let diametroExterno = medidas.rin + 2 * alturaFlanco;
                                        volumen_m3 = Math.PI * Math.pow(diametroExterno/2, 2) * medidas.ancho * factorCorreccion * margenLogisticoTipo;
                                    } else {
                                        factorCorreccion = 1.10;
                                        margenLogisticoTipo = 1.10;
                                        let alturaFlanco = medidas.perfil * medidas.ancho;
                                        let diametroExterno = medidas.rin + 2 * alturaFlanco;
                                        volumen_m3 = Math.PI * Math.pow(diametroExterno/2, 2) * medidas.ancho * factorCorreccion * margenLogisticoTipo;
                                    }
                                    
                                    volumen = volumen_m3;
                                    console.log(`[VOLUMEN CALCULADO] ${codigo}: ${volumen.toFixed(4)} m¬≥ (tipo: ${tipoLlanta})`);
                                }
                            } catch (e) {
                                console.warn('[ERROR VOLUMEN]', e);
                            }
                        }

                        if (!peso || peso === 0) {
                            try {
                                // Usar la misma l√≥gica COMPLETA de calcularPesosINVENTARIO para m√°xima consistencia
                                let desc = (descripcion || '').toUpperCase();
                                
                                const patrones = [
                                    {
                                        regex: /^(\d{3})[\s\/](\d{2})[\s\/]?R(\d{2})/i,
                                        calc: (m, desc = '') => {
                                            const ancho = Number(m[1]); const perfil = Number(m[2]); const rin = Number(m[3]);
                                            const base = (ancho * perfil/100 * rin/25.4) * 0.2;
                                            let factor = 1.0;
                                            if (desc.includes('SUV') || desc.includes('CAMIONETA')) factor *= 0.90;
                                            if (desc.includes('PERFOR')) factor *= 0.90; if (desc.includes('AGATE')) factor *= 0.90;
                                            if (desc.includes('BLACKHAWK')) factor *= 1.90; if (desc.includes('EFFICIENT')) factor *= 0.90;
                                            if (desc.includes('ANTARES')) factor *= 0.90; if (desc.includes('ATLAS')) factor *= 1.00;
                                            if (desc.includes('CACHLAND')) factor *= 0.90; if (desc.includes('DOUBLEKING')) factor *= 0.90;
                                            if (desc.includes('FRONWAY')) factor *= 0.90; if (desc.includes('KAPSEN')) factor *= 0.90;
                                            if (desc.includes('LINGLONG')) factor *= 0.90; if (desc.includes('MAXTREK')) factor *= 0.90;
                                            if (desc.includes('MIRAGE')) factor *= 0.90; if (desc.includes('SAFERICH')) factor *= 0.90;
                                            if (desc.includes('SAILUN')) factor *= 0.90; if (desc.includes('AT') || desc.includes('ALL TERRAIN')) factor *= 0.90;
                                            if (desc.includes('MT') || desc.includes('MUD TERRAIN')) factor *= 0.90;
                                            if (desc.includes('SPORT') || desc.includes('RACING')) factor *= 0.90;
                                            return { peso: base * factor, tipo: desc.includes('SUV') || desc.includes('CAMIONETA') ? 'SUV' : 'AUTO' };
                                        }
                                    },
                                    {
                                        regex: /^(\d{2})R(\d{2}\.?\d*)/i,
                                        calc: (m, desc = '') => {
                                            const ancho = Number(m[1]) * 25.4; const rin = Number(m[2]);
                                            const base = (ancho * 0.8 * rin/25.4) * 0.39;
                                            let factor = 1.50;
                                            if (desc.includes('TRACCION')) factor *= 0.90; if (desc.includes('DIRECCION')) factor *= 0.90;
                                            if (desc.includes('MIXTA')) factor *= 0.90; if (desc.includes('MINERA')) factor *= 0.50;
                                            return { peso: base * factor, tipo: 'CAMION' };
                                        }
                                    },
                                    {
                                        regex: /^(\d+\.\d+)-(\d{2})(?:\s*([A-Z0-9\-]+))?/i,
                                        calc: (m, desc) => {
                                            const ancho = Number(m[1]) * 25.4; const rin = Number(m[2]);
                                            const base = (ancho * rin/25.4) * 0.4;
                                            const esConvencional = desc.includes('CONVENCIONAL');
                                            const esAgro = /\bAGRO\b|\bAGRICOL|\bFARM\b/i.test(desc) || desc.includes('AG');
                                            const esTL = /\bTL\b|\bTUBELESS\b/i.test(desc);
                                            let factor = esConvencional ? 1.2 : 1.0;
                                            if (esAgro) factor *= 2.10; if (esTL) factor *= 0.98;
                                            const tipo = esAgro ? 'AGRICOLA' : (esConvencional ? 'CONVENCIONAL' : 'AUTO');
                                            return { peso: base * factor, tipo: tipo };
                                        }
                                    },
                                    {
                                        regex: /^(\d{3})[\s\/]R(\d{2})(?:\s|$)/i,
                                        calc: (m, desc = '') => {
                                            const anchoMm = Number(m[1]); const rin = Number(m[2]);
                                            const base = (anchoMm * rin) * 0.055;
                                            let factor = 1.0;
                                            if (desc.includes('DOUBLEKING') || desc.includes('DK228')) factor *= 0.95;
                                            if (desc.includes('MICHELIN') || desc.includes('PIRELLI') || desc.includes('CONTINENTAL')) factor *= 1.15;
                                            if (desc.includes('SPORT') || desc.includes('RACING')) factor *= 1.10;
                                            if (desc.includes('ECO') || desc.includes('ECONOMY')) factor *= 0.90;
                                            const cargaMatch = desc.match(/(\d{3})\/(\d{3})R/);
                                            if (cargaMatch) { const indice = Number(cargaMatch[1]); if (indice > 100) factor *= 1.08; }
                                            return { peso: base * factor, tipo: 'AUTO' };
                                        }
                                    },
                                    {
                                        regex: /^(\d{2,3})[Xx](\d{1,2}\.?\d*)[\s-]?R(\d{2})/i,
                                        calc: (m, desc = '') => {
                                            const diamIn = Number(m[1]); const anchoIn = Number(m[2]); const rin = Number(m[3]);
                                            const anchoMm = anchoIn * 25.4;
                                            const base = (anchoMm * (rin / 25.4)) * 0.45;
                                            let factor = 1.0;
                                            if (desc.includes('MT') || desc.includes('MUD TERRAIN')) factor *= 1.15;
                                            if (desc.includes('AT') || desc.includes('ALL TERRAIN')) factor *= 1.05;
                                            if (desc.includes('HEAVY DUTY') || desc.includes('HD')) factor *= 1.30;
                                            if (desc.includes('REFORZADA') || desc.includes('REINFORCED')) factor *= 1.25;
                                            return { peso: base * factor, tipo: 'TODO_TERRENO' };
                                        }
                                    },
                                    {
                                        regex: /^(\d+(?:\.\d+)?)-(\d+\.?\d*)\s*(IND|AG)?/i,
                                        calc: (m, desc = '') => {
                                            const ancho = Number(m[1]) * 25.4; const rin = Number(m[2]);
                                            const base = ancho * rin/25.4 * 0.6;
                                            let tipo, factorBase;
                                            if (desc.includes('MINERIA') || desc.includes('MINING')) {
                                                tipo = 'MINERIA'; factorBase = 0.20;
                                            } else if (desc.includes('AG') || desc.includes('AGRICOLA') || desc.includes('FARM')) {
                                                tipo = 'AGRICOLA'; factorBase = 2.00;
                                            } else {
                                                tipo = 'INDUSTRIAL'; factorBase = 0.50;
                                            }
                                            let factorAdicional = 1.0;
                                            if (desc.includes('HEAVY DUTY') || desc.includes('HD')) factorAdicional *= 0.50;
                                            if (desc.includes('L5') || desc.includes('ROCK')) factorAdicional *= 0.50;
                                            if (desc.includes('ESPECIAL') || desc.includes('SPECIAL')) factorAdicional *= 0.50;
                                            if (desc.includes('REFORZADA') || desc.includes('REINFORCED')) factorAdicional *= 0.50;
                                            return { peso: base * factorBase * factorAdicional, tipo: tipo };
                                        }
                                    },
                                    {
                                        regex: /(\d{3})\/(\d{2})R(\d{2})\s+\w+\s+(\d{3})/i,
                                        calc: (m, desc = '') => {
                                            const ancho = Number(m[1]); const perfil = Number(m[2]); const rin = Number(m[3]);
                                            const indice = Number(m[4]);
                                            const base = (ancho * perfil/100 * rin/25.4) * 0.25;
                                            let factor = indice > 100 ? 1.4 : 1;
                                            if (desc.includes('XL') || desc.includes('EXTRA LOAD')) factor *= 0.50;
                                            if (desc.includes('REFORZADA') || desc.includes('REINFORCED')) factor *= 0.50;
                                            if (desc.includes('HEAVY DUTY') || desc.includes('HD')) factor *= 0.50;
                                            if (desc.includes('COMERCIAL') || desc.includes('COMMERCIAL')) factor *= 0.50;
                                            return { peso: base * factor, tipo: 'CARGA_ALTA' };
                                        }
                                    }
                                ];

                                let resultado = null;
                                for (const patron of patrones) {
                                    const match = desc.match(patron.regex);
                                    if (match) {
                                        resultado = patron.calc(match, desc);
                                        break;
                                    }
                                }

                                if (resultado && resultado.peso > 0) {
                                    let pesoBase = resultado.peso;
                                    let tipoBase = resultado.tipo || 'AUTO';

                                    const factoresAjuste = {
                                        'XL': 0.50, 'RF': 0.50, 'PR': 0.50, 'SKS': 0.50, 'L5': 0.50,
                                        'SOLID': 0.50, 'HT': 0.50, 'AT': 0.50, 'MT': 0.50, 'TRACCION': 0.50,
                                        'DIRECCION': 0.50, 'COMERCIAL': 0.50, 'PERFOR': 0.50, 'EFFICIENT': 0.50, 'MIXTA': 0.50
                                    };

                                    let factorTotal = 1.0;
                                    for (const [clave, factor] of Object.entries(factoresAjuste)) {
                                        if (desc.includes(clave)) factorTotal *= factor;
                                    }

                                    const capasMatch = desc.match(/\((\d{1,2})\)/);
                                    if (capasMatch) {
                                        const capas = Number(capasMatch[1]);
                                        if (capas > 8) factorTotal *= (1 + (capas-8)*0.05);
                                    }

                                    if (desc.includes('STEEL')) factorTotal *= 0.50;
                                    if (desc.includes('RADIAL')) factorTotal *= 0.50;
                                    if (desc.includes('NYLON')) factorTotal *= 0.50;

                                    peso = pesoBase * factorTotal;
                                    peso = Math.round(peso * 100) / 100;
                                    console.log(`[PESO CALCULADO] ${codigo}: ${peso.toFixed(2)} kg (tipo: ${tipoBase})`);
                                }
                            } catch (e) {
                                console.warn('[ERROR PESO]', e);
                            }
                        }

                        // Determinar 'linea' intentando varias keys y, si no hay, inferir desde la descripci√≥n
                        const lineaFromFields = (producto.Linea || producto.linea || producto['L√≠nea'] || producto.Line || producto.line || '');
                        const inferLineaFromDescripcion = (desc) => {
                            if (!desc) return '';
                            const d = desc.toUpperCase();

                            // Reglas expl√≠citas por marca/patr√≥n
                            const mapping = {
                                'CHAOYANG': 'MOTCG',
                                'MAXXIS': 'MOTMX',
                                'EPSILON': 'MOTEP',
                                'BLACKHAWK': 'AUTO',
                                'BROADPEAK': 'AUTO',
                                'DOUBLEKING': 'OFERT'
                            };

                            for (const key of Object.keys(mapping)) {
                                if (d.includes(key)) return mapping[key];
                            }

                            // Doubleking con c√≥digos espec√≠ficos -> reglas especiales
                            if (/DK208/i.test(d)) return 'OFESL';
                            if (/DK259/i.test(d)) return 'OFERT';

                            // Detectar formatos de moto (ej: 80/100-21, 90/90-18) -> asignar prefijo MOT
                            const isMoto = /\b\d{2,3}[\/]\d{2,3}-\d{2}\b|\b90\/90-18\b|\b80\/100-21\b/i.test(d) || /\bMOTC?G?\b/.test(d);
                            if (isMoto) {
                                // intentar detectar marca para moto
                                if (d.includes('CHAOYANG')) return 'MOTCG';
                                if (d.includes('MAXXIS')) return 'MOTMX';
                                if (d.includes('EPSILON')) return 'MOTEP';
                                return 'MOTO';
                            }

                            // Si contiene formato de cami√≥n/industrial, marcar CAMION
                            if (/\b11R|\b22\.5|\b295\/|\b315\//.test(d)) return 'CAMION';

                            // Fallback: tomar la primera palabra alfab√©tica relevante
                            const tokens = d.split(/\s+/);
                            for (const t of tokens) {
                                if (/^\d/.test(t)) continue; // saltar tama√±os
                                const clean = t.replace(/[^A-Z√ë&]/g, '');
                                if (clean.length >= 3) return clean;
                            }

                            return '';
                        };
                        const lineaVal = lineaFromFields || inferLineaFromDescripcion(descripcion) || 'Sin l√≠nea';

                        // ASEGURAR VALORES DE VOLUMEN Y PESO - Validar que siempre tengan n√∫meros v√°lidos
                        let volumenFinal = volumen;
                        let pesoFinal = peso;

                        // Si volumen sigue siendo 0 o no es v√°lido despu√©s del c√°lculo, intenta una √∫ltima vez
                        if (!volumenFinal || volumenFinal === 0 || isNaN(volumenFinal)) {
                            console.warn(`[‚ö†Ô∏è VOLUMEN INV√ÅLIDO] C√≥digo: ${codigo}, usando valor por defecto...`);
                            const defaults = calcularValoresPorDefecto(descripcion);
                            volumenFinal = defaults.volumen;
                        }

                        // Si peso sigue siendo 0 o no es v√°lido despu√©s del c√°lculo, intenta una √∫ltima vez
                        if (!pesoFinal || pesoFinal === 0 || isNaN(pesoFinal)) {
                            console.warn(`[‚ö†Ô∏è PESO INV√ÅLIDO] C√≥digo: ${codigo}, usando valor por defecto...`);
                            const defaults = calcularValoresPorDefecto(descripcion);
                            pesoFinal = defaults.peso;
                        }
                        // Intentar forzar c√°lculo usando funciones auxiliares (siempre preferir c√°lculo consistente)
                        try {
                            const volCalc = await calcularVolumenLlanta(descripcion || '');
                            if (volCalc && !isNaN(volCalc) && Number(volCalc) > 0) volumenFinal = Number(volCalc);
                        } catch (e) {
                            console.warn('[ERROR CALC VOLUMEN AUX]', e);
                        }
                        try {
                            const pesoCalc = await calcularPesoLlanta(descripcion || '');
                            if (pesoCalc && !isNaN(pesoCalc) && Number(pesoCalc) > 0) pesoFinal = Number(pesoCalc);
                        } catch (e) {
                            console.warn('[ERROR CALC PESO AUX]', e);
                        }

                        // Validar que SIEMPRE tenga valores positivos o al menos con los defaults
                        volumenFinal = Math.max(0.0100, Number(volumenFinal) || 0.0100);
                        pesoFinal = Math.max(5, Number(pesoFinal) || 10);

                        console.log(`[VALORES FINALES] ${codigo}: Volumen=${volumenFinal.toFixed(4)}m¬≥, Peso=${pesoFinal.toFixed(2)}kg`);

                        // Guardar SIN CAMBIOS en la escritura - mantener exactamente como vienen
                        const nuevoProducto = {
                            clave: codigo,
                            descripcion: producto.Descripci√≥n || producto.descripcion || descripcion,
                            volumen: volumenFinal.toFixed(4),
                            peso: pesoFinal.toFixed(2),
                            valor: parseNumber(producto.Valor || producto.valor || 0).toFixed(2),
                            linea: lineaVal
                        };

                        // Preservar campos originales sin modificar (si existen)
                        if (producto.C√≥digo) nuevoProducto.C√≥digo = producto.C√≥digo;
                        if (producto.Descripci√≥n) nuevoProducto.Descripci√≥n = producto.Descripci√≥n;
                        if (producto.Volumen) nuevoProducto.Volumen = producto.Volumen;
                        if (producto.Peso) nuevoProducto.Peso = producto.Peso;
                        if (producto.Valor) nuevoProducto.Valor = producto.Valor;
                        if (producto.L√≠nea) nuevoProducto.L√≠nea = producto.L√≠nea;

                        console.log('[OBJETO A GUARDAR]', nuevoProducto);
                        console.log(`[‚úÖ CONFIRMACI√ìN] ${codigo} tendr√° volumen=${nuevoProducto.volumen}m¬≥ y peso=${nuevoProducto.peso}kg`);

                        // Intentar guardar en SheetDB (POST) y s√≥lo si es exitoso lo consideramos agregado
                        let guardadoEnSheetDB = false;
                        for (let intento = 1; intento <= 3; intento++) {
                            try {
                                const respuesta = await fetch('https://sheetdb.io/api/v1/gdn5wqo960cey?sheet=INVENTARIO', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ data: [nuevoProducto] })
                                });

                                if (respuesta.ok) {
                                    console.log(`[‚úÖ GUARDADO] ${codigo} en SheetDB`);
                                    guardadoEnSheetDB = true;
                                    break;
                                } else {
                                    console.warn(`[‚ö†Ô∏è RESPUESTA ${respuesta.status}] intentando guardar ${codigo}`);
                                }
                            } catch (err) {
                                console.warn('[ERROR POST]', err.message || err);
                            }
                            // Espera breve antes de reintentar
                            await new Promise(r => setTimeout(r, 400));
                        }

                        if (guardadoEnSheetDB) {
                            guardadosConExito.push(nuevoProducto);
                            codigosGuardados.add(identificadorProducto); // Marcar como guardado para evitar duplicados (c√≥digo + descripci√≥n)
                            // Verificaci√≥n: confirmar que siempre tiene valores
                            if (!nuevoProducto.volumen || nuevoProducto.volumen === '0.0000' || nuevoProducto.peso === '0.00') {
                                console.error(`[‚ùå CR√çTICO] ${codigo} | ${descripcion} se guard√≥ pero sin volumen/peso v√°lidos. Vol=${nuevoProducto.volumen}, Peso=${nuevoProducto.peso}`);
                            } else {
                                console.log(`[‚úÖ VALIDADO] ${codigo} | ${descripcion} guardado correctamente con Vol=${nuevoProducto.volumen}m¬≥, Peso=${nuevoProducto.peso}kg`);
                            }
                        } else {
                            console.warn(`[NO GUARDADO] ${codigo} | ${descripcion} no se pudo persistir en SheetDB`);
                        }
                    } catch (e) {
                        console.error('[ERROR GENERAL]', e);
                    }
                }
                // Si hubo guardados en SheetDB, recargar INVENTARIO desde el servidor para confirmar
                if (guardadosConExito.length > 0) {
                    try {
                        await fetchINVENTARIO(); // recarga desde SheetDB y llama renderINVENTARIO()
                        productosAgregadosAlINVENTARIO = guardadosConExito.length;
                    } catch (e) {
                        console.warn('Guardados localmente pero no se pudo recargar INVENTARIO:', e);
                        // Si no pudimos recargar, a√±adir al array local para evitar p√©rdida temporal
                        for (const p of guardadosConExito) INVENTARIO.push(p);
                        productosAgregadosAlINVENTARIO = guardadosConExito.length;
                    }
                }
            }
            
            // Acumular las nuevas llantas con las existentes (evitar duplicados por c√≥digo+descripci√≥n)
            if (!Array.isArray(llantasAcumuladasEnBloque)) llantasAcumuladasEnBloque = [];
            for (const l of llantasParaAgregar) {
                const idL = normalizarIdentificador(l.C√≥digo || l.codigo || l.clave || '', l.Descripci√≥n || l.descripcion || l.nombre || '');
                const existeEnAcumulado = llantasAcumuladasEnBloque.some(x => normalizarIdentificador(x.C√≥digo || x.codigo || x.clave || x.Clave || x.ID || '', x.Descripci√≥n || x.descripcion || x.nombre || '') === idL);
                if (!existeEnAcumulado) llantasAcumuladasEnBloque.push(l);
            }
            
            // Actualizar la tabla con todas las llantas acumuladas
            actualizarTablaLlantasBloque(llantasAcumuladasEnBloque);
            
            // === MOSTRAR MODAL CON RESUMEN ===
            const htmlResumen = `
                <div style="text-align: left;">
                    <h4 style="color: #489051; margin-bottom: 15px;">üì¶ Resumen de Productos Agregados</h4>
                    
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 12px; border-left: 4px solid #28a745;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span><strong>Total de productos:</strong></span>
                            <span style="font-size: 1.2em; color: #489051;"><strong>${llantasParaAgregar.length}</strong></span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span><strong>Productos nuevos agregados al INVENTARIO:</strong></span>
                            <span style="font-size: 1.2em; color: #28a745;"><strong>${productosAgregadosAlINVENTARIO}</strong></span>
                        </div>
                    </div>
                    
                    <div style="background: #e8f5e9; padding: 12px; border-radius: 6px; border-left: 4px solid #4caf50;">
                        <strong>‚úÖ Productos ya existentes en INVENTARIO:</strong>
                        <div style="margin-top: 8px; font-size: 0.95em;">${productosYaExistentes.length} unidades</div>
                    </div>

                    ${codigosGuardados.size !== productosNuevos.length ? `
                        <div style="background: #fff3cd; padding: 12px; border-radius: 6px; margin-top: 12px; border-left: 4px solid #ffc107;">
                            <strong>‚ö†Ô∏è Duplicados evitados:</strong>
                            <div style="margin-top: 8px; font-size: 0.95em;">${productosNuevos.length - codigosGuardados.size} productos (no se agregaron)</div>
                        </div>
                    ` : ''}
                    
                    ${productosNuevos.length > 0 ? `
                        <div style="background: #e3f2fd; padding: 12px; border-radius: 6px; margin-top: 12px; border-left: 4px solid #2196f3;">
                            <strong>üÜï Productos nuevos agregados (${codigosGuardados.size}):</strong>
                            <ul style="margin: 8px 0; padding-left: 20px; font-size: 0.9em;">
                                ${productosNuevos.filter((p, idx) => {
                                    const cod = p.C√≥digo || p.codigo || p.clave || '';
                                    const desc = p.Descripci√≥n || p.descripcion || p.nombre || '';
                                    const ident = normalizarIdentificador(cod, desc);
                                    return codigosGuardados.has(ident);
                                }).map(p => `
                                    <li>${p.C√≥digo || p.codigo || 'Sin c√≥digo'} - ${p.Descripci√≥n || p.descripcion || 'Sin descripci√≥n'}</li>
                                `).join('')}
                            </ul>
                        </div>
                    ` : ''}
                    
                    <div style="margin-top: 15px; padding-top: 12px; border-top: 1px solid #ddd; color: #666; font-size: 0.9em;">
                        <strong>Resumen:</strong> ${llantasParaAgregar.length} totales | ${codigosGuardados.size} nuevas agregadas | ${productosYaExistentes.length} ya existentes
                    </div>
                </div>
            `;
            
            Swal.fire({
                title: 'Bloque agregado exitosamente',
                html: htmlResumen,
                icon: 'success',
                confirmButtonText: 'Aceptar',
                confirmButtonColor: '#489051',
                width: '550px'
            });
            
            // Mostrar mensaje de √©xito tambi√©n en el div
            divResultado.innerHTML = `
                <div class="alert alert-success">
                    <i class="bi bi-check-circle"></i> 
                    Se agregaron ${llantasParaAgregar.length} llantas al bloque. ${productosAgregadosAlINVENTARIO > 0 ? `Se a√±adieron ${productosAgregadosAlINVENTARIO} productos nuevos al INVENTARIO.` : ''} Total acumulado: ${llantasAcumuladasEnBloque.length} partidas.
                </div>`;
            document.getElementById('inputBusquedaBloqueNuevo').value = '';
        } else {
            console.log("‚ùå NO SE ENCONTRARON LLANTAS. Folio normalizado:", folio, "Folio raw:", folioRaw);
            divResultado.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-x-circle"></i> No se encontraron llantas para agregar con el folio "${folioRaw}".
                    <br><small>Buscar en: traspasos, FACTURAS, traspasos (sheet), bloques locales</small>
                </div>`;
        }
    } catch (error) {
        console.error('Error al agregar bloque:', error);
        divResultado.innerHTML = `
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> Error al agregar el bloque: ${error.message}
            </div>`;
    }
} 
    
async function generarPDFPedidosApartados() {
    // Mostrar indicador de carga
    Swal.fire({
        title: 'Actualizando datos...',
        text: 'Por favor espere mientras se obtienen los datos m√°s recientes...',
        allowOutsideClick: false,
        didOpen: () => {
            Swal.showLoading();
        }
    });

    try {
        // Forzar una actualizaci√≥n completa desde el servidor primero
        await fetchPedidosApartados();
        
        // Mostrar nuevo mensaje mientras se genera el PDF
        Swal.update({
            title: 'Generando PDF...',
            text: 'Por favor espere mientras se genera el documento...'
        });
        
        // Esperar a que el DOM se actualice: usar requestAnimationFrame para esperar al siguiente ciclo de render
        function waitForRender() {
            return new Promise(resolve => {
                // Esperar dos frames y un peque√±o timeout para asegurarnos de que el navegador pint√≥
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        setTimeout(resolve, 50);
                    });
                });      
            });
        }

        // Esperar a que la actualizaci√≥n visual se complete antes de generar el PDF
        await waitForRender();
        // Crear un contenedor temporal para el PDF
        const tempDiv = document.createElement('div');
        tempDiv.className = 'pdf-container';
        tempDiv.style.padding = '30px';
        tempDiv.style.backgroundColor = 'white';
        tempDiv.style.width = '210mm'; // Ancho de p√°gina carta
        tempDiv.style.margin = '0 auto';
        tempDiv.style.border = '2px solid #000';
        tempDiv.style.position = 'relative';
        tempDiv.style.boxSizing = 'border-box';

        // Crear el encabezado
        const header = document.createElement('div');
        header.className = 'pdf-header';
        
        // Crear el t√≠tulo con la fecha
        const today = new Date();
        const dias = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];
        const diaSemana = dias[today.getDay()].toLowerCase();
        const dia = String(today.getDate()).padStart(2, '0');
        const mes = String(today.getMonth() + 1).padStart(2, '0');
        const a√±o = today.getFullYear();
        const fechaFormateada = `${dia}/${mes}/${a√±o}`;
        
        const title = document.createElement('h3');
        title.className = 'pdf-title';
        title.textContent = `Log√≠stica-${diaSemana}-${fechaFormateada}`;
        title.style.marginBottom = '20px';
        title.style.textAlign = 'center';
        tempDiv.appendChild(title);
        
        // Asegurar que todos los datos est√©n visibles
        const searchInput = document.querySelector('#pedidos-Apartados input[type="search"]');
        const originalSearchValue = searchInput ? searchInput.value : '';
        if (searchInput) {
            searchInput.value = '';
            // Forzar actualizaci√≥n de la tabla
            actualizarTablaPedidosApartados('');
        }
        
        // Obtener la tabla original
        const originalTable = document.querySelector('#pedidos-Apartados table');
        if (!originalTable) {
            throw new Error('No se encontr√≥ la tabla de pedidos apartados');
        }
        
        // Crear nueva tabla con solo las columnas deseadas
        const newTable = document.createElement('table');
        newTable.className = 'pdf-table';
        newTable.style.width = '100%';
        newTable.style.marginTop = '20px';
        newTable.style.borderCollapse = 'collapse';
        header.appendChild(title);
        tempDiv.appendChild(header);
        
        // Copiar solo las columnas que queremos
        const columnsToKeep = ['Econ√≥mico', 'Nombre', 'Llantas'];

        // Crear el encabezado
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        columnsToKeep.forEach(colName => {
            const th = document.createElement('th');
            th.textContent = colName;
            th.style.backgroundColor = '#f8f9fa';
            th.style.border = '1px solid #dee2e6';
            th.style.padding = '8px';
            th.style.textAlign = 'center';
            th.style.fontWeight = 'bold';
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        newTable.appendChild(thead);

        // Crear el cuerpo de la tabla
        const tbody = document.createElement('tbody');
        const rows = originalTable.querySelectorAll('tbody tr');
        rows.forEach(row => {
            const newRow = document.createElement('tr');
            const cells = row.cells;
            columnsToKeep.forEach((colName, index) => {
                const cellIndex = Array.from(originalTable.querySelectorAll('th'))
                    .findIndex(th => th.textContent.trim() === colName);
                if (cellIndex !== -1 && cells[cellIndex]) {
                    const td = document.createElement('td');
                    td.textContent = cells[cellIndex].textContent;
                    td.style.border = '1px solid #dee2e6';
                    td.style.padding = '8px';
                    td.style.textAlign = 'center';
                    newRow.appendChild(td);
                }
            });
            tbody.appendChild(newRow);
        });
        newTable.appendChild(tbody);
        
        tempDiv.appendChild(newTable);

        // Agregar estilos CSS para el PDF
        const style = document.createElement('style');
        style.textContent = `
            @media print {
                @page {
                    margin: 15mm;
                    size: letter;
                }
                .pdf-container {
                    font-family: Arial, sans-serif;
                    color: #333;
                    position: relative;
                    border: 2px solid #000 !important;
                    padding: 25px !important;
                    margin: 0 auto !important;
                    box-shadow: 0 0 0 2px #000;
                    -webkit-print-color-adjust: exact;
                    print-color-adjust: exact;
                    width: 100% !important;
                }
                .pdf-table {
                    width: 100% !important;
                    margin: 20px auto !important;
                    border-collapse: collapse !important;
                    table-layout: fixed !important;
                }
                .pdf-header {
                    background: linear-gradient(to right, #f8f9fa, #e9ecef);
                    padding: 15px;
                    border-radius: 5px;
                    margin-bottom: 20px;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                }
                .pdf-title {
                    color: #2c3e50;
                    font-size: 24px;
                    text-align: center;
                    margin: 0;
                }
                .pdf-table {
                    width: 100%;
                    border-collapse: collapse;
                    background: white;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                }
                .pdf-table th {
                    background: linear-gradient(to bottom, #4a90e2, #357abd);
                    color: white;
                    font-weight: bold;
                    padding: 12px 8px;
                    text-align: center;
                    border: 1px solid #2c3e50;
                }
                .pdf-table td {
                    padding: 8px 6px;
                    border: 1px solid #dee2e6;
                    text-align: center;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    font-size: 11px;
                }
                /* Anchos espec√≠ficos para cada columna */
                .pdf-table td:nth-child(1),
                .pdf-table th:nth-child(1) { width: 100px !important; min-width: 100px !important; } /* Econ√≥mico */
                .pdf-table td:nth-child(2),
                .pdf-table th:nth-child(2) { width: auto !important; flex: 1 !important; } /* Nombre */
                .pdf-table td:nth-child(3),
                .pdf-table th:nth-child(3) { width: 80px !important; min-width: 80px !important; } /* Llantas */
                .pdf-table th {
                    width: auto;
                    padding: 8px 6px;
                    font-size: 12px;
                }
                .pdf-table th:nth-child(2) { width: 15%; } /* Econ√≥mico */
                .pdf-table th:nth-child(3) { width: 60%; } /* Nombre */
                .pdf-table th:nth-child(4) { width: 10%; } /* Llantas */
                .pdf-table tr:nth-child(even) {
                    background-color: #f8f9fa;
                }
                .pdf-table tr:hover {
                    background-color: #f2f2f2;
                }
            }
        `;
        tempDiv.appendChild(style);
        
        // Configuraci√≥n para html2pdf
        const opt = {
            margin: 10,
            filename: `logistica_${dia}${mes}${a√±o}.pdf`,
            image: { type: 'jpeg', quality: 1 },
            html2canvas: { 
                scale: 2,
                logging: true,
                letterRendering: true,
                useCORS: true,
                windowWidth: 1200,
                backgroundColor: '#ffffff'
            },
            jsPDF: {  
                unit: 'mm', 
                format: 'letter', 
                orientation: 'portrait',
                compress: true,
                precision: 16   
            },
            pagebreak: { mode: 'avoid-all' }
        };
          
        // Generar el PDF con la tabla filtrada
        try {
            await html2pdf().set(opt).from(tempDiv).save();
        } catch (pdfError) {
            console.error('Error durante html2pdf:', pdfError);
            throw pdfError; // rethrow para que el catch externo lo muestre tambi√©n
        } finally {
            // Limpiar el style agregado al head para no ensuciar el DOM
            try {
                if (style && style.parentNode) style.parentNode.removeChild(style);
            } catch (e) {
                console.warn('No se pudo remover el style del head:', e);
            }
        }

        // Restaurar el estado original de la b√∫squeda
        if (searchInput && originalSearchValue) {
            searchInput.value = originalSearchValue;
            actualizarTablaPedidosApartados(originalSearchValue);
        }

        // Mostrar mensaje de √©xito
        Swal.fire({
            icon: 'success',
            title: '¬°PDF generado con √©xito!',
            text: 'El archivo se ha descargado correctamente.',
            timer: 2000,
            showConfirmButton: false
        });
    } catch (error) {
        // Mostrar mensaje de error
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'Hubo un problema al generar el PDF: ' + error.message
        });
    }   
}
</script>
<!-- Contenedor de burbujas eliminado -->

<!-- Chart.js (si se necesita) -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<!-- Bootstrap y otros scripts -->      
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
